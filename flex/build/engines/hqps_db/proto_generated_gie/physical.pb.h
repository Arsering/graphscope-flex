// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: physical.proto

#ifndef PROTOBUF_INCLUDED_physical_2eproto
#define PROTOBUF_INCLUDED_physical_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "expr.pb.h"
#include "schema.pb.h"
#include "type.pb.h"
#include "algebra.pb.h"
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_physical_2eproto 

namespace protobuf_physical_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[25];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_physical_2eproto
namespace physical {
class Apply;
class ApplyDefaultTypeInternal;
extern ApplyDefaultTypeInternal _Apply_default_instance_;
class EdgeExpand;
class EdgeExpandDefaultTypeInternal;
extern EdgeExpandDefaultTypeInternal _EdgeExpand_default_instance_;
class GetV;
class GetVDefaultTypeInternal;
extern GetVDefaultTypeInternal _GetV_default_instance_;
class GroupBy;
class GroupByDefaultTypeInternal;
extern GroupByDefaultTypeInternal _GroupBy_default_instance_;
class GroupBy_AggFunc;
class GroupBy_AggFuncDefaultTypeInternal;
extern GroupBy_AggFuncDefaultTypeInternal _GroupBy_AggFunc_default_instance_;
class GroupBy_KeyAlias;
class GroupBy_KeyAliasDefaultTypeInternal;
extern GroupBy_KeyAliasDefaultTypeInternal _GroupBy_KeyAlias_default_instance_;
class Intersect;
class IntersectDefaultTypeInternal;
extern IntersectDefaultTypeInternal _Intersect_default_instance_;
class Join;
class JoinDefaultTypeInternal;
extern JoinDefaultTypeInternal _Join_default_instance_;
class PathExpand;
class PathExpandDefaultTypeInternal;
extern PathExpandDefaultTypeInternal _PathExpand_default_instance_;
class PathExpand_ExpandBase;
class PathExpand_ExpandBaseDefaultTypeInternal;
extern PathExpand_ExpandBaseDefaultTypeInternal _PathExpand_ExpandBase_default_instance_;
class PhysicalOpr;
class PhysicalOprDefaultTypeInternal;
extern PhysicalOprDefaultTypeInternal _PhysicalOpr_default_instance_;
class PhysicalOpr_MetaData;
class PhysicalOpr_MetaDataDefaultTypeInternal;
extern PhysicalOpr_MetaDataDefaultTypeInternal _PhysicalOpr_MetaData_default_instance_;
class PhysicalOpr_Operator;
class PhysicalOpr_OperatorDefaultTypeInternal;
extern PhysicalOpr_OperatorDefaultTypeInternal _PhysicalOpr_Operator_default_instance_;
class PhysicalPlan;
class PhysicalPlanDefaultTypeInternal;
extern PhysicalPlanDefaultTypeInternal _PhysicalPlan_default_instance_;
class Project;
class ProjectDefaultTypeInternal;
extern ProjectDefaultTypeInternal _Project_default_instance_;
class Project_ExprAlias;
class Project_ExprAliasDefaultTypeInternal;
extern Project_ExprAliasDefaultTypeInternal _Project_ExprAlias_default_instance_;
class Repartition;
class RepartitionDefaultTypeInternal;
extern RepartitionDefaultTypeInternal _Repartition_default_instance_;
class Repartition_Broadcast;
class Repartition_BroadcastDefaultTypeInternal;
extern Repartition_BroadcastDefaultTypeInternal _Repartition_Broadcast_default_instance_;
class Repartition_Shuffle;
class Repartition_ShuffleDefaultTypeInternal;
extern Repartition_ShuffleDefaultTypeInternal _Repartition_Shuffle_default_instance_;
class Root;
class RootDefaultTypeInternal;
extern RootDefaultTypeInternal _Root_default_instance_;
class Scan;
class ScanDefaultTypeInternal;
extern ScanDefaultTypeInternal _Scan_default_instance_;
class Sink;
class SinkDefaultTypeInternal;
extern SinkDefaultTypeInternal _Sink_default_instance_;
class Sink_OptTag;
class Sink_OptTagDefaultTypeInternal;
extern Sink_OptTagDefaultTypeInternal _Sink_OptTag_default_instance_;
class Unfold;
class UnfoldDefaultTypeInternal;
extern UnfoldDefaultTypeInternal _Unfold_default_instance_;
class Union;
class UnionDefaultTypeInternal;
extern UnionDefaultTypeInternal _Union_default_instance_;
}  // namespace physical
namespace google {
namespace protobuf {
template<> ::physical::Apply* Arena::CreateMaybeMessage<::physical::Apply>(Arena*);
template<> ::physical::EdgeExpand* Arena::CreateMaybeMessage<::physical::EdgeExpand>(Arena*);
template<> ::physical::GetV* Arena::CreateMaybeMessage<::physical::GetV>(Arena*);
template<> ::physical::GroupBy* Arena::CreateMaybeMessage<::physical::GroupBy>(Arena*);
template<> ::physical::GroupBy_AggFunc* Arena::CreateMaybeMessage<::physical::GroupBy_AggFunc>(Arena*);
template<> ::physical::GroupBy_KeyAlias* Arena::CreateMaybeMessage<::physical::GroupBy_KeyAlias>(Arena*);
template<> ::physical::Intersect* Arena::CreateMaybeMessage<::physical::Intersect>(Arena*);
template<> ::physical::Join* Arena::CreateMaybeMessage<::physical::Join>(Arena*);
template<> ::physical::PathExpand* Arena::CreateMaybeMessage<::physical::PathExpand>(Arena*);
template<> ::physical::PathExpand_ExpandBase* Arena::CreateMaybeMessage<::physical::PathExpand_ExpandBase>(Arena*);
template<> ::physical::PhysicalOpr* Arena::CreateMaybeMessage<::physical::PhysicalOpr>(Arena*);
template<> ::physical::PhysicalOpr_MetaData* Arena::CreateMaybeMessage<::physical::PhysicalOpr_MetaData>(Arena*);
template<> ::physical::PhysicalOpr_Operator* Arena::CreateMaybeMessage<::physical::PhysicalOpr_Operator>(Arena*);
template<> ::physical::PhysicalPlan* Arena::CreateMaybeMessage<::physical::PhysicalPlan>(Arena*);
template<> ::physical::Project* Arena::CreateMaybeMessage<::physical::Project>(Arena*);
template<> ::physical::Project_ExprAlias* Arena::CreateMaybeMessage<::physical::Project_ExprAlias>(Arena*);
template<> ::physical::Repartition* Arena::CreateMaybeMessage<::physical::Repartition>(Arena*);
template<> ::physical::Repartition_Broadcast* Arena::CreateMaybeMessage<::physical::Repartition_Broadcast>(Arena*);
template<> ::physical::Repartition_Shuffle* Arena::CreateMaybeMessage<::physical::Repartition_Shuffle>(Arena*);
template<> ::physical::Root* Arena::CreateMaybeMessage<::physical::Root>(Arena*);
template<> ::physical::Scan* Arena::CreateMaybeMessage<::physical::Scan>(Arena*);
template<> ::physical::Sink* Arena::CreateMaybeMessage<::physical::Sink>(Arena*);
template<> ::physical::Sink_OptTag* Arena::CreateMaybeMessage<::physical::Sink_OptTag>(Arena*);
template<> ::physical::Unfold* Arena::CreateMaybeMessage<::physical::Unfold>(Arena*);
template<> ::physical::Union* Arena::CreateMaybeMessage<::physical::Union>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace physical {

enum GroupBy_AggFunc_Aggregate {
  GroupBy_AggFunc_Aggregate_SUM = 0,
  GroupBy_AggFunc_Aggregate_MIN = 1,
  GroupBy_AggFunc_Aggregate_MAX = 2,
  GroupBy_AggFunc_Aggregate_COUNT = 3,
  GroupBy_AggFunc_Aggregate_COUNT_DISTINCT = 4,
  GroupBy_AggFunc_Aggregate_TO_LIST = 5,
  GroupBy_AggFunc_Aggregate_TO_SET = 6,
  GroupBy_AggFunc_Aggregate_AVG = 7,
  GroupBy_AggFunc_Aggregate_FIRST = 8,
  GroupBy_AggFunc_Aggregate_GroupBy_AggFunc_Aggregate_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GroupBy_AggFunc_Aggregate_GroupBy_AggFunc_Aggregate_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GroupBy_AggFunc_Aggregate_IsValid(int value);
const GroupBy_AggFunc_Aggregate GroupBy_AggFunc_Aggregate_Aggregate_MIN = GroupBy_AggFunc_Aggregate_SUM;
const GroupBy_AggFunc_Aggregate GroupBy_AggFunc_Aggregate_Aggregate_MAX = GroupBy_AggFunc_Aggregate_FIRST;
const int GroupBy_AggFunc_Aggregate_Aggregate_ARRAYSIZE = GroupBy_AggFunc_Aggregate_Aggregate_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupBy_AggFunc_Aggregate_descriptor();
inline const ::std::string& GroupBy_AggFunc_Aggregate_Name(GroupBy_AggFunc_Aggregate value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupBy_AggFunc_Aggregate_descriptor(), value);
}
inline bool GroupBy_AggFunc_Aggregate_Parse(
    const ::std::string& name, GroupBy_AggFunc_Aggregate* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupBy_AggFunc_Aggregate>(
    GroupBy_AggFunc_Aggregate_descriptor(), name, value);
}
enum Join_JoinKind {
  Join_JoinKind_INNER = 0,
  Join_JoinKind_LEFT_OUTER = 1,
  Join_JoinKind_RIGHT_OUTER = 2,
  Join_JoinKind_FULL_OUTER = 3,
  Join_JoinKind_SEMI = 4,
  Join_JoinKind_ANTI = 5,
  Join_JoinKind_TIMES = 6,
  Join_JoinKind_Join_JoinKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Join_JoinKind_Join_JoinKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Join_JoinKind_IsValid(int value);
const Join_JoinKind Join_JoinKind_JoinKind_MIN = Join_JoinKind_INNER;
const Join_JoinKind Join_JoinKind_JoinKind_MAX = Join_JoinKind_TIMES;
const int Join_JoinKind_JoinKind_ARRAYSIZE = Join_JoinKind_JoinKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Join_JoinKind_descriptor();
inline const ::std::string& Join_JoinKind_Name(Join_JoinKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Join_JoinKind_descriptor(), value);
}
inline bool Join_JoinKind_Parse(
    const ::std::string& name, Join_JoinKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Join_JoinKind>(
    Join_JoinKind_descriptor(), name, value);
}
enum Scan_ScanOpt {
  Scan_ScanOpt_VERTEX = 0,
  Scan_ScanOpt_EDGE = 1,
  Scan_ScanOpt_TABLE = 2,
  Scan_ScanOpt_Scan_ScanOpt_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Scan_ScanOpt_Scan_ScanOpt_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Scan_ScanOpt_IsValid(int value);
const Scan_ScanOpt Scan_ScanOpt_ScanOpt_MIN = Scan_ScanOpt_VERTEX;
const Scan_ScanOpt Scan_ScanOpt_ScanOpt_MAX = Scan_ScanOpt_TABLE;
const int Scan_ScanOpt_ScanOpt_ARRAYSIZE = Scan_ScanOpt_ScanOpt_MAX + 1;

const ::google::protobuf::EnumDescriptor* Scan_ScanOpt_descriptor();
inline const ::std::string& Scan_ScanOpt_Name(Scan_ScanOpt value) {
  return ::google::protobuf::internal::NameOfEnum(
    Scan_ScanOpt_descriptor(), value);
}
inline bool Scan_ScanOpt_Parse(
    const ::std::string& name, Scan_ScanOpt* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Scan_ScanOpt>(
    Scan_ScanOpt_descriptor(), name, value);
}
enum GetV_VOpt {
  GetV_VOpt_START = 0,
  GetV_VOpt_END = 1,
  GetV_VOpt_OTHER = 2,
  GetV_VOpt_BOTH = 3,
  GetV_VOpt_ITSELF = 4,
  GetV_VOpt_GetV_VOpt_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GetV_VOpt_GetV_VOpt_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GetV_VOpt_IsValid(int value);
const GetV_VOpt GetV_VOpt_VOpt_MIN = GetV_VOpt_START;
const GetV_VOpt GetV_VOpt_VOpt_MAX = GetV_VOpt_ITSELF;
const int GetV_VOpt_VOpt_ARRAYSIZE = GetV_VOpt_VOpt_MAX + 1;

const ::google::protobuf::EnumDescriptor* GetV_VOpt_descriptor();
inline const ::std::string& GetV_VOpt_Name(GetV_VOpt value) {
  return ::google::protobuf::internal::NameOfEnum(
    GetV_VOpt_descriptor(), value);
}
inline bool GetV_VOpt_Parse(
    const ::std::string& name, GetV_VOpt* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GetV_VOpt>(
    GetV_VOpt_descriptor(), name, value);
}
enum EdgeExpand_Direction {
  EdgeExpand_Direction_OUT = 0,
  EdgeExpand_Direction_IN = 1,
  EdgeExpand_Direction_BOTH = 2,
  EdgeExpand_Direction_EdgeExpand_Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EdgeExpand_Direction_EdgeExpand_Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EdgeExpand_Direction_IsValid(int value);
const EdgeExpand_Direction EdgeExpand_Direction_Direction_MIN = EdgeExpand_Direction_OUT;
const EdgeExpand_Direction EdgeExpand_Direction_Direction_MAX = EdgeExpand_Direction_BOTH;
const int EdgeExpand_Direction_Direction_ARRAYSIZE = EdgeExpand_Direction_Direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* EdgeExpand_Direction_descriptor();
inline const ::std::string& EdgeExpand_Direction_Name(EdgeExpand_Direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    EdgeExpand_Direction_descriptor(), value);
}
inline bool EdgeExpand_Direction_Parse(
    const ::std::string& name, EdgeExpand_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EdgeExpand_Direction>(
    EdgeExpand_Direction_descriptor(), name, value);
}
enum EdgeExpand_ExpandOpt {
  EdgeExpand_ExpandOpt_VERTEX = 0,
  EdgeExpand_ExpandOpt_EDGE = 1,
  EdgeExpand_ExpandOpt_DEGREE = 2,
  EdgeExpand_ExpandOpt_EdgeExpand_ExpandOpt_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EdgeExpand_ExpandOpt_EdgeExpand_ExpandOpt_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EdgeExpand_ExpandOpt_IsValid(int value);
const EdgeExpand_ExpandOpt EdgeExpand_ExpandOpt_ExpandOpt_MIN = EdgeExpand_ExpandOpt_VERTEX;
const EdgeExpand_ExpandOpt EdgeExpand_ExpandOpt_ExpandOpt_MAX = EdgeExpand_ExpandOpt_DEGREE;
const int EdgeExpand_ExpandOpt_ExpandOpt_ARRAYSIZE = EdgeExpand_ExpandOpt_ExpandOpt_MAX + 1;

const ::google::protobuf::EnumDescriptor* EdgeExpand_ExpandOpt_descriptor();
inline const ::std::string& EdgeExpand_ExpandOpt_Name(EdgeExpand_ExpandOpt value) {
  return ::google::protobuf::internal::NameOfEnum(
    EdgeExpand_ExpandOpt_descriptor(), value);
}
inline bool EdgeExpand_ExpandOpt_Parse(
    const ::std::string& name, EdgeExpand_ExpandOpt* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EdgeExpand_ExpandOpt>(
    EdgeExpand_ExpandOpt_descriptor(), name, value);
}
enum PathExpand_PathOpt {
  PathExpand_PathOpt_ARBITRARY = 0,
  PathExpand_PathOpt_SIMPLE = 1,
  PathExpand_PathOpt_PathExpand_PathOpt_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PathExpand_PathOpt_PathExpand_PathOpt_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PathExpand_PathOpt_IsValid(int value);
const PathExpand_PathOpt PathExpand_PathOpt_PathOpt_MIN = PathExpand_PathOpt_ARBITRARY;
const PathExpand_PathOpt PathExpand_PathOpt_PathOpt_MAX = PathExpand_PathOpt_SIMPLE;
const int PathExpand_PathOpt_PathOpt_ARRAYSIZE = PathExpand_PathOpt_PathOpt_MAX + 1;

const ::google::protobuf::EnumDescriptor* PathExpand_PathOpt_descriptor();
inline const ::std::string& PathExpand_PathOpt_Name(PathExpand_PathOpt value) {
  return ::google::protobuf::internal::NameOfEnum(
    PathExpand_PathOpt_descriptor(), value);
}
inline bool PathExpand_PathOpt_Parse(
    const ::std::string& name, PathExpand_PathOpt* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PathExpand_PathOpt>(
    PathExpand_PathOpt_descriptor(), name, value);
}
enum PathExpand_ResultOpt {
  PathExpand_ResultOpt_END_V = 0,
  PathExpand_ResultOpt_ALL_V = 1,
  PathExpand_ResultOpt_ALL_V_E = 2,
  PathExpand_ResultOpt_PathExpand_ResultOpt_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PathExpand_ResultOpt_PathExpand_ResultOpt_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PathExpand_ResultOpt_IsValid(int value);
const PathExpand_ResultOpt PathExpand_ResultOpt_ResultOpt_MIN = PathExpand_ResultOpt_END_V;
const PathExpand_ResultOpt PathExpand_ResultOpt_ResultOpt_MAX = PathExpand_ResultOpt_ALL_V_E;
const int PathExpand_ResultOpt_ResultOpt_ARRAYSIZE = PathExpand_ResultOpt_ResultOpt_MAX + 1;

const ::google::protobuf::EnumDescriptor* PathExpand_ResultOpt_descriptor();
inline const ::std::string& PathExpand_ResultOpt_Name(PathExpand_ResultOpt value) {
  return ::google::protobuf::internal::NameOfEnum(
    PathExpand_ResultOpt_descriptor(), value);
}
inline bool PathExpand_ResultOpt_Parse(
    const ::std::string& name, PathExpand_ResultOpt* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PathExpand_ResultOpt>(
    PathExpand_ResultOpt_descriptor(), name, value);
}
// ===================================================================

class Project_ExprAlias : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.Project.ExprAlias) */ {
 public:
  Project_ExprAlias();
  virtual ~Project_ExprAlias();

  Project_ExprAlias(const Project_ExprAlias& from);

  inline Project_ExprAlias& operator=(const Project_ExprAlias& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Project_ExprAlias(Project_ExprAlias&& from) noexcept
    : Project_ExprAlias() {
    *this = ::std::move(from);
  }

  inline Project_ExprAlias& operator=(Project_ExprAlias&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Project_ExprAlias& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Project_ExprAlias* internal_default_instance() {
    return reinterpret_cast<const Project_ExprAlias*>(
               &_Project_ExprAlias_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Project_ExprAlias* other);
  friend void swap(Project_ExprAlias& a, Project_ExprAlias& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Project_ExprAlias* New() const final {
    return CreateMaybeMessage<Project_ExprAlias>(NULL);
  }

  Project_ExprAlias* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Project_ExprAlias>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Project_ExprAlias& from);
  void MergeFrom(const Project_ExprAlias& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Project_ExprAlias* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.Expression expr = 1;
  bool has_expr() const;
  void clear_expr();
  static const int kExprFieldNumber = 1;
  private:
  const ::common::Expression& _internal_expr() const;
  public:
  const ::common::Expression& expr() const;
  ::common::Expression* release_expr();
  ::common::Expression* mutable_expr();
  void set_allocated_expr(::common::Expression* expr);

  // .google.protobuf.Int32Value alias = 2;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 2;
  private:
  const ::google::protobuf::Int32Value& _internal_alias() const;
  public:
  const ::google::protobuf::Int32Value& alias() const;
  ::google::protobuf::Int32Value* release_alias();
  ::google::protobuf::Int32Value* mutable_alias();
  void set_allocated_alias(::google::protobuf::Int32Value* alias);

  // @@protoc_insertion_point(class_scope:physical.Project.ExprAlias)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::Expression* expr_;
  ::google::protobuf::Int32Value* alias_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Project : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.Project) */ {
 public:
  Project();
  virtual ~Project();

  Project(const Project& from);

  inline Project& operator=(const Project& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Project(Project&& from) noexcept
    : Project() {
    *this = ::std::move(from);
  }

  inline Project& operator=(Project&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Project& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Project* internal_default_instance() {
    return reinterpret_cast<const Project*>(
               &_Project_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Project* other);
  friend void swap(Project& a, Project& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Project* New() const final {
    return CreateMaybeMessage<Project>(NULL);
  }

  Project* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Project>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Project& from);
  void MergeFrom(const Project& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Project* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Project_ExprAlias ExprAlias;

  // accessors -------------------------------------------------------

  // repeated .physical.Project.ExprAlias mappings = 1;
  int mappings_size() const;
  void clear_mappings();
  static const int kMappingsFieldNumber = 1;
  ::physical::Project_ExprAlias* mutable_mappings(int index);
  ::google::protobuf::RepeatedPtrField< ::physical::Project_ExprAlias >*
      mutable_mappings();
  const ::physical::Project_ExprAlias& mappings(int index) const;
  ::physical::Project_ExprAlias* add_mappings();
  const ::google::protobuf::RepeatedPtrField< ::physical::Project_ExprAlias >&
      mappings() const;

  // bool is_append = 2;
  void clear_is_append();
  static const int kIsAppendFieldNumber = 2;
  bool is_append() const;
  void set_is_append(bool value);

  // @@protoc_insertion_point(class_scope:physical.Project)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::physical::Project_ExprAlias > mappings_;
  bool is_append_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroupBy_AggFunc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.GroupBy.AggFunc) */ {
 public:
  GroupBy_AggFunc();
  virtual ~GroupBy_AggFunc();

  GroupBy_AggFunc(const GroupBy_AggFunc& from);

  inline GroupBy_AggFunc& operator=(const GroupBy_AggFunc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroupBy_AggFunc(GroupBy_AggFunc&& from) noexcept
    : GroupBy_AggFunc() {
    *this = ::std::move(from);
  }

  inline GroupBy_AggFunc& operator=(GroupBy_AggFunc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupBy_AggFunc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GroupBy_AggFunc* internal_default_instance() {
    return reinterpret_cast<const GroupBy_AggFunc*>(
               &_GroupBy_AggFunc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(GroupBy_AggFunc* other);
  friend void swap(GroupBy_AggFunc& a, GroupBy_AggFunc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroupBy_AggFunc* New() const final {
    return CreateMaybeMessage<GroupBy_AggFunc>(NULL);
  }

  GroupBy_AggFunc* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GroupBy_AggFunc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GroupBy_AggFunc& from);
  void MergeFrom(const GroupBy_AggFunc& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupBy_AggFunc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GroupBy_AggFunc_Aggregate Aggregate;
  static const Aggregate SUM =
    GroupBy_AggFunc_Aggregate_SUM;
  static const Aggregate MIN =
    GroupBy_AggFunc_Aggregate_MIN;
  static const Aggregate MAX =
    GroupBy_AggFunc_Aggregate_MAX;
  static const Aggregate COUNT =
    GroupBy_AggFunc_Aggregate_COUNT;
  static const Aggregate COUNT_DISTINCT =
    GroupBy_AggFunc_Aggregate_COUNT_DISTINCT;
  static const Aggregate TO_LIST =
    GroupBy_AggFunc_Aggregate_TO_LIST;
  static const Aggregate TO_SET =
    GroupBy_AggFunc_Aggregate_TO_SET;
  static const Aggregate AVG =
    GroupBy_AggFunc_Aggregate_AVG;
  static const Aggregate FIRST =
    GroupBy_AggFunc_Aggregate_FIRST;
  static inline bool Aggregate_IsValid(int value) {
    return GroupBy_AggFunc_Aggregate_IsValid(value);
  }
  static const Aggregate Aggregate_MIN =
    GroupBy_AggFunc_Aggregate_Aggregate_MIN;
  static const Aggregate Aggregate_MAX =
    GroupBy_AggFunc_Aggregate_Aggregate_MAX;
  static const int Aggregate_ARRAYSIZE =
    GroupBy_AggFunc_Aggregate_Aggregate_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Aggregate_descriptor() {
    return GroupBy_AggFunc_Aggregate_descriptor();
  }
  static inline const ::std::string& Aggregate_Name(Aggregate value) {
    return GroupBy_AggFunc_Aggregate_Name(value);
  }
  static inline bool Aggregate_Parse(const ::std::string& name,
      Aggregate* value) {
    return GroupBy_AggFunc_Aggregate_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .common.Variable vars = 1;
  int vars_size() const;
  void clear_vars();
  static const int kVarsFieldNumber = 1;
  ::common::Variable* mutable_vars(int index);
  ::google::protobuf::RepeatedPtrField< ::common::Variable >*
      mutable_vars();
  const ::common::Variable& vars(int index) const;
  ::common::Variable* add_vars();
  const ::google::protobuf::RepeatedPtrField< ::common::Variable >&
      vars() const;

  // .google.protobuf.Int32Value alias = 3;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 3;
  private:
  const ::google::protobuf::Int32Value& _internal_alias() const;
  public:
  const ::google::protobuf::Int32Value& alias() const;
  ::google::protobuf::Int32Value* release_alias();
  ::google::protobuf::Int32Value* mutable_alias();
  void set_allocated_alias(::google::protobuf::Int32Value* alias);

  // .physical.GroupBy.AggFunc.Aggregate aggregate = 2;
  void clear_aggregate();
  static const int kAggregateFieldNumber = 2;
  ::physical::GroupBy_AggFunc_Aggregate aggregate() const;
  void set_aggregate(::physical::GroupBy_AggFunc_Aggregate value);

  // @@protoc_insertion_point(class_scope:physical.GroupBy.AggFunc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::common::Variable > vars_;
  ::google::protobuf::Int32Value* alias_;
  int aggregate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroupBy_KeyAlias : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.GroupBy.KeyAlias) */ {
 public:
  GroupBy_KeyAlias();
  virtual ~GroupBy_KeyAlias();

  GroupBy_KeyAlias(const GroupBy_KeyAlias& from);

  inline GroupBy_KeyAlias& operator=(const GroupBy_KeyAlias& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroupBy_KeyAlias(GroupBy_KeyAlias&& from) noexcept
    : GroupBy_KeyAlias() {
    *this = ::std::move(from);
  }

  inline GroupBy_KeyAlias& operator=(GroupBy_KeyAlias&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupBy_KeyAlias& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GroupBy_KeyAlias* internal_default_instance() {
    return reinterpret_cast<const GroupBy_KeyAlias*>(
               &_GroupBy_KeyAlias_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GroupBy_KeyAlias* other);
  friend void swap(GroupBy_KeyAlias& a, GroupBy_KeyAlias& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroupBy_KeyAlias* New() const final {
    return CreateMaybeMessage<GroupBy_KeyAlias>(NULL);
  }

  GroupBy_KeyAlias* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GroupBy_KeyAlias>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GroupBy_KeyAlias& from);
  void MergeFrom(const GroupBy_KeyAlias& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupBy_KeyAlias* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.Variable key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  private:
  const ::common::Variable& _internal_key() const;
  public:
  const ::common::Variable& key() const;
  ::common::Variable* release_key();
  ::common::Variable* mutable_key();
  void set_allocated_key(::common::Variable* key);

  // .google.protobuf.Int32Value alias = 2;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 2;
  private:
  const ::google::protobuf::Int32Value& _internal_alias() const;
  public:
  const ::google::protobuf::Int32Value& alias() const;
  ::google::protobuf::Int32Value* release_alias();
  ::google::protobuf::Int32Value* mutable_alias();
  void set_allocated_alias(::google::protobuf::Int32Value* alias);

  // @@protoc_insertion_point(class_scope:physical.GroupBy.KeyAlias)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::Variable* key_;
  ::google::protobuf::Int32Value* alias_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroupBy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.GroupBy) */ {
 public:
  GroupBy();
  virtual ~GroupBy();

  GroupBy(const GroupBy& from);

  inline GroupBy& operator=(const GroupBy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroupBy(GroupBy&& from) noexcept
    : GroupBy() {
    *this = ::std::move(from);
  }

  inline GroupBy& operator=(GroupBy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupBy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GroupBy* internal_default_instance() {
    return reinterpret_cast<const GroupBy*>(
               &_GroupBy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(GroupBy* other);
  friend void swap(GroupBy& a, GroupBy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroupBy* New() const final {
    return CreateMaybeMessage<GroupBy>(NULL);
  }

  GroupBy* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GroupBy>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GroupBy& from);
  void MergeFrom(const GroupBy& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupBy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GroupBy_AggFunc AggFunc;
  typedef GroupBy_KeyAlias KeyAlias;

  // accessors -------------------------------------------------------

  // repeated .physical.GroupBy.KeyAlias mappings = 1;
  int mappings_size() const;
  void clear_mappings();
  static const int kMappingsFieldNumber = 1;
  ::physical::GroupBy_KeyAlias* mutable_mappings(int index);
  ::google::protobuf::RepeatedPtrField< ::physical::GroupBy_KeyAlias >*
      mutable_mappings();
  const ::physical::GroupBy_KeyAlias& mappings(int index) const;
  ::physical::GroupBy_KeyAlias* add_mappings();
  const ::google::protobuf::RepeatedPtrField< ::physical::GroupBy_KeyAlias >&
      mappings() const;

  // repeated .physical.GroupBy.AggFunc functions = 2;
  int functions_size() const;
  void clear_functions();
  static const int kFunctionsFieldNumber = 2;
  ::physical::GroupBy_AggFunc* mutable_functions(int index);
  ::google::protobuf::RepeatedPtrField< ::physical::GroupBy_AggFunc >*
      mutable_functions();
  const ::physical::GroupBy_AggFunc& functions(int index) const;
  ::physical::GroupBy_AggFunc* add_functions();
  const ::google::protobuf::RepeatedPtrField< ::physical::GroupBy_AggFunc >&
      functions() const;

  // @@protoc_insertion_point(class_scope:physical.GroupBy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::physical::GroupBy_KeyAlias > mappings_;
  ::google::protobuf::RepeatedPtrField< ::physical::GroupBy_AggFunc > functions_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Unfold : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.Unfold) */ {
 public:
  Unfold();
  virtual ~Unfold();

  Unfold(const Unfold& from);

  inline Unfold& operator=(const Unfold& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Unfold(Unfold&& from) noexcept
    : Unfold() {
    *this = ::std::move(from);
  }

  inline Unfold& operator=(Unfold&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Unfold& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Unfold* internal_default_instance() {
    return reinterpret_cast<const Unfold*>(
               &_Unfold_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Unfold* other);
  friend void swap(Unfold& a, Unfold& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Unfold* New() const final {
    return CreateMaybeMessage<Unfold>(NULL);
  }

  Unfold* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Unfold>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Unfold& from);
  void MergeFrom(const Unfold& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Unfold* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Int32Value tag = 1;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  private:
  const ::google::protobuf::Int32Value& _internal_tag() const;
  public:
  const ::google::protobuf::Int32Value& tag() const;
  ::google::protobuf::Int32Value* release_tag();
  ::google::protobuf::Int32Value* mutable_tag();
  void set_allocated_tag(::google::protobuf::Int32Value* tag);

  // .google.protobuf.Int32Value alias = 2;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 2;
  private:
  const ::google::protobuf::Int32Value& _internal_alias() const;
  public:
  const ::google::protobuf::Int32Value& alias() const;
  ::google::protobuf::Int32Value* release_alias();
  ::google::protobuf::Int32Value* mutable_alias();
  void set_allocated_alias(::google::protobuf::Int32Value* alias);

  // @@protoc_insertion_point(class_scope:physical.Unfold)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Int32Value* tag_;
  ::google::protobuf::Int32Value* alias_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Union : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.Union) */ {
 public:
  Union();
  virtual ~Union();

  Union(const Union& from);

  inline Union& operator=(const Union& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Union(Union&& from) noexcept
    : Union() {
    *this = ::std::move(from);
  }

  inline Union& operator=(Union&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Union& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Union* internal_default_instance() {
    return reinterpret_cast<const Union*>(
               &_Union_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Union* other);
  friend void swap(Union& a, Union& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Union* New() const final {
    return CreateMaybeMessage<Union>(NULL);
  }

  Union* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Union>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Union& from);
  void MergeFrom(const Union& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Union* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .physical.PhysicalPlan sub_plans = 1;
  int sub_plans_size() const;
  void clear_sub_plans();
  static const int kSubPlansFieldNumber = 1;
  ::physical::PhysicalPlan* mutable_sub_plans(int index);
  ::google::protobuf::RepeatedPtrField< ::physical::PhysicalPlan >*
      mutable_sub_plans();
  const ::physical::PhysicalPlan& sub_plans(int index) const;
  ::physical::PhysicalPlan* add_sub_plans();
  const ::google::protobuf::RepeatedPtrField< ::physical::PhysicalPlan >&
      sub_plans() const;

  // @@protoc_insertion_point(class_scope:physical.Union)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::physical::PhysicalPlan > sub_plans_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Intersect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.Intersect) */ {
 public:
  Intersect();
  virtual ~Intersect();

  Intersect(const Intersect& from);

  inline Intersect& operator=(const Intersect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Intersect(Intersect&& from) noexcept
    : Intersect() {
    *this = ::std::move(from);
  }

  inline Intersect& operator=(Intersect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Intersect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Intersect* internal_default_instance() {
    return reinterpret_cast<const Intersect*>(
               &_Intersect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Intersect* other);
  friend void swap(Intersect& a, Intersect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Intersect* New() const final {
    return CreateMaybeMessage<Intersect>(NULL);
  }

  Intersect* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Intersect>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Intersect& from);
  void MergeFrom(const Intersect& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Intersect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .physical.PhysicalPlan sub_plans = 1;
  int sub_plans_size() const;
  void clear_sub_plans();
  static const int kSubPlansFieldNumber = 1;
  ::physical::PhysicalPlan* mutable_sub_plans(int index);
  ::google::protobuf::RepeatedPtrField< ::physical::PhysicalPlan >*
      mutable_sub_plans();
  const ::physical::PhysicalPlan& sub_plans(int index) const;
  ::physical::PhysicalPlan* add_sub_plans();
  const ::google::protobuf::RepeatedPtrField< ::physical::PhysicalPlan >&
      sub_plans() const;

  // int32 key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  ::google::protobuf::int32 key() const;
  void set_key(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:physical.Intersect)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::physical::PhysicalPlan > sub_plans_;
  ::google::protobuf::int32 key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Join : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.Join) */ {
 public:
  Join();
  virtual ~Join();

  Join(const Join& from);

  inline Join& operator=(const Join& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Join(Join&& from) noexcept
    : Join() {
    *this = ::std::move(from);
  }

  inline Join& operator=(Join&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Join& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Join* internal_default_instance() {
    return reinterpret_cast<const Join*>(
               &_Join_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Join* other);
  friend void swap(Join& a, Join& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Join* New() const final {
    return CreateMaybeMessage<Join>(NULL);
  }

  Join* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Join>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Join& from);
  void MergeFrom(const Join& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Join* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Join_JoinKind JoinKind;
  static const JoinKind INNER =
    Join_JoinKind_INNER;
  static const JoinKind LEFT_OUTER =
    Join_JoinKind_LEFT_OUTER;
  static const JoinKind RIGHT_OUTER =
    Join_JoinKind_RIGHT_OUTER;
  static const JoinKind FULL_OUTER =
    Join_JoinKind_FULL_OUTER;
  static const JoinKind SEMI =
    Join_JoinKind_SEMI;
  static const JoinKind ANTI =
    Join_JoinKind_ANTI;
  static const JoinKind TIMES =
    Join_JoinKind_TIMES;
  static inline bool JoinKind_IsValid(int value) {
    return Join_JoinKind_IsValid(value);
  }
  static const JoinKind JoinKind_MIN =
    Join_JoinKind_JoinKind_MIN;
  static const JoinKind JoinKind_MAX =
    Join_JoinKind_JoinKind_MAX;
  static const int JoinKind_ARRAYSIZE =
    Join_JoinKind_JoinKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  JoinKind_descriptor() {
    return Join_JoinKind_descriptor();
  }
  static inline const ::std::string& JoinKind_Name(JoinKind value) {
    return Join_JoinKind_Name(value);
  }
  static inline bool JoinKind_Parse(const ::std::string& name,
      JoinKind* value) {
    return Join_JoinKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .common.Variable left_keys = 1;
  int left_keys_size() const;
  void clear_left_keys();
  static const int kLeftKeysFieldNumber = 1;
  ::common::Variable* mutable_left_keys(int index);
  ::google::protobuf::RepeatedPtrField< ::common::Variable >*
      mutable_left_keys();
  const ::common::Variable& left_keys(int index) const;
  ::common::Variable* add_left_keys();
  const ::google::protobuf::RepeatedPtrField< ::common::Variable >&
      left_keys() const;

  // repeated .common.Variable right_keys = 2;
  int right_keys_size() const;
  void clear_right_keys();
  static const int kRightKeysFieldNumber = 2;
  ::common::Variable* mutable_right_keys(int index);
  ::google::protobuf::RepeatedPtrField< ::common::Variable >*
      mutable_right_keys();
  const ::common::Variable& right_keys(int index) const;
  ::common::Variable* add_right_keys();
  const ::google::protobuf::RepeatedPtrField< ::common::Variable >&
      right_keys() const;

  // .physical.PhysicalPlan left_plan = 4;
  bool has_left_plan() const;
  void clear_left_plan();
  static const int kLeftPlanFieldNumber = 4;
  private:
  const ::physical::PhysicalPlan& _internal_left_plan() const;
  public:
  const ::physical::PhysicalPlan& left_plan() const;
  ::physical::PhysicalPlan* release_left_plan();
  ::physical::PhysicalPlan* mutable_left_plan();
  void set_allocated_left_plan(::physical::PhysicalPlan* left_plan);

  // .physical.PhysicalPlan right_plan = 5;
  bool has_right_plan() const;
  void clear_right_plan();
  static const int kRightPlanFieldNumber = 5;
  private:
  const ::physical::PhysicalPlan& _internal_right_plan() const;
  public:
  const ::physical::PhysicalPlan& right_plan() const;
  ::physical::PhysicalPlan* release_right_plan();
  ::physical::PhysicalPlan* mutable_right_plan();
  void set_allocated_right_plan(::physical::PhysicalPlan* right_plan);

  // .physical.Join.JoinKind join_kind = 3;
  void clear_join_kind();
  static const int kJoinKindFieldNumber = 3;
  ::physical::Join_JoinKind join_kind() const;
  void set_join_kind(::physical::Join_JoinKind value);

  // @@protoc_insertion_point(class_scope:physical.Join)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::common::Variable > left_keys_;
  ::google::protobuf::RepeatedPtrField< ::common::Variable > right_keys_;
  ::physical::PhysicalPlan* left_plan_;
  ::physical::PhysicalPlan* right_plan_;
  int join_kind_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Apply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.Apply) */ {
 public:
  Apply();
  virtual ~Apply();

  Apply(const Apply& from);

  inline Apply& operator=(const Apply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Apply(Apply&& from) noexcept
    : Apply() {
    *this = ::std::move(from);
  }

  inline Apply& operator=(Apply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Apply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Apply* internal_default_instance() {
    return reinterpret_cast<const Apply*>(
               &_Apply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Apply* other);
  friend void swap(Apply& a, Apply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Apply* New() const final {
    return CreateMaybeMessage<Apply>(NULL);
  }

  Apply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Apply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Apply& from);
  void MergeFrom(const Apply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Apply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .common.Variable keys = 2;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 2;
  ::common::Variable* mutable_keys(int index);
  ::google::protobuf::RepeatedPtrField< ::common::Variable >*
      mutable_keys();
  const ::common::Variable& keys(int index) const;
  ::common::Variable* add_keys();
  const ::google::protobuf::RepeatedPtrField< ::common::Variable >&
      keys() const;

  // .physical.PhysicalPlan sub_plan = 3;
  bool has_sub_plan() const;
  void clear_sub_plan();
  static const int kSubPlanFieldNumber = 3;
  private:
  const ::physical::PhysicalPlan& _internal_sub_plan() const;
  public:
  const ::physical::PhysicalPlan& sub_plan() const;
  ::physical::PhysicalPlan* release_sub_plan();
  ::physical::PhysicalPlan* mutable_sub_plan();
  void set_allocated_sub_plan(::physical::PhysicalPlan* sub_plan);

  // .google.protobuf.Int32Value alias = 4;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 4;
  private:
  const ::google::protobuf::Int32Value& _internal_alias() const;
  public:
  const ::google::protobuf::Int32Value& alias() const;
  ::google::protobuf::Int32Value* release_alias();
  ::google::protobuf::Int32Value* mutable_alias();
  void set_allocated_alias(::google::protobuf::Int32Value* alias);

  // .physical.Join.JoinKind join_kind = 1;
  void clear_join_kind();
  static const int kJoinKindFieldNumber = 1;
  ::physical::Join_JoinKind join_kind() const;
  void set_join_kind(::physical::Join_JoinKind value);

  // @@protoc_insertion_point(class_scope:physical.Apply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::common::Variable > keys_;
  ::physical::PhysicalPlan* sub_plan_;
  ::google::protobuf::Int32Value* alias_;
  int join_kind_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.Scan) */ {
 public:
  Scan();
  virtual ~Scan();

  Scan(const Scan& from);

  inline Scan& operator=(const Scan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scan(Scan&& from) noexcept
    : Scan() {
    *this = ::std::move(from);
  }

  inline Scan& operator=(Scan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scan* internal_default_instance() {
    return reinterpret_cast<const Scan*>(
               &_Scan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Scan* other);
  friend void swap(Scan& a, Scan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scan* New() const final {
    return CreateMaybeMessage<Scan>(NULL);
  }

  Scan* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scan>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scan& from);
  void MergeFrom(const Scan& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Scan_ScanOpt ScanOpt;
  static const ScanOpt VERTEX =
    Scan_ScanOpt_VERTEX;
  static const ScanOpt EDGE =
    Scan_ScanOpt_EDGE;
  static const ScanOpt TABLE =
    Scan_ScanOpt_TABLE;
  static inline bool ScanOpt_IsValid(int value) {
    return Scan_ScanOpt_IsValid(value);
  }
  static const ScanOpt ScanOpt_MIN =
    Scan_ScanOpt_ScanOpt_MIN;
  static const ScanOpt ScanOpt_MAX =
    Scan_ScanOpt_ScanOpt_MAX;
  static const int ScanOpt_ARRAYSIZE =
    Scan_ScanOpt_ScanOpt_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ScanOpt_descriptor() {
    return Scan_ScanOpt_descriptor();
  }
  static inline const ::std::string& ScanOpt_Name(ScanOpt value) {
    return Scan_ScanOpt_Name(value);
  }
  static inline bool ScanOpt_Parse(const ::std::string& name,
      ScanOpt* value) {
    return Scan_ScanOpt_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .google.protobuf.Int32Value alias = 2;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 2;
  private:
  const ::google::protobuf::Int32Value& _internal_alias() const;
  public:
  const ::google::protobuf::Int32Value& alias() const;
  ::google::protobuf::Int32Value* release_alias();
  ::google::protobuf::Int32Value* mutable_alias();
  void set_allocated_alias(::google::protobuf::Int32Value* alias);

  // .algebra.QueryParams params = 3;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 3;
  private:
  const ::algebra::QueryParams& _internal_params() const;
  public:
  const ::algebra::QueryParams& params() const;
  ::algebra::QueryParams* release_params();
  ::algebra::QueryParams* mutable_params();
  void set_allocated_params(::algebra::QueryParams* params);

  // .algebra.IndexPredicate idx_predicate = 4;
  bool has_idx_predicate() const;
  void clear_idx_predicate();
  static const int kIdxPredicateFieldNumber = 4;
  private:
  const ::algebra::IndexPredicate& _internal_idx_predicate() const;
  public:
  const ::algebra::IndexPredicate& idx_predicate() const;
  ::algebra::IndexPredicate* release_idx_predicate();
  ::algebra::IndexPredicate* mutable_idx_predicate();
  void set_allocated_idx_predicate(::algebra::IndexPredicate* idx_predicate);

  // .physical.Scan.ScanOpt scan_opt = 1;
  void clear_scan_opt();
  static const int kScanOptFieldNumber = 1;
  ::physical::Scan_ScanOpt scan_opt() const;
  void set_scan_opt(::physical::Scan_ScanOpt value);

  // @@protoc_insertion_point(class_scope:physical.Scan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Int32Value* alias_;
  ::algebra::QueryParams* params_;
  ::algebra::IndexPredicate* idx_predicate_;
  int scan_opt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetV : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.GetV) */ {
 public:
  GetV();
  virtual ~GetV();

  GetV(const GetV& from);

  inline GetV& operator=(const GetV& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetV(GetV&& from) noexcept
    : GetV() {
    *this = ::std::move(from);
  }

  inline GetV& operator=(GetV&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetV& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetV* internal_default_instance() {
    return reinterpret_cast<const GetV*>(
               &_GetV_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(GetV* other);
  friend void swap(GetV& a, GetV& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetV* New() const final {
    return CreateMaybeMessage<GetV>(NULL);
  }

  GetV* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetV>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetV& from);
  void MergeFrom(const GetV& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetV* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetV_VOpt VOpt;
  static const VOpt START =
    GetV_VOpt_START;
  static const VOpt END =
    GetV_VOpt_END;
  static const VOpt OTHER =
    GetV_VOpt_OTHER;
  static const VOpt BOTH =
    GetV_VOpt_BOTH;
  static const VOpt ITSELF =
    GetV_VOpt_ITSELF;
  static inline bool VOpt_IsValid(int value) {
    return GetV_VOpt_IsValid(value);
  }
  static const VOpt VOpt_MIN =
    GetV_VOpt_VOpt_MIN;
  static const VOpt VOpt_MAX =
    GetV_VOpt_VOpt_MAX;
  static const int VOpt_ARRAYSIZE =
    GetV_VOpt_VOpt_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VOpt_descriptor() {
    return GetV_VOpt_descriptor();
  }
  static inline const ::std::string& VOpt_Name(VOpt value) {
    return GetV_VOpt_Name(value);
  }
  static inline bool VOpt_Parse(const ::std::string& name,
      VOpt* value) {
    return GetV_VOpt_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .google.protobuf.Int32Value tag = 1;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  private:
  const ::google::protobuf::Int32Value& _internal_tag() const;
  public:
  const ::google::protobuf::Int32Value& tag() const;
  ::google::protobuf::Int32Value* release_tag();
  ::google::protobuf::Int32Value* mutable_tag();
  void set_allocated_tag(::google::protobuf::Int32Value* tag);

  // .algebra.QueryParams params = 3;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 3;
  private:
  const ::algebra::QueryParams& _internal_params() const;
  public:
  const ::algebra::QueryParams& params() const;
  ::algebra::QueryParams* release_params();
  ::algebra::QueryParams* mutable_params();
  void set_allocated_params(::algebra::QueryParams* params);

  // .google.protobuf.Int32Value alias = 4;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 4;
  private:
  const ::google::protobuf::Int32Value& _internal_alias() const;
  public:
  const ::google::protobuf::Int32Value& alias() const;
  ::google::protobuf::Int32Value* release_alias();
  ::google::protobuf::Int32Value* mutable_alias();
  void set_allocated_alias(::google::protobuf::Int32Value* alias);

  // .physical.GetV.VOpt opt = 2;
  void clear_opt();
  static const int kOptFieldNumber = 2;
  ::physical::GetV_VOpt opt() const;
  void set_opt(::physical::GetV_VOpt value);

  // @@protoc_insertion_point(class_scope:physical.GetV)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Int32Value* tag_;
  ::algebra::QueryParams* params_;
  ::google::protobuf::Int32Value* alias_;
  int opt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EdgeExpand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.EdgeExpand) */ {
 public:
  EdgeExpand();
  virtual ~EdgeExpand();

  EdgeExpand(const EdgeExpand& from);

  inline EdgeExpand& operator=(const EdgeExpand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EdgeExpand(EdgeExpand&& from) noexcept
    : EdgeExpand() {
    *this = ::std::move(from);
  }

  inline EdgeExpand& operator=(EdgeExpand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EdgeExpand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EdgeExpand* internal_default_instance() {
    return reinterpret_cast<const EdgeExpand*>(
               &_EdgeExpand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(EdgeExpand* other);
  friend void swap(EdgeExpand& a, EdgeExpand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EdgeExpand* New() const final {
    return CreateMaybeMessage<EdgeExpand>(NULL);
  }

  EdgeExpand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EdgeExpand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EdgeExpand& from);
  void MergeFrom(const EdgeExpand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EdgeExpand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EdgeExpand_Direction Direction;
  static const Direction OUT =
    EdgeExpand_Direction_OUT;
  static const Direction IN =
    EdgeExpand_Direction_IN;
  static const Direction BOTH =
    EdgeExpand_Direction_BOTH;
  static inline bool Direction_IsValid(int value) {
    return EdgeExpand_Direction_IsValid(value);
  }
  static const Direction Direction_MIN =
    EdgeExpand_Direction_Direction_MIN;
  static const Direction Direction_MAX =
    EdgeExpand_Direction_Direction_MAX;
  static const int Direction_ARRAYSIZE =
    EdgeExpand_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Direction_descriptor() {
    return EdgeExpand_Direction_descriptor();
  }
  static inline const ::std::string& Direction_Name(Direction value) {
    return EdgeExpand_Direction_Name(value);
  }
  static inline bool Direction_Parse(const ::std::string& name,
      Direction* value) {
    return EdgeExpand_Direction_Parse(name, value);
  }

  typedef EdgeExpand_ExpandOpt ExpandOpt;
  static const ExpandOpt VERTEX =
    EdgeExpand_ExpandOpt_VERTEX;
  static const ExpandOpt EDGE =
    EdgeExpand_ExpandOpt_EDGE;
  static const ExpandOpt DEGREE =
    EdgeExpand_ExpandOpt_DEGREE;
  static inline bool ExpandOpt_IsValid(int value) {
    return EdgeExpand_ExpandOpt_IsValid(value);
  }
  static const ExpandOpt ExpandOpt_MIN =
    EdgeExpand_ExpandOpt_ExpandOpt_MIN;
  static const ExpandOpt ExpandOpt_MAX =
    EdgeExpand_ExpandOpt_ExpandOpt_MAX;
  static const int ExpandOpt_ARRAYSIZE =
    EdgeExpand_ExpandOpt_ExpandOpt_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ExpandOpt_descriptor() {
    return EdgeExpand_ExpandOpt_descriptor();
  }
  static inline const ::std::string& ExpandOpt_Name(ExpandOpt value) {
    return EdgeExpand_ExpandOpt_Name(value);
  }
  static inline bool ExpandOpt_Parse(const ::std::string& name,
      ExpandOpt* value) {
    return EdgeExpand_ExpandOpt_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .google.protobuf.Int32Value v_tag = 1;
  bool has_v_tag() const;
  void clear_v_tag();
  static const int kVTagFieldNumber = 1;
  private:
  const ::google::protobuf::Int32Value& _internal_v_tag() const;
  public:
  const ::google::protobuf::Int32Value& v_tag() const;
  ::google::protobuf::Int32Value* release_v_tag();
  ::google::protobuf::Int32Value* mutable_v_tag();
  void set_allocated_v_tag(::google::protobuf::Int32Value* v_tag);

  // .algebra.QueryParams params = 3;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 3;
  private:
  const ::algebra::QueryParams& _internal_params() const;
  public:
  const ::algebra::QueryParams& params() const;
  ::algebra::QueryParams* release_params();
  ::algebra::QueryParams* mutable_params();
  void set_allocated_params(::algebra::QueryParams* params);

  // .google.protobuf.Int32Value alias = 4;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 4;
  private:
  const ::google::protobuf::Int32Value& _internal_alias() const;
  public:
  const ::google::protobuf::Int32Value& alias() const;
  ::google::protobuf::Int32Value* release_alias();
  ::google::protobuf::Int32Value* mutable_alias();
  void set_allocated_alias(::google::protobuf::Int32Value* alias);

  // .physical.EdgeExpand.Direction direction = 2;
  void clear_direction();
  static const int kDirectionFieldNumber = 2;
  ::physical::EdgeExpand_Direction direction() const;
  void set_direction(::physical::EdgeExpand_Direction value);

  // .physical.EdgeExpand.ExpandOpt expand_opt = 5;
  void clear_expand_opt();
  static const int kExpandOptFieldNumber = 5;
  ::physical::EdgeExpand_ExpandOpt expand_opt() const;
  void set_expand_opt(::physical::EdgeExpand_ExpandOpt value);

  // @@protoc_insertion_point(class_scope:physical.EdgeExpand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Int32Value* v_tag_;
  ::algebra::QueryParams* params_;
  ::google::protobuf::Int32Value* alias_;
  int direction_;
  int expand_opt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PathExpand_ExpandBase : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.PathExpand.ExpandBase) */ {
 public:
  PathExpand_ExpandBase();
  virtual ~PathExpand_ExpandBase();

  PathExpand_ExpandBase(const PathExpand_ExpandBase& from);

  inline PathExpand_ExpandBase& operator=(const PathExpand_ExpandBase& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PathExpand_ExpandBase(PathExpand_ExpandBase&& from) noexcept
    : PathExpand_ExpandBase() {
    *this = ::std::move(from);
  }

  inline PathExpand_ExpandBase& operator=(PathExpand_ExpandBase&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PathExpand_ExpandBase& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PathExpand_ExpandBase* internal_default_instance() {
    return reinterpret_cast<const PathExpand_ExpandBase*>(
               &_PathExpand_ExpandBase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(PathExpand_ExpandBase* other);
  friend void swap(PathExpand_ExpandBase& a, PathExpand_ExpandBase& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PathExpand_ExpandBase* New() const final {
    return CreateMaybeMessage<PathExpand_ExpandBase>(NULL);
  }

  PathExpand_ExpandBase* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PathExpand_ExpandBase>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PathExpand_ExpandBase& from);
  void MergeFrom(const PathExpand_ExpandBase& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathExpand_ExpandBase* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .physical.EdgeExpand edge_expand = 1;
  bool has_edge_expand() const;
  void clear_edge_expand();
  static const int kEdgeExpandFieldNumber = 1;
  private:
  const ::physical::EdgeExpand& _internal_edge_expand() const;
  public:
  const ::physical::EdgeExpand& edge_expand() const;
  ::physical::EdgeExpand* release_edge_expand();
  ::physical::EdgeExpand* mutable_edge_expand();
  void set_allocated_edge_expand(::physical::EdgeExpand* edge_expand);

  // .physical.GetV get_V = 2;
  bool has_get_v() const;
  void clear_get_v();
  static const int kGetVFieldNumber = 2;
  private:
  const ::physical::GetV& _internal_get_v() const;
  public:
  const ::physical::GetV& get_v() const;
  ::physical::GetV* release_get_v();
  ::physical::GetV* mutable_get_v();
  void set_allocated_get_v(::physical::GetV* get_v);

  // @@protoc_insertion_point(class_scope:physical.PathExpand.ExpandBase)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::physical::EdgeExpand* edge_expand_;
  ::physical::GetV* get_v_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PathExpand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.PathExpand) */ {
 public:
  PathExpand();
  virtual ~PathExpand();

  PathExpand(const PathExpand& from);

  inline PathExpand& operator=(const PathExpand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PathExpand(PathExpand&& from) noexcept
    : PathExpand() {
    *this = ::std::move(from);
  }

  inline PathExpand& operator=(PathExpand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PathExpand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PathExpand* internal_default_instance() {
    return reinterpret_cast<const PathExpand*>(
               &_PathExpand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(PathExpand* other);
  friend void swap(PathExpand& a, PathExpand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PathExpand* New() const final {
    return CreateMaybeMessage<PathExpand>(NULL);
  }

  PathExpand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PathExpand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PathExpand& from);
  void MergeFrom(const PathExpand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathExpand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PathExpand_ExpandBase ExpandBase;

  typedef PathExpand_PathOpt PathOpt;
  static const PathOpt ARBITRARY =
    PathExpand_PathOpt_ARBITRARY;
  static const PathOpt SIMPLE =
    PathExpand_PathOpt_SIMPLE;
  static inline bool PathOpt_IsValid(int value) {
    return PathExpand_PathOpt_IsValid(value);
  }
  static const PathOpt PathOpt_MIN =
    PathExpand_PathOpt_PathOpt_MIN;
  static const PathOpt PathOpt_MAX =
    PathExpand_PathOpt_PathOpt_MAX;
  static const int PathOpt_ARRAYSIZE =
    PathExpand_PathOpt_PathOpt_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PathOpt_descriptor() {
    return PathExpand_PathOpt_descriptor();
  }
  static inline const ::std::string& PathOpt_Name(PathOpt value) {
    return PathExpand_PathOpt_Name(value);
  }
  static inline bool PathOpt_Parse(const ::std::string& name,
      PathOpt* value) {
    return PathExpand_PathOpt_Parse(name, value);
  }

  typedef PathExpand_ResultOpt ResultOpt;
  static const ResultOpt END_V =
    PathExpand_ResultOpt_END_V;
  static const ResultOpt ALL_V =
    PathExpand_ResultOpt_ALL_V;
  static const ResultOpt ALL_V_E =
    PathExpand_ResultOpt_ALL_V_E;
  static inline bool ResultOpt_IsValid(int value) {
    return PathExpand_ResultOpt_IsValid(value);
  }
  static const ResultOpt ResultOpt_MIN =
    PathExpand_ResultOpt_ResultOpt_MIN;
  static const ResultOpt ResultOpt_MAX =
    PathExpand_ResultOpt_ResultOpt_MAX;
  static const int ResultOpt_ARRAYSIZE =
    PathExpand_ResultOpt_ResultOpt_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResultOpt_descriptor() {
    return PathExpand_ResultOpt_descriptor();
  }
  static inline const ::std::string& ResultOpt_Name(ResultOpt value) {
    return PathExpand_ResultOpt_Name(value);
  }
  static inline bool ResultOpt_Parse(const ::std::string& name,
      ResultOpt* value) {
    return PathExpand_ResultOpt_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .physical.PathExpand.ExpandBase base = 1;
  bool has_base() const;
  void clear_base();
  static const int kBaseFieldNumber = 1;
  private:
  const ::physical::PathExpand_ExpandBase& _internal_base() const;
  public:
  const ::physical::PathExpand_ExpandBase& base() const;
  ::physical::PathExpand_ExpandBase* release_base();
  ::physical::PathExpand_ExpandBase* mutable_base();
  void set_allocated_base(::physical::PathExpand_ExpandBase* base);

  // .google.protobuf.Int32Value start_tag = 2;
  bool has_start_tag() const;
  void clear_start_tag();
  static const int kStartTagFieldNumber = 2;
  private:
  const ::google::protobuf::Int32Value& _internal_start_tag() const;
  public:
  const ::google::protobuf::Int32Value& start_tag() const;
  ::google::protobuf::Int32Value* release_start_tag();
  ::google::protobuf::Int32Value* mutable_start_tag();
  void set_allocated_start_tag(::google::protobuf::Int32Value* start_tag);

  // .google.protobuf.Int32Value alias = 3;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 3;
  private:
  const ::google::protobuf::Int32Value& _internal_alias() const;
  public:
  const ::google::protobuf::Int32Value& alias() const;
  ::google::protobuf::Int32Value* release_alias();
  ::google::protobuf::Int32Value* mutable_alias();
  void set_allocated_alias(::google::protobuf::Int32Value* alias);

  // .algebra.Range hop_range = 4;
  bool has_hop_range() const;
  void clear_hop_range();
  static const int kHopRangeFieldNumber = 4;
  private:
  const ::algebra::Range& _internal_hop_range() const;
  public:
  const ::algebra::Range& hop_range() const;
  ::algebra::Range* release_hop_range();
  ::algebra::Range* mutable_hop_range();
  void set_allocated_hop_range(::algebra::Range* hop_range);

  // .common.Expression condition = 7;
  bool has_condition() const;
  void clear_condition();
  static const int kConditionFieldNumber = 7;
  private:
  const ::common::Expression& _internal_condition() const;
  public:
  const ::common::Expression& condition() const;
  ::common::Expression* release_condition();
  ::common::Expression* mutable_condition();
  void set_allocated_condition(::common::Expression* condition);

  // .physical.PathExpand.PathOpt path_opt = 5;
  void clear_path_opt();
  static const int kPathOptFieldNumber = 5;
  ::physical::PathExpand_PathOpt path_opt() const;
  void set_path_opt(::physical::PathExpand_PathOpt value);

  // .physical.PathExpand.ResultOpt result_opt = 6;
  void clear_result_opt();
  static const int kResultOptFieldNumber = 6;
  ::physical::PathExpand_ResultOpt result_opt() const;
  void set_result_opt(::physical::PathExpand_ResultOpt value);

  // @@protoc_insertion_point(class_scope:physical.PathExpand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::physical::PathExpand_ExpandBase* base_;
  ::google::protobuf::Int32Value* start_tag_;
  ::google::protobuf::Int32Value* alias_;
  ::algebra::Range* hop_range_;
  ::common::Expression* condition_;
  int path_opt_;
  int result_opt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sink_OptTag : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.Sink.OptTag) */ {
 public:
  Sink_OptTag();
  virtual ~Sink_OptTag();

  Sink_OptTag(const Sink_OptTag& from);

  inline Sink_OptTag& operator=(const Sink_OptTag& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sink_OptTag(Sink_OptTag&& from) noexcept
    : Sink_OptTag() {
    *this = ::std::move(from);
  }

  inline Sink_OptTag& operator=(Sink_OptTag&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sink_OptTag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sink_OptTag* internal_default_instance() {
    return reinterpret_cast<const Sink_OptTag*>(
               &_Sink_OptTag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(Sink_OptTag* other);
  friend void swap(Sink_OptTag& a, Sink_OptTag& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sink_OptTag* New() const final {
    return CreateMaybeMessage<Sink_OptTag>(NULL);
  }

  Sink_OptTag* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Sink_OptTag>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Sink_OptTag& from);
  void MergeFrom(const Sink_OptTag& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sink_OptTag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Int32Value tag = 1;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  private:
  const ::google::protobuf::Int32Value& _internal_tag() const;
  public:
  const ::google::protobuf::Int32Value& tag() const;
  ::google::protobuf::Int32Value* release_tag();
  ::google::protobuf::Int32Value* mutable_tag();
  void set_allocated_tag(::google::protobuf::Int32Value* tag);

  // @@protoc_insertion_point(class_scope:physical.Sink.OptTag)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Int32Value* tag_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sink : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.Sink) */ {
 public:
  Sink();
  virtual ~Sink();

  Sink(const Sink& from);

  inline Sink& operator=(const Sink& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sink(Sink&& from) noexcept
    : Sink() {
    *this = ::std::move(from);
  }

  inline Sink& operator=(Sink&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sink& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sink* internal_default_instance() {
    return reinterpret_cast<const Sink*>(
               &_Sink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(Sink* other);
  friend void swap(Sink& a, Sink& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sink* New() const final {
    return CreateMaybeMessage<Sink>(NULL);
  }

  Sink* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Sink>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Sink& from);
  void MergeFrom(const Sink& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sink* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Sink_OptTag OptTag;

  // accessors -------------------------------------------------------

  // repeated .physical.Sink.OptTag tags = 1;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 1;
  ::physical::Sink_OptTag* mutable_tags(int index);
  ::google::protobuf::RepeatedPtrField< ::physical::Sink_OptTag >*
      mutable_tags();
  const ::physical::Sink_OptTag& tags(int index) const;
  ::physical::Sink_OptTag* add_tags();
  const ::google::protobuf::RepeatedPtrField< ::physical::Sink_OptTag >&
      tags() const;

  // .algebra.Sink.SinkTarget sink_target = 2;
  bool has_sink_target() const;
  void clear_sink_target();
  static const int kSinkTargetFieldNumber = 2;
  private:
  const ::algebra::Sink_SinkTarget& _internal_sink_target() const;
  public:
  const ::algebra::Sink_SinkTarget& sink_target() const;
  ::algebra::Sink_SinkTarget* release_sink_target();
  ::algebra::Sink_SinkTarget* mutable_sink_target();
  void set_allocated_sink_target(::algebra::Sink_SinkTarget* sink_target);

  // @@protoc_insertion_point(class_scope:physical.Sink)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::physical::Sink_OptTag > tags_;
  ::algebra::Sink_SinkTarget* sink_target_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Repartition_Shuffle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.Repartition.Shuffle) */ {
 public:
  Repartition_Shuffle();
  virtual ~Repartition_Shuffle();

  Repartition_Shuffle(const Repartition_Shuffle& from);

  inline Repartition_Shuffle& operator=(const Repartition_Shuffle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Repartition_Shuffle(Repartition_Shuffle&& from) noexcept
    : Repartition_Shuffle() {
    *this = ::std::move(from);
  }

  inline Repartition_Shuffle& operator=(Repartition_Shuffle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Repartition_Shuffle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Repartition_Shuffle* internal_default_instance() {
    return reinterpret_cast<const Repartition_Shuffle*>(
               &_Repartition_Shuffle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(Repartition_Shuffle* other);
  friend void swap(Repartition_Shuffle& a, Repartition_Shuffle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Repartition_Shuffle* New() const final {
    return CreateMaybeMessage<Repartition_Shuffle>(NULL);
  }

  Repartition_Shuffle* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Repartition_Shuffle>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Repartition_Shuffle& from);
  void MergeFrom(const Repartition_Shuffle& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Repartition_Shuffle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Int32Value shuffle_key = 1;
  bool has_shuffle_key() const;
  void clear_shuffle_key();
  static const int kShuffleKeyFieldNumber = 1;
  private:
  const ::google::protobuf::Int32Value& _internal_shuffle_key() const;
  public:
  const ::google::protobuf::Int32Value& shuffle_key() const;
  ::google::protobuf::Int32Value* release_shuffle_key();
  ::google::protobuf::Int32Value* mutable_shuffle_key();
  void set_allocated_shuffle_key(::google::protobuf::Int32Value* shuffle_key);

  // @@protoc_insertion_point(class_scope:physical.Repartition.Shuffle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Int32Value* shuffle_key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Repartition_Broadcast : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.Repartition.Broadcast) */ {
 public:
  Repartition_Broadcast();
  virtual ~Repartition_Broadcast();

  Repartition_Broadcast(const Repartition_Broadcast& from);

  inline Repartition_Broadcast& operator=(const Repartition_Broadcast& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Repartition_Broadcast(Repartition_Broadcast&& from) noexcept
    : Repartition_Broadcast() {
    *this = ::std::move(from);
  }

  inline Repartition_Broadcast& operator=(Repartition_Broadcast&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Repartition_Broadcast& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Repartition_Broadcast* internal_default_instance() {
    return reinterpret_cast<const Repartition_Broadcast*>(
               &_Repartition_Broadcast_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(Repartition_Broadcast* other);
  friend void swap(Repartition_Broadcast& a, Repartition_Broadcast& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Repartition_Broadcast* New() const final {
    return CreateMaybeMessage<Repartition_Broadcast>(NULL);
  }

  Repartition_Broadcast* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Repartition_Broadcast>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Repartition_Broadcast& from);
  void MergeFrom(const Repartition_Broadcast& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Repartition_Broadcast* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:physical.Repartition.Broadcast)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Repartition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.Repartition) */ {
 public:
  Repartition();
  virtual ~Repartition();

  Repartition(const Repartition& from);

  inline Repartition& operator=(const Repartition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Repartition(Repartition&& from) noexcept
    : Repartition() {
    *this = ::std::move(from);
  }

  inline Repartition& operator=(Repartition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Repartition& default_instance();

  enum StrategyCase {
    kToAnother = 1,
    kToOthers = 2,
    STRATEGY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Repartition* internal_default_instance() {
    return reinterpret_cast<const Repartition*>(
               &_Repartition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(Repartition* other);
  friend void swap(Repartition& a, Repartition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Repartition* New() const final {
    return CreateMaybeMessage<Repartition>(NULL);
  }

  Repartition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Repartition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Repartition& from);
  void MergeFrom(const Repartition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Repartition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Repartition_Shuffle Shuffle;
  typedef Repartition_Broadcast Broadcast;

  // accessors -------------------------------------------------------

  // .physical.Repartition.Shuffle to_another = 1;
  bool has_to_another() const;
  void clear_to_another();
  static const int kToAnotherFieldNumber = 1;
  private:
  const ::physical::Repartition_Shuffle& _internal_to_another() const;
  public:
  const ::physical::Repartition_Shuffle& to_another() const;
  ::physical::Repartition_Shuffle* release_to_another();
  ::physical::Repartition_Shuffle* mutable_to_another();
  void set_allocated_to_another(::physical::Repartition_Shuffle* to_another);

  // .physical.Repartition.Broadcast to_others = 2;
  bool has_to_others() const;
  void clear_to_others();
  static const int kToOthersFieldNumber = 2;
  private:
  const ::physical::Repartition_Broadcast& _internal_to_others() const;
  public:
  const ::physical::Repartition_Broadcast& to_others() const;
  ::physical::Repartition_Broadcast* release_to_others();
  ::physical::Repartition_Broadcast* mutable_to_others();
  void set_allocated_to_others(::physical::Repartition_Broadcast* to_others);

  void clear_Strategy();
  StrategyCase Strategy_case() const;
  // @@protoc_insertion_point(class_scope:physical.Repartition)
 private:
  void set_has_to_another();
  void set_has_to_others();

  inline bool has_Strategy() const;
  inline void clear_has_Strategy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union StrategyUnion {
    StrategyUnion() {}
    ::physical::Repartition_Shuffle* to_another_;
    ::physical::Repartition_Broadcast* to_others_;
  } Strategy_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Root : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.Root) */ {
 public:
  Root();
  virtual ~Root();

  Root(const Root& from);

  inline Root& operator=(const Root& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Root(Root&& from) noexcept
    : Root() {
    *this = ::std::move(from);
  }

  inline Root& operator=(Root&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Root& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Root* internal_default_instance() {
    return reinterpret_cast<const Root*>(
               &_Root_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(Root* other);
  friend void swap(Root& a, Root& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Root* New() const final {
    return CreateMaybeMessage<Root>(NULL);
  }

  Root* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Root>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Root& from);
  void MergeFrom(const Root& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Root* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:physical.Root)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PhysicalOpr_Operator : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.PhysicalOpr.Operator) */ {
 public:
  PhysicalOpr_Operator();
  virtual ~PhysicalOpr_Operator();

  PhysicalOpr_Operator(const PhysicalOpr_Operator& from);

  inline PhysicalOpr_Operator& operator=(const PhysicalOpr_Operator& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PhysicalOpr_Operator(PhysicalOpr_Operator&& from) noexcept
    : PhysicalOpr_Operator() {
    *this = ::std::move(from);
  }

  inline PhysicalOpr_Operator& operator=(PhysicalOpr_Operator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PhysicalOpr_Operator& default_instance();

  enum OpKindCase {
    kProject = 1,
    kSelect = 2,
    kGroupBy = 3,
    kOrderBy = 4,
    kDedup = 5,
    kUnfold = 6,
    kLimit = 7,
    kScan = 8,
    kSink = 9,
    kApply = 10,
    kJoin = 11,
    kUnion = 12,
    kIntersect = 13,
    kRepartition = 14,
    kRoot = 16,
    kSample = 17,
    kVertex = 30,
    kEdge = 31,
    kPath = 32,
    OP_KIND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PhysicalOpr_Operator* internal_default_instance() {
    return reinterpret_cast<const PhysicalOpr_Operator*>(
               &_PhysicalOpr_Operator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(PhysicalOpr_Operator* other);
  friend void swap(PhysicalOpr_Operator& a, PhysicalOpr_Operator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PhysicalOpr_Operator* New() const final {
    return CreateMaybeMessage<PhysicalOpr_Operator>(NULL);
  }

  PhysicalOpr_Operator* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PhysicalOpr_Operator>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PhysicalOpr_Operator& from);
  void MergeFrom(const PhysicalOpr_Operator& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhysicalOpr_Operator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .physical.Project project = 1;
  bool has_project() const;
  void clear_project();
  static const int kProjectFieldNumber = 1;
  private:
  const ::physical::Project& _internal_project() const;
  public:
  const ::physical::Project& project() const;
  ::physical::Project* release_project();
  ::physical::Project* mutable_project();
  void set_allocated_project(::physical::Project* project);

  // .algebra.Select select = 2;
  bool has_select() const;
  void clear_select();
  static const int kSelectFieldNumber = 2;
  private:
  const ::algebra::Select& _internal_select() const;
  public:
  const ::algebra::Select& select() const;
  ::algebra::Select* release_select();
  ::algebra::Select* mutable_select();
  void set_allocated_select(::algebra::Select* select);

  // .physical.GroupBy group_by = 3;
  bool has_group_by() const;
  void clear_group_by();
  static const int kGroupByFieldNumber = 3;
  private:
  const ::physical::GroupBy& _internal_group_by() const;
  public:
  const ::physical::GroupBy& group_by() const;
  ::physical::GroupBy* release_group_by();
  ::physical::GroupBy* mutable_group_by();
  void set_allocated_group_by(::physical::GroupBy* group_by);

  // .algebra.OrderBy order_by = 4;
  bool has_order_by() const;
  void clear_order_by();
  static const int kOrderByFieldNumber = 4;
  private:
  const ::algebra::OrderBy& _internal_order_by() const;
  public:
  const ::algebra::OrderBy& order_by() const;
  ::algebra::OrderBy* release_order_by();
  ::algebra::OrderBy* mutable_order_by();
  void set_allocated_order_by(::algebra::OrderBy* order_by);

  // .algebra.Dedup dedup = 5;
  bool has_dedup() const;
  void clear_dedup();
  static const int kDedupFieldNumber = 5;
  private:
  const ::algebra::Dedup& _internal_dedup() const;
  public:
  const ::algebra::Dedup& dedup() const;
  ::algebra::Dedup* release_dedup();
  ::algebra::Dedup* mutable_dedup();
  void set_allocated_dedup(::algebra::Dedup* dedup);

  // .physical.Unfold unfold = 6;
  bool has_unfold() const;
  void clear_unfold();
  static const int kUnfoldFieldNumber = 6;
  private:
  const ::physical::Unfold& _internal_unfold() const;
  public:
  const ::physical::Unfold& unfold() const;
  ::physical::Unfold* release_unfold();
  ::physical::Unfold* mutable_unfold();
  void set_allocated_unfold(::physical::Unfold* unfold);

  // .algebra.Limit limit = 7;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 7;
  private:
  const ::algebra::Limit& _internal_limit() const;
  public:
  const ::algebra::Limit& limit() const;
  ::algebra::Limit* release_limit();
  ::algebra::Limit* mutable_limit();
  void set_allocated_limit(::algebra::Limit* limit);

  // .physical.Scan scan = 8;
  bool has_scan() const;
  void clear_scan();
  static const int kScanFieldNumber = 8;
  private:
  const ::physical::Scan& _internal_scan() const;
  public:
  const ::physical::Scan& scan() const;
  ::physical::Scan* release_scan();
  ::physical::Scan* mutable_scan();
  void set_allocated_scan(::physical::Scan* scan);

  // .physical.Sink sink = 9;
  bool has_sink() const;
  void clear_sink();
  static const int kSinkFieldNumber = 9;
  private:
  const ::physical::Sink& _internal_sink() const;
  public:
  const ::physical::Sink& sink() const;
  ::physical::Sink* release_sink();
  ::physical::Sink* mutable_sink();
  void set_allocated_sink(::physical::Sink* sink);

  // .physical.Apply apply = 10;
  bool has_apply() const;
  void clear_apply();
  static const int kApplyFieldNumber = 10;
  private:
  const ::physical::Apply& _internal_apply() const;
  public:
  const ::physical::Apply& apply() const;
  ::physical::Apply* release_apply();
  ::physical::Apply* mutable_apply();
  void set_allocated_apply(::physical::Apply* apply);

  // .physical.Join join = 11;
  bool has_join() const;
  void clear_join();
  static const int kJoinFieldNumber = 11;
  private:
  const ::physical::Join& _internal_join() const;
  public:
  const ::physical::Join& join() const;
  ::physical::Join* release_join();
  ::physical::Join* mutable_join();
  void set_allocated_join(::physical::Join* join);

  // .physical.Union union = 12;
  bool has_union_() const;
  void clear_union_();
  static const int kUnionFieldNumber = 12;
  private:
  const ::physical::Union& _internal_union_() const;
  public:
  const ::physical::Union& union_() const;
  ::physical::Union* release_union_();
  ::physical::Union* mutable_union_();
  void set_allocated_union_(::physical::Union* union_);

  // .physical.Intersect intersect = 13;
  bool has_intersect() const;
  void clear_intersect();
  static const int kIntersectFieldNumber = 13;
  private:
  const ::physical::Intersect& _internal_intersect() const;
  public:
  const ::physical::Intersect& intersect() const;
  ::physical::Intersect* release_intersect();
  ::physical::Intersect* mutable_intersect();
  void set_allocated_intersect(::physical::Intersect* intersect);

  // .physical.Repartition repartition = 14;
  bool has_repartition() const;
  void clear_repartition();
  static const int kRepartitionFieldNumber = 14;
  private:
  const ::physical::Repartition& _internal_repartition() const;
  public:
  const ::physical::Repartition& repartition() const;
  ::physical::Repartition* release_repartition();
  ::physical::Repartition* mutable_repartition();
  void set_allocated_repartition(::physical::Repartition* repartition);

  // .physical.Root root = 16;
  bool has_root() const;
  void clear_root();
  static const int kRootFieldNumber = 16;
  private:
  const ::physical::Root& _internal_root() const;
  public:
  const ::physical::Root& root() const;
  ::physical::Root* release_root();
  ::physical::Root* mutable_root();
  void set_allocated_root(::physical::Root* root);

  // .algebra.Sample sample = 17;
  bool has_sample() const;
  void clear_sample();
  static const int kSampleFieldNumber = 17;
  private:
  const ::algebra::Sample& _internal_sample() const;
  public:
  const ::algebra::Sample& sample() const;
  ::algebra::Sample* release_sample();
  ::algebra::Sample* mutable_sample();
  void set_allocated_sample(::algebra::Sample* sample);

  // .physical.GetV vertex = 30;
  bool has_vertex() const;
  void clear_vertex();
  static const int kVertexFieldNumber = 30;
  private:
  const ::physical::GetV& _internal_vertex() const;
  public:
  const ::physical::GetV& vertex() const;
  ::physical::GetV* release_vertex();
  ::physical::GetV* mutable_vertex();
  void set_allocated_vertex(::physical::GetV* vertex);

  // .physical.EdgeExpand edge = 31;
  bool has_edge() const;
  void clear_edge();
  static const int kEdgeFieldNumber = 31;
  private:
  const ::physical::EdgeExpand& _internal_edge() const;
  public:
  const ::physical::EdgeExpand& edge() const;
  ::physical::EdgeExpand* release_edge();
  ::physical::EdgeExpand* mutable_edge();
  void set_allocated_edge(::physical::EdgeExpand* edge);

  // .physical.PathExpand path = 32;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 32;
  private:
  const ::physical::PathExpand& _internal_path() const;
  public:
  const ::physical::PathExpand& path() const;
  ::physical::PathExpand* release_path();
  ::physical::PathExpand* mutable_path();
  void set_allocated_path(::physical::PathExpand* path);

  void clear_op_kind();
  OpKindCase op_kind_case() const;
  // @@protoc_insertion_point(class_scope:physical.PhysicalOpr.Operator)
 private:
  void set_has_project();
  void set_has_select();
  void set_has_group_by();
  void set_has_order_by();
  void set_has_dedup();
  void set_has_unfold();
  void set_has_limit();
  void set_has_scan();
  void set_has_sink();
  void set_has_apply();
  void set_has_join();
  void set_has_union_();
  void set_has_intersect();
  void set_has_repartition();
  void set_has_root();
  void set_has_sample();
  void set_has_vertex();
  void set_has_edge();
  void set_has_path();

  inline bool has_op_kind() const;
  inline void clear_has_op_kind();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union OpKindUnion {
    OpKindUnion() {}
    ::physical::Project* project_;
    ::algebra::Select* select_;
    ::physical::GroupBy* group_by_;
    ::algebra::OrderBy* order_by_;
    ::algebra::Dedup* dedup_;
    ::physical::Unfold* unfold_;
    ::algebra::Limit* limit_;
    ::physical::Scan* scan_;
    ::physical::Sink* sink_;
    ::physical::Apply* apply_;
    ::physical::Join* join_;
    ::physical::Union* union__;
    ::physical::Intersect* intersect_;
    ::physical::Repartition* repartition_;
    ::physical::Root* root_;
    ::algebra::Sample* sample_;
    ::physical::GetV* vertex_;
    ::physical::EdgeExpand* edge_;
    ::physical::PathExpand* path_;
  } op_kind_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PhysicalOpr_MetaData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.PhysicalOpr.MetaData) */ {
 public:
  PhysicalOpr_MetaData();
  virtual ~PhysicalOpr_MetaData();

  PhysicalOpr_MetaData(const PhysicalOpr_MetaData& from);

  inline PhysicalOpr_MetaData& operator=(const PhysicalOpr_MetaData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PhysicalOpr_MetaData(PhysicalOpr_MetaData&& from) noexcept
    : PhysicalOpr_MetaData() {
    *this = ::std::move(from);
  }

  inline PhysicalOpr_MetaData& operator=(PhysicalOpr_MetaData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PhysicalOpr_MetaData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PhysicalOpr_MetaData* internal_default_instance() {
    return reinterpret_cast<const PhysicalOpr_MetaData*>(
               &_PhysicalOpr_MetaData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(PhysicalOpr_MetaData* other);
  friend void swap(PhysicalOpr_MetaData& a, PhysicalOpr_MetaData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PhysicalOpr_MetaData* New() const final {
    return CreateMaybeMessage<PhysicalOpr_MetaData>(NULL);
  }

  PhysicalOpr_MetaData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PhysicalOpr_MetaData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PhysicalOpr_MetaData& from);
  void MergeFrom(const PhysicalOpr_MetaData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhysicalOpr_MetaData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.IrDataType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  private:
  const ::common::IrDataType& _internal_type() const;
  public:
  const ::common::IrDataType& type() const;
  ::common::IrDataType* release_type();
  ::common::IrDataType* mutable_type();
  void set_allocated_type(::common::IrDataType* type);

  // int32 alias = 2;
  void clear_alias();
  static const int kAliasFieldNumber = 2;
  ::google::protobuf::int32 alias() const;
  void set_alias(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:physical.PhysicalOpr.MetaData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::IrDataType* type_;
  ::google::protobuf::int32 alias_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PhysicalOpr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.PhysicalOpr) */ {
 public:
  PhysicalOpr();
  virtual ~PhysicalOpr();

  PhysicalOpr(const PhysicalOpr& from);

  inline PhysicalOpr& operator=(const PhysicalOpr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PhysicalOpr(PhysicalOpr&& from) noexcept
    : PhysicalOpr() {
    *this = ::std::move(from);
  }

  inline PhysicalOpr& operator=(PhysicalOpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PhysicalOpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PhysicalOpr* internal_default_instance() {
    return reinterpret_cast<const PhysicalOpr*>(
               &_PhysicalOpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(PhysicalOpr* other);
  friend void swap(PhysicalOpr& a, PhysicalOpr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PhysicalOpr* New() const final {
    return CreateMaybeMessage<PhysicalOpr>(NULL);
  }

  PhysicalOpr* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PhysicalOpr>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PhysicalOpr& from);
  void MergeFrom(const PhysicalOpr& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhysicalOpr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PhysicalOpr_Operator Operator;
  typedef PhysicalOpr_MetaData MetaData;

  // accessors -------------------------------------------------------

  // repeated .physical.PhysicalOpr.MetaData meta_data = 2;
  int meta_data_size() const;
  void clear_meta_data();
  static const int kMetaDataFieldNumber = 2;
  ::physical::PhysicalOpr_MetaData* mutable_meta_data(int index);
  ::google::protobuf::RepeatedPtrField< ::physical::PhysicalOpr_MetaData >*
      mutable_meta_data();
  const ::physical::PhysicalOpr_MetaData& meta_data(int index) const;
  ::physical::PhysicalOpr_MetaData* add_meta_data();
  const ::google::protobuf::RepeatedPtrField< ::physical::PhysicalOpr_MetaData >&
      meta_data() const;

  // .physical.PhysicalOpr.Operator opr = 1;
  bool has_opr() const;
  void clear_opr();
  static const int kOprFieldNumber = 1;
  private:
  const ::physical::PhysicalOpr_Operator& _internal_opr() const;
  public:
  const ::physical::PhysicalOpr_Operator& opr() const;
  ::physical::PhysicalOpr_Operator* release_opr();
  ::physical::PhysicalOpr_Operator* mutable_opr();
  void set_allocated_opr(::physical::PhysicalOpr_Operator* opr);

  // @@protoc_insertion_point(class_scope:physical.PhysicalOpr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::physical::PhysicalOpr_MetaData > meta_data_;
  ::physical::PhysicalOpr_Operator* opr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PhysicalPlan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:physical.PhysicalPlan) */ {
 public:
  PhysicalPlan();
  virtual ~PhysicalPlan();

  PhysicalPlan(const PhysicalPlan& from);

  inline PhysicalPlan& operator=(const PhysicalPlan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PhysicalPlan(PhysicalPlan&& from) noexcept
    : PhysicalPlan() {
    *this = ::std::move(from);
  }

  inline PhysicalPlan& operator=(PhysicalPlan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PhysicalPlan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PhysicalPlan* internal_default_instance() {
    return reinterpret_cast<const PhysicalPlan*>(
               &_PhysicalPlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(PhysicalPlan* other);
  friend void swap(PhysicalPlan& a, PhysicalPlan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PhysicalPlan* New() const final {
    return CreateMaybeMessage<PhysicalPlan>(NULL);
  }

  PhysicalPlan* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PhysicalPlan>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PhysicalPlan& from);
  void MergeFrom(const PhysicalPlan& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhysicalPlan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .physical.PhysicalOpr plan = 1;
  int plan_size() const;
  void clear_plan();
  static const int kPlanFieldNumber = 1;
  ::physical::PhysicalOpr* mutable_plan(int index);
  ::google::protobuf::RepeatedPtrField< ::physical::PhysicalOpr >*
      mutable_plan();
  const ::physical::PhysicalOpr& plan(int index) const;
  ::physical::PhysicalOpr* add_plan();
  const ::google::protobuf::RepeatedPtrField< ::physical::PhysicalOpr >&
      plan() const;

  // @@protoc_insertion_point(class_scope:physical.PhysicalPlan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::physical::PhysicalOpr > plan_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_physical_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Project_ExprAlias

// .common.Expression expr = 1;
inline bool Project_ExprAlias::has_expr() const {
  return this != internal_default_instance() && expr_ != NULL;
}
inline const ::common::Expression& Project_ExprAlias::_internal_expr() const {
  return *expr_;
}
inline const ::common::Expression& Project_ExprAlias::expr() const {
  const ::common::Expression* p = expr_;
  // @@protoc_insertion_point(field_get:physical.Project.ExprAlias.expr)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Expression*>(
      &::common::_Expression_default_instance_);
}
inline ::common::Expression* Project_ExprAlias::release_expr() {
  // @@protoc_insertion_point(field_release:physical.Project.ExprAlias.expr)
  
  ::common::Expression* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline ::common::Expression* Project_ExprAlias::mutable_expr() {
  
  if (expr_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Expression>(GetArenaNoVirtual());
    expr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.Project.ExprAlias.expr)
  return expr_;
}
inline void Project_ExprAlias::set_allocated_expr(::common::Expression* expr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(expr_);
  }
  if (expr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      expr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, expr, submessage_arena);
    }
    
  } else {
    
  }
  expr_ = expr;
  // @@protoc_insertion_point(field_set_allocated:physical.Project.ExprAlias.expr)
}

// .google.protobuf.Int32Value alias = 2;
inline bool Project_ExprAlias::has_alias() const {
  return this != internal_default_instance() && alias_ != NULL;
}
inline const ::google::protobuf::Int32Value& Project_ExprAlias::_internal_alias() const {
  return *alias_;
}
inline const ::google::protobuf::Int32Value& Project_ExprAlias::alias() const {
  const ::google::protobuf::Int32Value* p = alias_;
  // @@protoc_insertion_point(field_get:physical.Project.ExprAlias.alias)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* Project_ExprAlias::release_alias() {
  // @@protoc_insertion_point(field_release:physical.Project.ExprAlias.alias)
  
  ::google::protobuf::Int32Value* temp = alias_;
  alias_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* Project_ExprAlias::mutable_alias() {
  
  if (alias_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    alias_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.Project.ExprAlias.alias)
  return alias_;
}
inline void Project_ExprAlias::set_allocated_alias(::google::protobuf::Int32Value* alias) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(alias_);
  }
  if (alias) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(alias)->GetArena();
    if (message_arena != submessage_arena) {
      alias = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, alias, submessage_arena);
    }
    
  } else {
    
  }
  alias_ = alias;
  // @@protoc_insertion_point(field_set_allocated:physical.Project.ExprAlias.alias)
}

// -------------------------------------------------------------------

// Project

// repeated .physical.Project.ExprAlias mappings = 1;
inline int Project::mappings_size() const {
  return mappings_.size();
}
inline void Project::clear_mappings() {
  mappings_.Clear();
}
inline ::physical::Project_ExprAlias* Project::mutable_mappings(int index) {
  // @@protoc_insertion_point(field_mutable:physical.Project.mappings)
  return mappings_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::physical::Project_ExprAlias >*
Project::mutable_mappings() {
  // @@protoc_insertion_point(field_mutable_list:physical.Project.mappings)
  return &mappings_;
}
inline const ::physical::Project_ExprAlias& Project::mappings(int index) const {
  // @@protoc_insertion_point(field_get:physical.Project.mappings)
  return mappings_.Get(index);
}
inline ::physical::Project_ExprAlias* Project::add_mappings() {
  // @@protoc_insertion_point(field_add:physical.Project.mappings)
  return mappings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::physical::Project_ExprAlias >&
Project::mappings() const {
  // @@protoc_insertion_point(field_list:physical.Project.mappings)
  return mappings_;
}

// bool is_append = 2;
inline void Project::clear_is_append() {
  is_append_ = false;
}
inline bool Project::is_append() const {
  // @@protoc_insertion_point(field_get:physical.Project.is_append)
  return is_append_;
}
inline void Project::set_is_append(bool value) {
  
  is_append_ = value;
  // @@protoc_insertion_point(field_set:physical.Project.is_append)
}

// -------------------------------------------------------------------

// GroupBy_AggFunc

// repeated .common.Variable vars = 1;
inline int GroupBy_AggFunc::vars_size() const {
  return vars_.size();
}
inline ::common::Variable* GroupBy_AggFunc::mutable_vars(int index) {
  // @@protoc_insertion_point(field_mutable:physical.GroupBy.AggFunc.vars)
  return vars_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::common::Variable >*
GroupBy_AggFunc::mutable_vars() {
  // @@protoc_insertion_point(field_mutable_list:physical.GroupBy.AggFunc.vars)
  return &vars_;
}
inline const ::common::Variable& GroupBy_AggFunc::vars(int index) const {
  // @@protoc_insertion_point(field_get:physical.GroupBy.AggFunc.vars)
  return vars_.Get(index);
}
inline ::common::Variable* GroupBy_AggFunc::add_vars() {
  // @@protoc_insertion_point(field_add:physical.GroupBy.AggFunc.vars)
  return vars_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::Variable >&
GroupBy_AggFunc::vars() const {
  // @@protoc_insertion_point(field_list:physical.GroupBy.AggFunc.vars)
  return vars_;
}

// .physical.GroupBy.AggFunc.Aggregate aggregate = 2;
inline void GroupBy_AggFunc::clear_aggregate() {
  aggregate_ = 0;
}
inline ::physical::GroupBy_AggFunc_Aggregate GroupBy_AggFunc::aggregate() const {
  // @@protoc_insertion_point(field_get:physical.GroupBy.AggFunc.aggregate)
  return static_cast< ::physical::GroupBy_AggFunc_Aggregate >(aggregate_);
}
inline void GroupBy_AggFunc::set_aggregate(::physical::GroupBy_AggFunc_Aggregate value) {
  
  aggregate_ = value;
  // @@protoc_insertion_point(field_set:physical.GroupBy.AggFunc.aggregate)
}

// .google.protobuf.Int32Value alias = 3;
inline bool GroupBy_AggFunc::has_alias() const {
  return this != internal_default_instance() && alias_ != NULL;
}
inline const ::google::protobuf::Int32Value& GroupBy_AggFunc::_internal_alias() const {
  return *alias_;
}
inline const ::google::protobuf::Int32Value& GroupBy_AggFunc::alias() const {
  const ::google::protobuf::Int32Value* p = alias_;
  // @@protoc_insertion_point(field_get:physical.GroupBy.AggFunc.alias)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* GroupBy_AggFunc::release_alias() {
  // @@protoc_insertion_point(field_release:physical.GroupBy.AggFunc.alias)
  
  ::google::protobuf::Int32Value* temp = alias_;
  alias_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* GroupBy_AggFunc::mutable_alias() {
  
  if (alias_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    alias_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.GroupBy.AggFunc.alias)
  return alias_;
}
inline void GroupBy_AggFunc::set_allocated_alias(::google::protobuf::Int32Value* alias) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(alias_);
  }
  if (alias) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(alias)->GetArena();
    if (message_arena != submessage_arena) {
      alias = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, alias, submessage_arena);
    }
    
  } else {
    
  }
  alias_ = alias;
  // @@protoc_insertion_point(field_set_allocated:physical.GroupBy.AggFunc.alias)
}

// -------------------------------------------------------------------

// GroupBy_KeyAlias

// .common.Variable key = 1;
inline bool GroupBy_KeyAlias::has_key() const {
  return this != internal_default_instance() && key_ != NULL;
}
inline const ::common::Variable& GroupBy_KeyAlias::_internal_key() const {
  return *key_;
}
inline const ::common::Variable& GroupBy_KeyAlias::key() const {
  const ::common::Variable* p = key_;
  // @@protoc_insertion_point(field_get:physical.GroupBy.KeyAlias.key)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Variable*>(
      &::common::_Variable_default_instance_);
}
inline ::common::Variable* GroupBy_KeyAlias::release_key() {
  // @@protoc_insertion_point(field_release:physical.GroupBy.KeyAlias.key)
  
  ::common::Variable* temp = key_;
  key_ = NULL;
  return temp;
}
inline ::common::Variable* GroupBy_KeyAlias::mutable_key() {
  
  if (key_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Variable>(GetArenaNoVirtual());
    key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.GroupBy.KeyAlias.key)
  return key_;
}
inline void GroupBy_KeyAlias::set_allocated_key(::common::Variable* key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(key_);
  }
  if (key) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:physical.GroupBy.KeyAlias.key)
}

// .google.protobuf.Int32Value alias = 2;
inline bool GroupBy_KeyAlias::has_alias() const {
  return this != internal_default_instance() && alias_ != NULL;
}
inline const ::google::protobuf::Int32Value& GroupBy_KeyAlias::_internal_alias() const {
  return *alias_;
}
inline const ::google::protobuf::Int32Value& GroupBy_KeyAlias::alias() const {
  const ::google::protobuf::Int32Value* p = alias_;
  // @@protoc_insertion_point(field_get:physical.GroupBy.KeyAlias.alias)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* GroupBy_KeyAlias::release_alias() {
  // @@protoc_insertion_point(field_release:physical.GroupBy.KeyAlias.alias)
  
  ::google::protobuf::Int32Value* temp = alias_;
  alias_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* GroupBy_KeyAlias::mutable_alias() {
  
  if (alias_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    alias_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.GroupBy.KeyAlias.alias)
  return alias_;
}
inline void GroupBy_KeyAlias::set_allocated_alias(::google::protobuf::Int32Value* alias) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(alias_);
  }
  if (alias) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(alias)->GetArena();
    if (message_arena != submessage_arena) {
      alias = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, alias, submessage_arena);
    }
    
  } else {
    
  }
  alias_ = alias;
  // @@protoc_insertion_point(field_set_allocated:physical.GroupBy.KeyAlias.alias)
}

// -------------------------------------------------------------------

// GroupBy

// repeated .physical.GroupBy.KeyAlias mappings = 1;
inline int GroupBy::mappings_size() const {
  return mappings_.size();
}
inline void GroupBy::clear_mappings() {
  mappings_.Clear();
}
inline ::physical::GroupBy_KeyAlias* GroupBy::mutable_mappings(int index) {
  // @@protoc_insertion_point(field_mutable:physical.GroupBy.mappings)
  return mappings_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::physical::GroupBy_KeyAlias >*
GroupBy::mutable_mappings() {
  // @@protoc_insertion_point(field_mutable_list:physical.GroupBy.mappings)
  return &mappings_;
}
inline const ::physical::GroupBy_KeyAlias& GroupBy::mappings(int index) const {
  // @@protoc_insertion_point(field_get:physical.GroupBy.mappings)
  return mappings_.Get(index);
}
inline ::physical::GroupBy_KeyAlias* GroupBy::add_mappings() {
  // @@protoc_insertion_point(field_add:physical.GroupBy.mappings)
  return mappings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::physical::GroupBy_KeyAlias >&
GroupBy::mappings() const {
  // @@protoc_insertion_point(field_list:physical.GroupBy.mappings)
  return mappings_;
}

// repeated .physical.GroupBy.AggFunc functions = 2;
inline int GroupBy::functions_size() const {
  return functions_.size();
}
inline void GroupBy::clear_functions() {
  functions_.Clear();
}
inline ::physical::GroupBy_AggFunc* GroupBy::mutable_functions(int index) {
  // @@protoc_insertion_point(field_mutable:physical.GroupBy.functions)
  return functions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::physical::GroupBy_AggFunc >*
GroupBy::mutable_functions() {
  // @@protoc_insertion_point(field_mutable_list:physical.GroupBy.functions)
  return &functions_;
}
inline const ::physical::GroupBy_AggFunc& GroupBy::functions(int index) const {
  // @@protoc_insertion_point(field_get:physical.GroupBy.functions)
  return functions_.Get(index);
}
inline ::physical::GroupBy_AggFunc* GroupBy::add_functions() {
  // @@protoc_insertion_point(field_add:physical.GroupBy.functions)
  return functions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::physical::GroupBy_AggFunc >&
GroupBy::functions() const {
  // @@protoc_insertion_point(field_list:physical.GroupBy.functions)
  return functions_;
}

// -------------------------------------------------------------------

// Unfold

// .google.protobuf.Int32Value tag = 1;
inline bool Unfold::has_tag() const {
  return this != internal_default_instance() && tag_ != NULL;
}
inline const ::google::protobuf::Int32Value& Unfold::_internal_tag() const {
  return *tag_;
}
inline const ::google::protobuf::Int32Value& Unfold::tag() const {
  const ::google::protobuf::Int32Value* p = tag_;
  // @@protoc_insertion_point(field_get:physical.Unfold.tag)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* Unfold::release_tag() {
  // @@protoc_insertion_point(field_release:physical.Unfold.tag)
  
  ::google::protobuf::Int32Value* temp = tag_;
  tag_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* Unfold::mutable_tag() {
  
  if (tag_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    tag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.Unfold.tag)
  return tag_;
}
inline void Unfold::set_allocated_tag(::google::protobuf::Int32Value* tag) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tag_);
  }
  if (tag) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(tag)->GetArena();
    if (message_arena != submessage_arena) {
      tag = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tag, submessage_arena);
    }
    
  } else {
    
  }
  tag_ = tag;
  // @@protoc_insertion_point(field_set_allocated:physical.Unfold.tag)
}

// .google.protobuf.Int32Value alias = 2;
inline bool Unfold::has_alias() const {
  return this != internal_default_instance() && alias_ != NULL;
}
inline const ::google::protobuf::Int32Value& Unfold::_internal_alias() const {
  return *alias_;
}
inline const ::google::protobuf::Int32Value& Unfold::alias() const {
  const ::google::protobuf::Int32Value* p = alias_;
  // @@protoc_insertion_point(field_get:physical.Unfold.alias)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* Unfold::release_alias() {
  // @@protoc_insertion_point(field_release:physical.Unfold.alias)
  
  ::google::protobuf::Int32Value* temp = alias_;
  alias_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* Unfold::mutable_alias() {
  
  if (alias_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    alias_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.Unfold.alias)
  return alias_;
}
inline void Unfold::set_allocated_alias(::google::protobuf::Int32Value* alias) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(alias_);
  }
  if (alias) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(alias)->GetArena();
    if (message_arena != submessage_arena) {
      alias = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, alias, submessage_arena);
    }
    
  } else {
    
  }
  alias_ = alias;
  // @@protoc_insertion_point(field_set_allocated:physical.Unfold.alias)
}

// -------------------------------------------------------------------

// Union

// repeated .physical.PhysicalPlan sub_plans = 1;
inline int Union::sub_plans_size() const {
  return sub_plans_.size();
}
inline void Union::clear_sub_plans() {
  sub_plans_.Clear();
}
inline ::physical::PhysicalPlan* Union::mutable_sub_plans(int index) {
  // @@protoc_insertion_point(field_mutable:physical.Union.sub_plans)
  return sub_plans_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::physical::PhysicalPlan >*
Union::mutable_sub_plans() {
  // @@protoc_insertion_point(field_mutable_list:physical.Union.sub_plans)
  return &sub_plans_;
}
inline const ::physical::PhysicalPlan& Union::sub_plans(int index) const {
  // @@protoc_insertion_point(field_get:physical.Union.sub_plans)
  return sub_plans_.Get(index);
}
inline ::physical::PhysicalPlan* Union::add_sub_plans() {
  // @@protoc_insertion_point(field_add:physical.Union.sub_plans)
  return sub_plans_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::physical::PhysicalPlan >&
Union::sub_plans() const {
  // @@protoc_insertion_point(field_list:physical.Union.sub_plans)
  return sub_plans_;
}

// -------------------------------------------------------------------

// Intersect

// repeated .physical.PhysicalPlan sub_plans = 1;
inline int Intersect::sub_plans_size() const {
  return sub_plans_.size();
}
inline void Intersect::clear_sub_plans() {
  sub_plans_.Clear();
}
inline ::physical::PhysicalPlan* Intersect::mutable_sub_plans(int index) {
  // @@protoc_insertion_point(field_mutable:physical.Intersect.sub_plans)
  return sub_plans_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::physical::PhysicalPlan >*
Intersect::mutable_sub_plans() {
  // @@protoc_insertion_point(field_mutable_list:physical.Intersect.sub_plans)
  return &sub_plans_;
}
inline const ::physical::PhysicalPlan& Intersect::sub_plans(int index) const {
  // @@protoc_insertion_point(field_get:physical.Intersect.sub_plans)
  return sub_plans_.Get(index);
}
inline ::physical::PhysicalPlan* Intersect::add_sub_plans() {
  // @@protoc_insertion_point(field_add:physical.Intersect.sub_plans)
  return sub_plans_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::physical::PhysicalPlan >&
Intersect::sub_plans() const {
  // @@protoc_insertion_point(field_list:physical.Intersect.sub_plans)
  return sub_plans_;
}

// int32 key = 2;
inline void Intersect::clear_key() {
  key_ = 0;
}
inline ::google::protobuf::int32 Intersect::key() const {
  // @@protoc_insertion_point(field_get:physical.Intersect.key)
  return key_;
}
inline void Intersect::set_key(::google::protobuf::int32 value) {
  
  key_ = value;
  // @@protoc_insertion_point(field_set:physical.Intersect.key)
}

// -------------------------------------------------------------------

// Join

// repeated .common.Variable left_keys = 1;
inline int Join::left_keys_size() const {
  return left_keys_.size();
}
inline ::common::Variable* Join::mutable_left_keys(int index) {
  // @@protoc_insertion_point(field_mutable:physical.Join.left_keys)
  return left_keys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::common::Variable >*
Join::mutable_left_keys() {
  // @@protoc_insertion_point(field_mutable_list:physical.Join.left_keys)
  return &left_keys_;
}
inline const ::common::Variable& Join::left_keys(int index) const {
  // @@protoc_insertion_point(field_get:physical.Join.left_keys)
  return left_keys_.Get(index);
}
inline ::common::Variable* Join::add_left_keys() {
  // @@protoc_insertion_point(field_add:physical.Join.left_keys)
  return left_keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::Variable >&
Join::left_keys() const {
  // @@protoc_insertion_point(field_list:physical.Join.left_keys)
  return left_keys_;
}

// repeated .common.Variable right_keys = 2;
inline int Join::right_keys_size() const {
  return right_keys_.size();
}
inline ::common::Variable* Join::mutable_right_keys(int index) {
  // @@protoc_insertion_point(field_mutable:physical.Join.right_keys)
  return right_keys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::common::Variable >*
Join::mutable_right_keys() {
  // @@protoc_insertion_point(field_mutable_list:physical.Join.right_keys)
  return &right_keys_;
}
inline const ::common::Variable& Join::right_keys(int index) const {
  // @@protoc_insertion_point(field_get:physical.Join.right_keys)
  return right_keys_.Get(index);
}
inline ::common::Variable* Join::add_right_keys() {
  // @@protoc_insertion_point(field_add:physical.Join.right_keys)
  return right_keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::Variable >&
Join::right_keys() const {
  // @@protoc_insertion_point(field_list:physical.Join.right_keys)
  return right_keys_;
}

// .physical.Join.JoinKind join_kind = 3;
inline void Join::clear_join_kind() {
  join_kind_ = 0;
}
inline ::physical::Join_JoinKind Join::join_kind() const {
  // @@protoc_insertion_point(field_get:physical.Join.join_kind)
  return static_cast< ::physical::Join_JoinKind >(join_kind_);
}
inline void Join::set_join_kind(::physical::Join_JoinKind value) {
  
  join_kind_ = value;
  // @@protoc_insertion_point(field_set:physical.Join.join_kind)
}

// .physical.PhysicalPlan left_plan = 4;
inline bool Join::has_left_plan() const {
  return this != internal_default_instance() && left_plan_ != NULL;
}
inline void Join::clear_left_plan() {
  if (GetArenaNoVirtual() == NULL && left_plan_ != NULL) {
    delete left_plan_;
  }
  left_plan_ = NULL;
}
inline const ::physical::PhysicalPlan& Join::_internal_left_plan() const {
  return *left_plan_;
}
inline const ::physical::PhysicalPlan& Join::left_plan() const {
  const ::physical::PhysicalPlan* p = left_plan_;
  // @@protoc_insertion_point(field_get:physical.Join.left_plan)
  return p != NULL ? *p : *reinterpret_cast<const ::physical::PhysicalPlan*>(
      &::physical::_PhysicalPlan_default_instance_);
}
inline ::physical::PhysicalPlan* Join::release_left_plan() {
  // @@protoc_insertion_point(field_release:physical.Join.left_plan)
  
  ::physical::PhysicalPlan* temp = left_plan_;
  left_plan_ = NULL;
  return temp;
}
inline ::physical::PhysicalPlan* Join::mutable_left_plan() {
  
  if (left_plan_ == NULL) {
    auto* p = CreateMaybeMessage<::physical::PhysicalPlan>(GetArenaNoVirtual());
    left_plan_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.Join.left_plan)
  return left_plan_;
}
inline void Join::set_allocated_left_plan(::physical::PhysicalPlan* left_plan) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete left_plan_;
  }
  if (left_plan) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      left_plan = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, left_plan, submessage_arena);
    }
    
  } else {
    
  }
  left_plan_ = left_plan;
  // @@protoc_insertion_point(field_set_allocated:physical.Join.left_plan)
}

// .physical.PhysicalPlan right_plan = 5;
inline bool Join::has_right_plan() const {
  return this != internal_default_instance() && right_plan_ != NULL;
}
inline void Join::clear_right_plan() {
  if (GetArenaNoVirtual() == NULL && right_plan_ != NULL) {
    delete right_plan_;
  }
  right_plan_ = NULL;
}
inline const ::physical::PhysicalPlan& Join::_internal_right_plan() const {
  return *right_plan_;
}
inline const ::physical::PhysicalPlan& Join::right_plan() const {
  const ::physical::PhysicalPlan* p = right_plan_;
  // @@protoc_insertion_point(field_get:physical.Join.right_plan)
  return p != NULL ? *p : *reinterpret_cast<const ::physical::PhysicalPlan*>(
      &::physical::_PhysicalPlan_default_instance_);
}
inline ::physical::PhysicalPlan* Join::release_right_plan() {
  // @@protoc_insertion_point(field_release:physical.Join.right_plan)
  
  ::physical::PhysicalPlan* temp = right_plan_;
  right_plan_ = NULL;
  return temp;
}
inline ::physical::PhysicalPlan* Join::mutable_right_plan() {
  
  if (right_plan_ == NULL) {
    auto* p = CreateMaybeMessage<::physical::PhysicalPlan>(GetArenaNoVirtual());
    right_plan_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.Join.right_plan)
  return right_plan_;
}
inline void Join::set_allocated_right_plan(::physical::PhysicalPlan* right_plan) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete right_plan_;
  }
  if (right_plan) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      right_plan = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, right_plan, submessage_arena);
    }
    
  } else {
    
  }
  right_plan_ = right_plan;
  // @@protoc_insertion_point(field_set_allocated:physical.Join.right_plan)
}

// -------------------------------------------------------------------

// Apply

// .physical.Join.JoinKind join_kind = 1;
inline void Apply::clear_join_kind() {
  join_kind_ = 0;
}
inline ::physical::Join_JoinKind Apply::join_kind() const {
  // @@protoc_insertion_point(field_get:physical.Apply.join_kind)
  return static_cast< ::physical::Join_JoinKind >(join_kind_);
}
inline void Apply::set_join_kind(::physical::Join_JoinKind value) {
  
  join_kind_ = value;
  // @@protoc_insertion_point(field_set:physical.Apply.join_kind)
}

// repeated .common.Variable keys = 2;
inline int Apply::keys_size() const {
  return keys_.size();
}
inline ::common::Variable* Apply::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:physical.Apply.keys)
  return keys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::common::Variable >*
Apply::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:physical.Apply.keys)
  return &keys_;
}
inline const ::common::Variable& Apply::keys(int index) const {
  // @@protoc_insertion_point(field_get:physical.Apply.keys)
  return keys_.Get(index);
}
inline ::common::Variable* Apply::add_keys() {
  // @@protoc_insertion_point(field_add:physical.Apply.keys)
  return keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::Variable >&
Apply::keys() const {
  // @@protoc_insertion_point(field_list:physical.Apply.keys)
  return keys_;
}

// .physical.PhysicalPlan sub_plan = 3;
inline bool Apply::has_sub_plan() const {
  return this != internal_default_instance() && sub_plan_ != NULL;
}
inline void Apply::clear_sub_plan() {
  if (GetArenaNoVirtual() == NULL && sub_plan_ != NULL) {
    delete sub_plan_;
  }
  sub_plan_ = NULL;
}
inline const ::physical::PhysicalPlan& Apply::_internal_sub_plan() const {
  return *sub_plan_;
}
inline const ::physical::PhysicalPlan& Apply::sub_plan() const {
  const ::physical::PhysicalPlan* p = sub_plan_;
  // @@protoc_insertion_point(field_get:physical.Apply.sub_plan)
  return p != NULL ? *p : *reinterpret_cast<const ::physical::PhysicalPlan*>(
      &::physical::_PhysicalPlan_default_instance_);
}
inline ::physical::PhysicalPlan* Apply::release_sub_plan() {
  // @@protoc_insertion_point(field_release:physical.Apply.sub_plan)
  
  ::physical::PhysicalPlan* temp = sub_plan_;
  sub_plan_ = NULL;
  return temp;
}
inline ::physical::PhysicalPlan* Apply::mutable_sub_plan() {
  
  if (sub_plan_ == NULL) {
    auto* p = CreateMaybeMessage<::physical::PhysicalPlan>(GetArenaNoVirtual());
    sub_plan_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.Apply.sub_plan)
  return sub_plan_;
}
inline void Apply::set_allocated_sub_plan(::physical::PhysicalPlan* sub_plan) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sub_plan_;
  }
  if (sub_plan) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sub_plan = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sub_plan, submessage_arena);
    }
    
  } else {
    
  }
  sub_plan_ = sub_plan;
  // @@protoc_insertion_point(field_set_allocated:physical.Apply.sub_plan)
}

// .google.protobuf.Int32Value alias = 4;
inline bool Apply::has_alias() const {
  return this != internal_default_instance() && alias_ != NULL;
}
inline const ::google::protobuf::Int32Value& Apply::_internal_alias() const {
  return *alias_;
}
inline const ::google::protobuf::Int32Value& Apply::alias() const {
  const ::google::protobuf::Int32Value* p = alias_;
  // @@protoc_insertion_point(field_get:physical.Apply.alias)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* Apply::release_alias() {
  // @@protoc_insertion_point(field_release:physical.Apply.alias)
  
  ::google::protobuf::Int32Value* temp = alias_;
  alias_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* Apply::mutable_alias() {
  
  if (alias_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    alias_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.Apply.alias)
  return alias_;
}
inline void Apply::set_allocated_alias(::google::protobuf::Int32Value* alias) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(alias_);
  }
  if (alias) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(alias)->GetArena();
    if (message_arena != submessage_arena) {
      alias = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, alias, submessage_arena);
    }
    
  } else {
    
  }
  alias_ = alias;
  // @@protoc_insertion_point(field_set_allocated:physical.Apply.alias)
}

// -------------------------------------------------------------------

// Scan

// .physical.Scan.ScanOpt scan_opt = 1;
inline void Scan::clear_scan_opt() {
  scan_opt_ = 0;
}
inline ::physical::Scan_ScanOpt Scan::scan_opt() const {
  // @@protoc_insertion_point(field_get:physical.Scan.scan_opt)
  return static_cast< ::physical::Scan_ScanOpt >(scan_opt_);
}
inline void Scan::set_scan_opt(::physical::Scan_ScanOpt value) {
  
  scan_opt_ = value;
  // @@protoc_insertion_point(field_set:physical.Scan.scan_opt)
}

// .google.protobuf.Int32Value alias = 2;
inline bool Scan::has_alias() const {
  return this != internal_default_instance() && alias_ != NULL;
}
inline const ::google::protobuf::Int32Value& Scan::_internal_alias() const {
  return *alias_;
}
inline const ::google::protobuf::Int32Value& Scan::alias() const {
  const ::google::protobuf::Int32Value* p = alias_;
  // @@protoc_insertion_point(field_get:physical.Scan.alias)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* Scan::release_alias() {
  // @@protoc_insertion_point(field_release:physical.Scan.alias)
  
  ::google::protobuf::Int32Value* temp = alias_;
  alias_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* Scan::mutable_alias() {
  
  if (alias_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    alias_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.Scan.alias)
  return alias_;
}
inline void Scan::set_allocated_alias(::google::protobuf::Int32Value* alias) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(alias_);
  }
  if (alias) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(alias)->GetArena();
    if (message_arena != submessage_arena) {
      alias = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, alias, submessage_arena);
    }
    
  } else {
    
  }
  alias_ = alias;
  // @@protoc_insertion_point(field_set_allocated:physical.Scan.alias)
}

// .algebra.QueryParams params = 3;
inline bool Scan::has_params() const {
  return this != internal_default_instance() && params_ != NULL;
}
inline const ::algebra::QueryParams& Scan::_internal_params() const {
  return *params_;
}
inline const ::algebra::QueryParams& Scan::params() const {
  const ::algebra::QueryParams* p = params_;
  // @@protoc_insertion_point(field_get:physical.Scan.params)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::QueryParams*>(
      &::algebra::_QueryParams_default_instance_);
}
inline ::algebra::QueryParams* Scan::release_params() {
  // @@protoc_insertion_point(field_release:physical.Scan.params)
  
  ::algebra::QueryParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline ::algebra::QueryParams* Scan::mutable_params() {
  
  if (params_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::QueryParams>(GetArenaNoVirtual());
    params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.Scan.params)
  return params_;
}
inline void Scan::set_allocated_params(::algebra::QueryParams* params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(params_);
  }
  if (params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:physical.Scan.params)
}

// .algebra.IndexPredicate idx_predicate = 4;
inline bool Scan::has_idx_predicate() const {
  return this != internal_default_instance() && idx_predicate_ != NULL;
}
inline const ::algebra::IndexPredicate& Scan::_internal_idx_predicate() const {
  return *idx_predicate_;
}
inline const ::algebra::IndexPredicate& Scan::idx_predicate() const {
  const ::algebra::IndexPredicate* p = idx_predicate_;
  // @@protoc_insertion_point(field_get:physical.Scan.idx_predicate)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::IndexPredicate*>(
      &::algebra::_IndexPredicate_default_instance_);
}
inline ::algebra::IndexPredicate* Scan::release_idx_predicate() {
  // @@protoc_insertion_point(field_release:physical.Scan.idx_predicate)
  
  ::algebra::IndexPredicate* temp = idx_predicate_;
  idx_predicate_ = NULL;
  return temp;
}
inline ::algebra::IndexPredicate* Scan::mutable_idx_predicate() {
  
  if (idx_predicate_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::IndexPredicate>(GetArenaNoVirtual());
    idx_predicate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.Scan.idx_predicate)
  return idx_predicate_;
}
inline void Scan::set_allocated_idx_predicate(::algebra::IndexPredicate* idx_predicate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(idx_predicate_);
  }
  if (idx_predicate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      idx_predicate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, idx_predicate, submessage_arena);
    }
    
  } else {
    
  }
  idx_predicate_ = idx_predicate;
  // @@protoc_insertion_point(field_set_allocated:physical.Scan.idx_predicate)
}

// -------------------------------------------------------------------

// GetV

// .google.protobuf.Int32Value tag = 1;
inline bool GetV::has_tag() const {
  return this != internal_default_instance() && tag_ != NULL;
}
inline const ::google::protobuf::Int32Value& GetV::_internal_tag() const {
  return *tag_;
}
inline const ::google::protobuf::Int32Value& GetV::tag() const {
  const ::google::protobuf::Int32Value* p = tag_;
  // @@protoc_insertion_point(field_get:physical.GetV.tag)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* GetV::release_tag() {
  // @@protoc_insertion_point(field_release:physical.GetV.tag)
  
  ::google::protobuf::Int32Value* temp = tag_;
  tag_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* GetV::mutable_tag() {
  
  if (tag_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    tag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.GetV.tag)
  return tag_;
}
inline void GetV::set_allocated_tag(::google::protobuf::Int32Value* tag) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tag_);
  }
  if (tag) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(tag)->GetArena();
    if (message_arena != submessage_arena) {
      tag = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tag, submessage_arena);
    }
    
  } else {
    
  }
  tag_ = tag;
  // @@protoc_insertion_point(field_set_allocated:physical.GetV.tag)
}

// .physical.GetV.VOpt opt = 2;
inline void GetV::clear_opt() {
  opt_ = 0;
}
inline ::physical::GetV_VOpt GetV::opt() const {
  // @@protoc_insertion_point(field_get:physical.GetV.opt)
  return static_cast< ::physical::GetV_VOpt >(opt_);
}
inline void GetV::set_opt(::physical::GetV_VOpt value) {
  
  opt_ = value;
  // @@protoc_insertion_point(field_set:physical.GetV.opt)
}

// .algebra.QueryParams params = 3;
inline bool GetV::has_params() const {
  return this != internal_default_instance() && params_ != NULL;
}
inline const ::algebra::QueryParams& GetV::_internal_params() const {
  return *params_;
}
inline const ::algebra::QueryParams& GetV::params() const {
  const ::algebra::QueryParams* p = params_;
  // @@protoc_insertion_point(field_get:physical.GetV.params)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::QueryParams*>(
      &::algebra::_QueryParams_default_instance_);
}
inline ::algebra::QueryParams* GetV::release_params() {
  // @@protoc_insertion_point(field_release:physical.GetV.params)
  
  ::algebra::QueryParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline ::algebra::QueryParams* GetV::mutable_params() {
  
  if (params_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::QueryParams>(GetArenaNoVirtual());
    params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.GetV.params)
  return params_;
}
inline void GetV::set_allocated_params(::algebra::QueryParams* params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(params_);
  }
  if (params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:physical.GetV.params)
}

// .google.protobuf.Int32Value alias = 4;
inline bool GetV::has_alias() const {
  return this != internal_default_instance() && alias_ != NULL;
}
inline const ::google::protobuf::Int32Value& GetV::_internal_alias() const {
  return *alias_;
}
inline const ::google::protobuf::Int32Value& GetV::alias() const {
  const ::google::protobuf::Int32Value* p = alias_;
  // @@protoc_insertion_point(field_get:physical.GetV.alias)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* GetV::release_alias() {
  // @@protoc_insertion_point(field_release:physical.GetV.alias)
  
  ::google::protobuf::Int32Value* temp = alias_;
  alias_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* GetV::mutable_alias() {
  
  if (alias_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    alias_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.GetV.alias)
  return alias_;
}
inline void GetV::set_allocated_alias(::google::protobuf::Int32Value* alias) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(alias_);
  }
  if (alias) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(alias)->GetArena();
    if (message_arena != submessage_arena) {
      alias = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, alias, submessage_arena);
    }
    
  } else {
    
  }
  alias_ = alias;
  // @@protoc_insertion_point(field_set_allocated:physical.GetV.alias)
}

// -------------------------------------------------------------------

// EdgeExpand

// .google.protobuf.Int32Value v_tag = 1;
inline bool EdgeExpand::has_v_tag() const {
  return this != internal_default_instance() && v_tag_ != NULL;
}
inline const ::google::protobuf::Int32Value& EdgeExpand::_internal_v_tag() const {
  return *v_tag_;
}
inline const ::google::protobuf::Int32Value& EdgeExpand::v_tag() const {
  const ::google::protobuf::Int32Value* p = v_tag_;
  // @@protoc_insertion_point(field_get:physical.EdgeExpand.v_tag)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* EdgeExpand::release_v_tag() {
  // @@protoc_insertion_point(field_release:physical.EdgeExpand.v_tag)
  
  ::google::protobuf::Int32Value* temp = v_tag_;
  v_tag_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* EdgeExpand::mutable_v_tag() {
  
  if (v_tag_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    v_tag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.EdgeExpand.v_tag)
  return v_tag_;
}
inline void EdgeExpand::set_allocated_v_tag(::google::protobuf::Int32Value* v_tag) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(v_tag_);
  }
  if (v_tag) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(v_tag)->GetArena();
    if (message_arena != submessage_arena) {
      v_tag = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, v_tag, submessage_arena);
    }
    
  } else {
    
  }
  v_tag_ = v_tag;
  // @@protoc_insertion_point(field_set_allocated:physical.EdgeExpand.v_tag)
}

// .physical.EdgeExpand.Direction direction = 2;
inline void EdgeExpand::clear_direction() {
  direction_ = 0;
}
inline ::physical::EdgeExpand_Direction EdgeExpand::direction() const {
  // @@protoc_insertion_point(field_get:physical.EdgeExpand.direction)
  return static_cast< ::physical::EdgeExpand_Direction >(direction_);
}
inline void EdgeExpand::set_direction(::physical::EdgeExpand_Direction value) {
  
  direction_ = value;
  // @@protoc_insertion_point(field_set:physical.EdgeExpand.direction)
}

// .algebra.QueryParams params = 3;
inline bool EdgeExpand::has_params() const {
  return this != internal_default_instance() && params_ != NULL;
}
inline const ::algebra::QueryParams& EdgeExpand::_internal_params() const {
  return *params_;
}
inline const ::algebra::QueryParams& EdgeExpand::params() const {
  const ::algebra::QueryParams* p = params_;
  // @@protoc_insertion_point(field_get:physical.EdgeExpand.params)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::QueryParams*>(
      &::algebra::_QueryParams_default_instance_);
}
inline ::algebra::QueryParams* EdgeExpand::release_params() {
  // @@protoc_insertion_point(field_release:physical.EdgeExpand.params)
  
  ::algebra::QueryParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline ::algebra::QueryParams* EdgeExpand::mutable_params() {
  
  if (params_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::QueryParams>(GetArenaNoVirtual());
    params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.EdgeExpand.params)
  return params_;
}
inline void EdgeExpand::set_allocated_params(::algebra::QueryParams* params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(params_);
  }
  if (params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:physical.EdgeExpand.params)
}

// .google.protobuf.Int32Value alias = 4;
inline bool EdgeExpand::has_alias() const {
  return this != internal_default_instance() && alias_ != NULL;
}
inline const ::google::protobuf::Int32Value& EdgeExpand::_internal_alias() const {
  return *alias_;
}
inline const ::google::protobuf::Int32Value& EdgeExpand::alias() const {
  const ::google::protobuf::Int32Value* p = alias_;
  // @@protoc_insertion_point(field_get:physical.EdgeExpand.alias)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* EdgeExpand::release_alias() {
  // @@protoc_insertion_point(field_release:physical.EdgeExpand.alias)
  
  ::google::protobuf::Int32Value* temp = alias_;
  alias_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* EdgeExpand::mutable_alias() {
  
  if (alias_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    alias_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.EdgeExpand.alias)
  return alias_;
}
inline void EdgeExpand::set_allocated_alias(::google::protobuf::Int32Value* alias) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(alias_);
  }
  if (alias) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(alias)->GetArena();
    if (message_arena != submessage_arena) {
      alias = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, alias, submessage_arena);
    }
    
  } else {
    
  }
  alias_ = alias;
  // @@protoc_insertion_point(field_set_allocated:physical.EdgeExpand.alias)
}

// .physical.EdgeExpand.ExpandOpt expand_opt = 5;
inline void EdgeExpand::clear_expand_opt() {
  expand_opt_ = 0;
}
inline ::physical::EdgeExpand_ExpandOpt EdgeExpand::expand_opt() const {
  // @@protoc_insertion_point(field_get:physical.EdgeExpand.expand_opt)
  return static_cast< ::physical::EdgeExpand_ExpandOpt >(expand_opt_);
}
inline void EdgeExpand::set_expand_opt(::physical::EdgeExpand_ExpandOpt value) {
  
  expand_opt_ = value;
  // @@protoc_insertion_point(field_set:physical.EdgeExpand.expand_opt)
}

// -------------------------------------------------------------------

// PathExpand_ExpandBase

// .physical.EdgeExpand edge_expand = 1;
inline bool PathExpand_ExpandBase::has_edge_expand() const {
  return this != internal_default_instance() && edge_expand_ != NULL;
}
inline void PathExpand_ExpandBase::clear_edge_expand() {
  if (GetArenaNoVirtual() == NULL && edge_expand_ != NULL) {
    delete edge_expand_;
  }
  edge_expand_ = NULL;
}
inline const ::physical::EdgeExpand& PathExpand_ExpandBase::_internal_edge_expand() const {
  return *edge_expand_;
}
inline const ::physical::EdgeExpand& PathExpand_ExpandBase::edge_expand() const {
  const ::physical::EdgeExpand* p = edge_expand_;
  // @@protoc_insertion_point(field_get:physical.PathExpand.ExpandBase.edge_expand)
  return p != NULL ? *p : *reinterpret_cast<const ::physical::EdgeExpand*>(
      &::physical::_EdgeExpand_default_instance_);
}
inline ::physical::EdgeExpand* PathExpand_ExpandBase::release_edge_expand() {
  // @@protoc_insertion_point(field_release:physical.PathExpand.ExpandBase.edge_expand)
  
  ::physical::EdgeExpand* temp = edge_expand_;
  edge_expand_ = NULL;
  return temp;
}
inline ::physical::EdgeExpand* PathExpand_ExpandBase::mutable_edge_expand() {
  
  if (edge_expand_ == NULL) {
    auto* p = CreateMaybeMessage<::physical::EdgeExpand>(GetArenaNoVirtual());
    edge_expand_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.PathExpand.ExpandBase.edge_expand)
  return edge_expand_;
}
inline void PathExpand_ExpandBase::set_allocated_edge_expand(::physical::EdgeExpand* edge_expand) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete edge_expand_;
  }
  if (edge_expand) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      edge_expand = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, edge_expand, submessage_arena);
    }
    
  } else {
    
  }
  edge_expand_ = edge_expand;
  // @@protoc_insertion_point(field_set_allocated:physical.PathExpand.ExpandBase.edge_expand)
}

// .physical.GetV get_V = 2;
inline bool PathExpand_ExpandBase::has_get_v() const {
  return this != internal_default_instance() && get_v_ != NULL;
}
inline void PathExpand_ExpandBase::clear_get_v() {
  if (GetArenaNoVirtual() == NULL && get_v_ != NULL) {
    delete get_v_;
  }
  get_v_ = NULL;
}
inline const ::physical::GetV& PathExpand_ExpandBase::_internal_get_v() const {
  return *get_v_;
}
inline const ::physical::GetV& PathExpand_ExpandBase::get_v() const {
  const ::physical::GetV* p = get_v_;
  // @@protoc_insertion_point(field_get:physical.PathExpand.ExpandBase.get_V)
  return p != NULL ? *p : *reinterpret_cast<const ::physical::GetV*>(
      &::physical::_GetV_default_instance_);
}
inline ::physical::GetV* PathExpand_ExpandBase::release_get_v() {
  // @@protoc_insertion_point(field_release:physical.PathExpand.ExpandBase.get_V)
  
  ::physical::GetV* temp = get_v_;
  get_v_ = NULL;
  return temp;
}
inline ::physical::GetV* PathExpand_ExpandBase::mutable_get_v() {
  
  if (get_v_ == NULL) {
    auto* p = CreateMaybeMessage<::physical::GetV>(GetArenaNoVirtual());
    get_v_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.PathExpand.ExpandBase.get_V)
  return get_v_;
}
inline void PathExpand_ExpandBase::set_allocated_get_v(::physical::GetV* get_v) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_v_;
  }
  if (get_v) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      get_v = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_v, submessage_arena);
    }
    
  } else {
    
  }
  get_v_ = get_v;
  // @@protoc_insertion_point(field_set_allocated:physical.PathExpand.ExpandBase.get_V)
}

// -------------------------------------------------------------------

// PathExpand

// .physical.PathExpand.ExpandBase base = 1;
inline bool PathExpand::has_base() const {
  return this != internal_default_instance() && base_ != NULL;
}
inline void PathExpand::clear_base() {
  if (GetArenaNoVirtual() == NULL && base_ != NULL) {
    delete base_;
  }
  base_ = NULL;
}
inline const ::physical::PathExpand_ExpandBase& PathExpand::_internal_base() const {
  return *base_;
}
inline const ::physical::PathExpand_ExpandBase& PathExpand::base() const {
  const ::physical::PathExpand_ExpandBase* p = base_;
  // @@protoc_insertion_point(field_get:physical.PathExpand.base)
  return p != NULL ? *p : *reinterpret_cast<const ::physical::PathExpand_ExpandBase*>(
      &::physical::_PathExpand_ExpandBase_default_instance_);
}
inline ::physical::PathExpand_ExpandBase* PathExpand::release_base() {
  // @@protoc_insertion_point(field_release:physical.PathExpand.base)
  
  ::physical::PathExpand_ExpandBase* temp = base_;
  base_ = NULL;
  return temp;
}
inline ::physical::PathExpand_ExpandBase* PathExpand::mutable_base() {
  
  if (base_ == NULL) {
    auto* p = CreateMaybeMessage<::physical::PathExpand_ExpandBase>(GetArenaNoVirtual());
    base_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.PathExpand.base)
  return base_;
}
inline void PathExpand::set_allocated_base(::physical::PathExpand_ExpandBase* base) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete base_;
  }
  if (base) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      base = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  base_ = base;
  // @@protoc_insertion_point(field_set_allocated:physical.PathExpand.base)
}

// .google.protobuf.Int32Value start_tag = 2;
inline bool PathExpand::has_start_tag() const {
  return this != internal_default_instance() && start_tag_ != NULL;
}
inline const ::google::protobuf::Int32Value& PathExpand::_internal_start_tag() const {
  return *start_tag_;
}
inline const ::google::protobuf::Int32Value& PathExpand::start_tag() const {
  const ::google::protobuf::Int32Value* p = start_tag_;
  // @@protoc_insertion_point(field_get:physical.PathExpand.start_tag)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* PathExpand::release_start_tag() {
  // @@protoc_insertion_point(field_release:physical.PathExpand.start_tag)
  
  ::google::protobuf::Int32Value* temp = start_tag_;
  start_tag_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* PathExpand::mutable_start_tag() {
  
  if (start_tag_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    start_tag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.PathExpand.start_tag)
  return start_tag_;
}
inline void PathExpand::set_allocated_start_tag(::google::protobuf::Int32Value* start_tag) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_tag_);
  }
  if (start_tag) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(start_tag)->GetArena();
    if (message_arena != submessage_arena) {
      start_tag = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_tag, submessage_arena);
    }
    
  } else {
    
  }
  start_tag_ = start_tag;
  // @@protoc_insertion_point(field_set_allocated:physical.PathExpand.start_tag)
}

// .google.protobuf.Int32Value alias = 3;
inline bool PathExpand::has_alias() const {
  return this != internal_default_instance() && alias_ != NULL;
}
inline const ::google::protobuf::Int32Value& PathExpand::_internal_alias() const {
  return *alias_;
}
inline const ::google::protobuf::Int32Value& PathExpand::alias() const {
  const ::google::protobuf::Int32Value* p = alias_;
  // @@protoc_insertion_point(field_get:physical.PathExpand.alias)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* PathExpand::release_alias() {
  // @@protoc_insertion_point(field_release:physical.PathExpand.alias)
  
  ::google::protobuf::Int32Value* temp = alias_;
  alias_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* PathExpand::mutable_alias() {
  
  if (alias_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    alias_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.PathExpand.alias)
  return alias_;
}
inline void PathExpand::set_allocated_alias(::google::protobuf::Int32Value* alias) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(alias_);
  }
  if (alias) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(alias)->GetArena();
    if (message_arena != submessage_arena) {
      alias = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, alias, submessage_arena);
    }
    
  } else {
    
  }
  alias_ = alias;
  // @@protoc_insertion_point(field_set_allocated:physical.PathExpand.alias)
}

// .algebra.Range hop_range = 4;
inline bool PathExpand::has_hop_range() const {
  return this != internal_default_instance() && hop_range_ != NULL;
}
inline const ::algebra::Range& PathExpand::_internal_hop_range() const {
  return *hop_range_;
}
inline const ::algebra::Range& PathExpand::hop_range() const {
  const ::algebra::Range* p = hop_range_;
  // @@protoc_insertion_point(field_get:physical.PathExpand.hop_range)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::Range*>(
      &::algebra::_Range_default_instance_);
}
inline ::algebra::Range* PathExpand::release_hop_range() {
  // @@protoc_insertion_point(field_release:physical.PathExpand.hop_range)
  
  ::algebra::Range* temp = hop_range_;
  hop_range_ = NULL;
  return temp;
}
inline ::algebra::Range* PathExpand::mutable_hop_range() {
  
  if (hop_range_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::Range>(GetArenaNoVirtual());
    hop_range_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.PathExpand.hop_range)
  return hop_range_;
}
inline void PathExpand::set_allocated_hop_range(::algebra::Range* hop_range) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(hop_range_);
  }
  if (hop_range) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      hop_range = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hop_range, submessage_arena);
    }
    
  } else {
    
  }
  hop_range_ = hop_range;
  // @@protoc_insertion_point(field_set_allocated:physical.PathExpand.hop_range)
}

// .physical.PathExpand.PathOpt path_opt = 5;
inline void PathExpand::clear_path_opt() {
  path_opt_ = 0;
}
inline ::physical::PathExpand_PathOpt PathExpand::path_opt() const {
  // @@protoc_insertion_point(field_get:physical.PathExpand.path_opt)
  return static_cast< ::physical::PathExpand_PathOpt >(path_opt_);
}
inline void PathExpand::set_path_opt(::physical::PathExpand_PathOpt value) {
  
  path_opt_ = value;
  // @@protoc_insertion_point(field_set:physical.PathExpand.path_opt)
}

// .physical.PathExpand.ResultOpt result_opt = 6;
inline void PathExpand::clear_result_opt() {
  result_opt_ = 0;
}
inline ::physical::PathExpand_ResultOpt PathExpand::result_opt() const {
  // @@protoc_insertion_point(field_get:physical.PathExpand.result_opt)
  return static_cast< ::physical::PathExpand_ResultOpt >(result_opt_);
}
inline void PathExpand::set_result_opt(::physical::PathExpand_ResultOpt value) {
  
  result_opt_ = value;
  // @@protoc_insertion_point(field_set:physical.PathExpand.result_opt)
}

// .common.Expression condition = 7;
inline bool PathExpand::has_condition() const {
  return this != internal_default_instance() && condition_ != NULL;
}
inline const ::common::Expression& PathExpand::_internal_condition() const {
  return *condition_;
}
inline const ::common::Expression& PathExpand::condition() const {
  const ::common::Expression* p = condition_;
  // @@protoc_insertion_point(field_get:physical.PathExpand.condition)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Expression*>(
      &::common::_Expression_default_instance_);
}
inline ::common::Expression* PathExpand::release_condition() {
  // @@protoc_insertion_point(field_release:physical.PathExpand.condition)
  
  ::common::Expression* temp = condition_;
  condition_ = NULL;
  return temp;
}
inline ::common::Expression* PathExpand::mutable_condition() {
  
  if (condition_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Expression>(GetArenaNoVirtual());
    condition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.PathExpand.condition)
  return condition_;
}
inline void PathExpand::set_allocated_condition(::common::Expression* condition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(condition_);
  }
  if (condition) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      condition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, condition, submessage_arena);
    }
    
  } else {
    
  }
  condition_ = condition;
  // @@protoc_insertion_point(field_set_allocated:physical.PathExpand.condition)
}

// -------------------------------------------------------------------

// Sink_OptTag

// .google.protobuf.Int32Value tag = 1;
inline bool Sink_OptTag::has_tag() const {
  return this != internal_default_instance() && tag_ != NULL;
}
inline const ::google::protobuf::Int32Value& Sink_OptTag::_internal_tag() const {
  return *tag_;
}
inline const ::google::protobuf::Int32Value& Sink_OptTag::tag() const {
  const ::google::protobuf::Int32Value* p = tag_;
  // @@protoc_insertion_point(field_get:physical.Sink.OptTag.tag)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* Sink_OptTag::release_tag() {
  // @@protoc_insertion_point(field_release:physical.Sink.OptTag.tag)
  
  ::google::protobuf::Int32Value* temp = tag_;
  tag_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* Sink_OptTag::mutable_tag() {
  
  if (tag_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    tag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.Sink.OptTag.tag)
  return tag_;
}
inline void Sink_OptTag::set_allocated_tag(::google::protobuf::Int32Value* tag) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tag_);
  }
  if (tag) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(tag)->GetArena();
    if (message_arena != submessage_arena) {
      tag = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tag, submessage_arena);
    }
    
  } else {
    
  }
  tag_ = tag;
  // @@protoc_insertion_point(field_set_allocated:physical.Sink.OptTag.tag)
}

// -------------------------------------------------------------------

// Sink

// repeated .physical.Sink.OptTag tags = 1;
inline int Sink::tags_size() const {
  return tags_.size();
}
inline void Sink::clear_tags() {
  tags_.Clear();
}
inline ::physical::Sink_OptTag* Sink::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:physical.Sink.tags)
  return tags_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::physical::Sink_OptTag >*
Sink::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:physical.Sink.tags)
  return &tags_;
}
inline const ::physical::Sink_OptTag& Sink::tags(int index) const {
  // @@protoc_insertion_point(field_get:physical.Sink.tags)
  return tags_.Get(index);
}
inline ::physical::Sink_OptTag* Sink::add_tags() {
  // @@protoc_insertion_point(field_add:physical.Sink.tags)
  return tags_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::physical::Sink_OptTag >&
Sink::tags() const {
  // @@protoc_insertion_point(field_list:physical.Sink.tags)
  return tags_;
}

// .algebra.Sink.SinkTarget sink_target = 2;
inline bool Sink::has_sink_target() const {
  return this != internal_default_instance() && sink_target_ != NULL;
}
inline const ::algebra::Sink_SinkTarget& Sink::_internal_sink_target() const {
  return *sink_target_;
}
inline const ::algebra::Sink_SinkTarget& Sink::sink_target() const {
  const ::algebra::Sink_SinkTarget* p = sink_target_;
  // @@protoc_insertion_point(field_get:physical.Sink.sink_target)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::Sink_SinkTarget*>(
      &::algebra::_Sink_SinkTarget_default_instance_);
}
inline ::algebra::Sink_SinkTarget* Sink::release_sink_target() {
  // @@protoc_insertion_point(field_release:physical.Sink.sink_target)
  
  ::algebra::Sink_SinkTarget* temp = sink_target_;
  sink_target_ = NULL;
  return temp;
}
inline ::algebra::Sink_SinkTarget* Sink::mutable_sink_target() {
  
  if (sink_target_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::Sink_SinkTarget>(GetArenaNoVirtual());
    sink_target_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.Sink.sink_target)
  return sink_target_;
}
inline void Sink::set_allocated_sink_target(::algebra::Sink_SinkTarget* sink_target) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(sink_target_);
  }
  if (sink_target) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sink_target = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sink_target, submessage_arena);
    }
    
  } else {
    
  }
  sink_target_ = sink_target;
  // @@protoc_insertion_point(field_set_allocated:physical.Sink.sink_target)
}

// -------------------------------------------------------------------

// Repartition_Shuffle

// .google.protobuf.Int32Value shuffle_key = 1;
inline bool Repartition_Shuffle::has_shuffle_key() const {
  return this != internal_default_instance() && shuffle_key_ != NULL;
}
inline const ::google::protobuf::Int32Value& Repartition_Shuffle::_internal_shuffle_key() const {
  return *shuffle_key_;
}
inline const ::google::protobuf::Int32Value& Repartition_Shuffle::shuffle_key() const {
  const ::google::protobuf::Int32Value* p = shuffle_key_;
  // @@protoc_insertion_point(field_get:physical.Repartition.Shuffle.shuffle_key)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* Repartition_Shuffle::release_shuffle_key() {
  // @@protoc_insertion_point(field_release:physical.Repartition.Shuffle.shuffle_key)
  
  ::google::protobuf::Int32Value* temp = shuffle_key_;
  shuffle_key_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* Repartition_Shuffle::mutable_shuffle_key() {
  
  if (shuffle_key_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    shuffle_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.Repartition.Shuffle.shuffle_key)
  return shuffle_key_;
}
inline void Repartition_Shuffle::set_allocated_shuffle_key(::google::protobuf::Int32Value* shuffle_key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(shuffle_key_);
  }
  if (shuffle_key) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(shuffle_key)->GetArena();
    if (message_arena != submessage_arena) {
      shuffle_key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, shuffle_key, submessage_arena);
    }
    
  } else {
    
  }
  shuffle_key_ = shuffle_key;
  // @@protoc_insertion_point(field_set_allocated:physical.Repartition.Shuffle.shuffle_key)
}

// -------------------------------------------------------------------

// Repartition_Broadcast

// -------------------------------------------------------------------

// Repartition

// .physical.Repartition.Shuffle to_another = 1;
inline bool Repartition::has_to_another() const {
  return Strategy_case() == kToAnother;
}
inline void Repartition::set_has_to_another() {
  _oneof_case_[0] = kToAnother;
}
inline void Repartition::clear_to_another() {
  if (has_to_another()) {
    delete Strategy_.to_another_;
    clear_has_Strategy();
  }
}
inline const ::physical::Repartition_Shuffle& Repartition::_internal_to_another() const {
  return *Strategy_.to_another_;
}
inline ::physical::Repartition_Shuffle* Repartition::release_to_another() {
  // @@protoc_insertion_point(field_release:physical.Repartition.to_another)
  if (has_to_another()) {
    clear_has_Strategy();
      ::physical::Repartition_Shuffle* temp = Strategy_.to_another_;
    Strategy_.to_another_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::physical::Repartition_Shuffle& Repartition::to_another() const {
  // @@protoc_insertion_point(field_get:physical.Repartition.to_another)
  return has_to_another()
      ? *Strategy_.to_another_
      : *reinterpret_cast< ::physical::Repartition_Shuffle*>(&::physical::_Repartition_Shuffle_default_instance_);
}
inline ::physical::Repartition_Shuffle* Repartition::mutable_to_another() {
  if (!has_to_another()) {
    clear_Strategy();
    set_has_to_another();
    Strategy_.to_another_ = CreateMaybeMessage< ::physical::Repartition_Shuffle >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:physical.Repartition.to_another)
  return Strategy_.to_another_;
}

// .physical.Repartition.Broadcast to_others = 2;
inline bool Repartition::has_to_others() const {
  return Strategy_case() == kToOthers;
}
inline void Repartition::set_has_to_others() {
  _oneof_case_[0] = kToOthers;
}
inline void Repartition::clear_to_others() {
  if (has_to_others()) {
    delete Strategy_.to_others_;
    clear_has_Strategy();
  }
}
inline const ::physical::Repartition_Broadcast& Repartition::_internal_to_others() const {
  return *Strategy_.to_others_;
}
inline ::physical::Repartition_Broadcast* Repartition::release_to_others() {
  // @@protoc_insertion_point(field_release:physical.Repartition.to_others)
  if (has_to_others()) {
    clear_has_Strategy();
      ::physical::Repartition_Broadcast* temp = Strategy_.to_others_;
    Strategy_.to_others_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::physical::Repartition_Broadcast& Repartition::to_others() const {
  // @@protoc_insertion_point(field_get:physical.Repartition.to_others)
  return has_to_others()
      ? *Strategy_.to_others_
      : *reinterpret_cast< ::physical::Repartition_Broadcast*>(&::physical::_Repartition_Broadcast_default_instance_);
}
inline ::physical::Repartition_Broadcast* Repartition::mutable_to_others() {
  if (!has_to_others()) {
    clear_Strategy();
    set_has_to_others();
    Strategy_.to_others_ = CreateMaybeMessage< ::physical::Repartition_Broadcast >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:physical.Repartition.to_others)
  return Strategy_.to_others_;
}

inline bool Repartition::has_Strategy() const {
  return Strategy_case() != STRATEGY_NOT_SET;
}
inline void Repartition::clear_has_Strategy() {
  _oneof_case_[0] = STRATEGY_NOT_SET;
}
inline Repartition::StrategyCase Repartition::Strategy_case() const {
  return Repartition::StrategyCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Root

// -------------------------------------------------------------------

// PhysicalOpr_Operator

// .physical.Project project = 1;
inline bool PhysicalOpr_Operator::has_project() const {
  return op_kind_case() == kProject;
}
inline void PhysicalOpr_Operator::set_has_project() {
  _oneof_case_[0] = kProject;
}
inline void PhysicalOpr_Operator::clear_project() {
  if (has_project()) {
    delete op_kind_.project_;
    clear_has_op_kind();
  }
}
inline const ::physical::Project& PhysicalOpr_Operator::_internal_project() const {
  return *op_kind_.project_;
}
inline ::physical::Project* PhysicalOpr_Operator::release_project() {
  // @@protoc_insertion_point(field_release:physical.PhysicalOpr.Operator.project)
  if (has_project()) {
    clear_has_op_kind();
      ::physical::Project* temp = op_kind_.project_;
    op_kind_.project_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::physical::Project& PhysicalOpr_Operator::project() const {
  // @@protoc_insertion_point(field_get:physical.PhysicalOpr.Operator.project)
  return has_project()
      ? *op_kind_.project_
      : *reinterpret_cast< ::physical::Project*>(&::physical::_Project_default_instance_);
}
inline ::physical::Project* PhysicalOpr_Operator::mutable_project() {
  if (!has_project()) {
    clear_op_kind();
    set_has_project();
    op_kind_.project_ = CreateMaybeMessage< ::physical::Project >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:physical.PhysicalOpr.Operator.project)
  return op_kind_.project_;
}

// .algebra.Select select = 2;
inline bool PhysicalOpr_Operator::has_select() const {
  return op_kind_case() == kSelect;
}
inline void PhysicalOpr_Operator::set_has_select() {
  _oneof_case_[0] = kSelect;
}
inline const ::algebra::Select& PhysicalOpr_Operator::_internal_select() const {
  return *op_kind_.select_;
}
inline ::algebra::Select* PhysicalOpr_Operator::release_select() {
  // @@protoc_insertion_point(field_release:physical.PhysicalOpr.Operator.select)
  if (has_select()) {
    clear_has_op_kind();
      ::algebra::Select* temp = op_kind_.select_;
    op_kind_.select_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::Select& PhysicalOpr_Operator::select() const {
  // @@protoc_insertion_point(field_get:physical.PhysicalOpr.Operator.select)
  return has_select()
      ? *op_kind_.select_
      : *reinterpret_cast< ::algebra::Select*>(&::algebra::_Select_default_instance_);
}
inline ::algebra::Select* PhysicalOpr_Operator::mutable_select() {
  if (!has_select()) {
    clear_op_kind();
    set_has_select();
    op_kind_.select_ = CreateMaybeMessage< ::algebra::Select >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:physical.PhysicalOpr.Operator.select)
  return op_kind_.select_;
}

// .physical.GroupBy group_by = 3;
inline bool PhysicalOpr_Operator::has_group_by() const {
  return op_kind_case() == kGroupBy;
}
inline void PhysicalOpr_Operator::set_has_group_by() {
  _oneof_case_[0] = kGroupBy;
}
inline void PhysicalOpr_Operator::clear_group_by() {
  if (has_group_by()) {
    delete op_kind_.group_by_;
    clear_has_op_kind();
  }
}
inline const ::physical::GroupBy& PhysicalOpr_Operator::_internal_group_by() const {
  return *op_kind_.group_by_;
}
inline ::physical::GroupBy* PhysicalOpr_Operator::release_group_by() {
  // @@protoc_insertion_point(field_release:physical.PhysicalOpr.Operator.group_by)
  if (has_group_by()) {
    clear_has_op_kind();
      ::physical::GroupBy* temp = op_kind_.group_by_;
    op_kind_.group_by_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::physical::GroupBy& PhysicalOpr_Operator::group_by() const {
  // @@protoc_insertion_point(field_get:physical.PhysicalOpr.Operator.group_by)
  return has_group_by()
      ? *op_kind_.group_by_
      : *reinterpret_cast< ::physical::GroupBy*>(&::physical::_GroupBy_default_instance_);
}
inline ::physical::GroupBy* PhysicalOpr_Operator::mutable_group_by() {
  if (!has_group_by()) {
    clear_op_kind();
    set_has_group_by();
    op_kind_.group_by_ = CreateMaybeMessage< ::physical::GroupBy >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:physical.PhysicalOpr.Operator.group_by)
  return op_kind_.group_by_;
}

// .algebra.OrderBy order_by = 4;
inline bool PhysicalOpr_Operator::has_order_by() const {
  return op_kind_case() == kOrderBy;
}
inline void PhysicalOpr_Operator::set_has_order_by() {
  _oneof_case_[0] = kOrderBy;
}
inline const ::algebra::OrderBy& PhysicalOpr_Operator::_internal_order_by() const {
  return *op_kind_.order_by_;
}
inline ::algebra::OrderBy* PhysicalOpr_Operator::release_order_by() {
  // @@protoc_insertion_point(field_release:physical.PhysicalOpr.Operator.order_by)
  if (has_order_by()) {
    clear_has_op_kind();
      ::algebra::OrderBy* temp = op_kind_.order_by_;
    op_kind_.order_by_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::OrderBy& PhysicalOpr_Operator::order_by() const {
  // @@protoc_insertion_point(field_get:physical.PhysicalOpr.Operator.order_by)
  return has_order_by()
      ? *op_kind_.order_by_
      : *reinterpret_cast< ::algebra::OrderBy*>(&::algebra::_OrderBy_default_instance_);
}
inline ::algebra::OrderBy* PhysicalOpr_Operator::mutable_order_by() {
  if (!has_order_by()) {
    clear_op_kind();
    set_has_order_by();
    op_kind_.order_by_ = CreateMaybeMessage< ::algebra::OrderBy >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:physical.PhysicalOpr.Operator.order_by)
  return op_kind_.order_by_;
}

// .algebra.Dedup dedup = 5;
inline bool PhysicalOpr_Operator::has_dedup() const {
  return op_kind_case() == kDedup;
}
inline void PhysicalOpr_Operator::set_has_dedup() {
  _oneof_case_[0] = kDedup;
}
inline const ::algebra::Dedup& PhysicalOpr_Operator::_internal_dedup() const {
  return *op_kind_.dedup_;
}
inline ::algebra::Dedup* PhysicalOpr_Operator::release_dedup() {
  // @@protoc_insertion_point(field_release:physical.PhysicalOpr.Operator.dedup)
  if (has_dedup()) {
    clear_has_op_kind();
      ::algebra::Dedup* temp = op_kind_.dedup_;
    op_kind_.dedup_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::Dedup& PhysicalOpr_Operator::dedup() const {
  // @@protoc_insertion_point(field_get:physical.PhysicalOpr.Operator.dedup)
  return has_dedup()
      ? *op_kind_.dedup_
      : *reinterpret_cast< ::algebra::Dedup*>(&::algebra::_Dedup_default_instance_);
}
inline ::algebra::Dedup* PhysicalOpr_Operator::mutable_dedup() {
  if (!has_dedup()) {
    clear_op_kind();
    set_has_dedup();
    op_kind_.dedup_ = CreateMaybeMessage< ::algebra::Dedup >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:physical.PhysicalOpr.Operator.dedup)
  return op_kind_.dedup_;
}

// .physical.Unfold unfold = 6;
inline bool PhysicalOpr_Operator::has_unfold() const {
  return op_kind_case() == kUnfold;
}
inline void PhysicalOpr_Operator::set_has_unfold() {
  _oneof_case_[0] = kUnfold;
}
inline void PhysicalOpr_Operator::clear_unfold() {
  if (has_unfold()) {
    delete op_kind_.unfold_;
    clear_has_op_kind();
  }
}
inline const ::physical::Unfold& PhysicalOpr_Operator::_internal_unfold() const {
  return *op_kind_.unfold_;
}
inline ::physical::Unfold* PhysicalOpr_Operator::release_unfold() {
  // @@protoc_insertion_point(field_release:physical.PhysicalOpr.Operator.unfold)
  if (has_unfold()) {
    clear_has_op_kind();
      ::physical::Unfold* temp = op_kind_.unfold_;
    op_kind_.unfold_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::physical::Unfold& PhysicalOpr_Operator::unfold() const {
  // @@protoc_insertion_point(field_get:physical.PhysicalOpr.Operator.unfold)
  return has_unfold()
      ? *op_kind_.unfold_
      : *reinterpret_cast< ::physical::Unfold*>(&::physical::_Unfold_default_instance_);
}
inline ::physical::Unfold* PhysicalOpr_Operator::mutable_unfold() {
  if (!has_unfold()) {
    clear_op_kind();
    set_has_unfold();
    op_kind_.unfold_ = CreateMaybeMessage< ::physical::Unfold >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:physical.PhysicalOpr.Operator.unfold)
  return op_kind_.unfold_;
}

// .algebra.Limit limit = 7;
inline bool PhysicalOpr_Operator::has_limit() const {
  return op_kind_case() == kLimit;
}
inline void PhysicalOpr_Operator::set_has_limit() {
  _oneof_case_[0] = kLimit;
}
inline const ::algebra::Limit& PhysicalOpr_Operator::_internal_limit() const {
  return *op_kind_.limit_;
}
inline ::algebra::Limit* PhysicalOpr_Operator::release_limit() {
  // @@protoc_insertion_point(field_release:physical.PhysicalOpr.Operator.limit)
  if (has_limit()) {
    clear_has_op_kind();
      ::algebra::Limit* temp = op_kind_.limit_;
    op_kind_.limit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::Limit& PhysicalOpr_Operator::limit() const {
  // @@protoc_insertion_point(field_get:physical.PhysicalOpr.Operator.limit)
  return has_limit()
      ? *op_kind_.limit_
      : *reinterpret_cast< ::algebra::Limit*>(&::algebra::_Limit_default_instance_);
}
inline ::algebra::Limit* PhysicalOpr_Operator::mutable_limit() {
  if (!has_limit()) {
    clear_op_kind();
    set_has_limit();
    op_kind_.limit_ = CreateMaybeMessage< ::algebra::Limit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:physical.PhysicalOpr.Operator.limit)
  return op_kind_.limit_;
}

// .physical.Scan scan = 8;
inline bool PhysicalOpr_Operator::has_scan() const {
  return op_kind_case() == kScan;
}
inline void PhysicalOpr_Operator::set_has_scan() {
  _oneof_case_[0] = kScan;
}
inline void PhysicalOpr_Operator::clear_scan() {
  if (has_scan()) {
    delete op_kind_.scan_;
    clear_has_op_kind();
  }
}
inline const ::physical::Scan& PhysicalOpr_Operator::_internal_scan() const {
  return *op_kind_.scan_;
}
inline ::physical::Scan* PhysicalOpr_Operator::release_scan() {
  // @@protoc_insertion_point(field_release:physical.PhysicalOpr.Operator.scan)
  if (has_scan()) {
    clear_has_op_kind();
      ::physical::Scan* temp = op_kind_.scan_;
    op_kind_.scan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::physical::Scan& PhysicalOpr_Operator::scan() const {
  // @@protoc_insertion_point(field_get:physical.PhysicalOpr.Operator.scan)
  return has_scan()
      ? *op_kind_.scan_
      : *reinterpret_cast< ::physical::Scan*>(&::physical::_Scan_default_instance_);
}
inline ::physical::Scan* PhysicalOpr_Operator::mutable_scan() {
  if (!has_scan()) {
    clear_op_kind();
    set_has_scan();
    op_kind_.scan_ = CreateMaybeMessage< ::physical::Scan >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:physical.PhysicalOpr.Operator.scan)
  return op_kind_.scan_;
}

// .physical.Sink sink = 9;
inline bool PhysicalOpr_Operator::has_sink() const {
  return op_kind_case() == kSink;
}
inline void PhysicalOpr_Operator::set_has_sink() {
  _oneof_case_[0] = kSink;
}
inline void PhysicalOpr_Operator::clear_sink() {
  if (has_sink()) {
    delete op_kind_.sink_;
    clear_has_op_kind();
  }
}
inline const ::physical::Sink& PhysicalOpr_Operator::_internal_sink() const {
  return *op_kind_.sink_;
}
inline ::physical::Sink* PhysicalOpr_Operator::release_sink() {
  // @@protoc_insertion_point(field_release:physical.PhysicalOpr.Operator.sink)
  if (has_sink()) {
    clear_has_op_kind();
      ::physical::Sink* temp = op_kind_.sink_;
    op_kind_.sink_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::physical::Sink& PhysicalOpr_Operator::sink() const {
  // @@protoc_insertion_point(field_get:physical.PhysicalOpr.Operator.sink)
  return has_sink()
      ? *op_kind_.sink_
      : *reinterpret_cast< ::physical::Sink*>(&::physical::_Sink_default_instance_);
}
inline ::physical::Sink* PhysicalOpr_Operator::mutable_sink() {
  if (!has_sink()) {
    clear_op_kind();
    set_has_sink();
    op_kind_.sink_ = CreateMaybeMessage< ::physical::Sink >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:physical.PhysicalOpr.Operator.sink)
  return op_kind_.sink_;
}

// .physical.Apply apply = 10;
inline bool PhysicalOpr_Operator::has_apply() const {
  return op_kind_case() == kApply;
}
inline void PhysicalOpr_Operator::set_has_apply() {
  _oneof_case_[0] = kApply;
}
inline void PhysicalOpr_Operator::clear_apply() {
  if (has_apply()) {
    delete op_kind_.apply_;
    clear_has_op_kind();
  }
}
inline const ::physical::Apply& PhysicalOpr_Operator::_internal_apply() const {
  return *op_kind_.apply_;
}
inline ::physical::Apply* PhysicalOpr_Operator::release_apply() {
  // @@protoc_insertion_point(field_release:physical.PhysicalOpr.Operator.apply)
  if (has_apply()) {
    clear_has_op_kind();
      ::physical::Apply* temp = op_kind_.apply_;
    op_kind_.apply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::physical::Apply& PhysicalOpr_Operator::apply() const {
  // @@protoc_insertion_point(field_get:physical.PhysicalOpr.Operator.apply)
  return has_apply()
      ? *op_kind_.apply_
      : *reinterpret_cast< ::physical::Apply*>(&::physical::_Apply_default_instance_);
}
inline ::physical::Apply* PhysicalOpr_Operator::mutable_apply() {
  if (!has_apply()) {
    clear_op_kind();
    set_has_apply();
    op_kind_.apply_ = CreateMaybeMessage< ::physical::Apply >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:physical.PhysicalOpr.Operator.apply)
  return op_kind_.apply_;
}

// .physical.Join join = 11;
inline bool PhysicalOpr_Operator::has_join() const {
  return op_kind_case() == kJoin;
}
inline void PhysicalOpr_Operator::set_has_join() {
  _oneof_case_[0] = kJoin;
}
inline void PhysicalOpr_Operator::clear_join() {
  if (has_join()) {
    delete op_kind_.join_;
    clear_has_op_kind();
  }
}
inline const ::physical::Join& PhysicalOpr_Operator::_internal_join() const {
  return *op_kind_.join_;
}
inline ::physical::Join* PhysicalOpr_Operator::release_join() {
  // @@protoc_insertion_point(field_release:physical.PhysicalOpr.Operator.join)
  if (has_join()) {
    clear_has_op_kind();
      ::physical::Join* temp = op_kind_.join_;
    op_kind_.join_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::physical::Join& PhysicalOpr_Operator::join() const {
  // @@protoc_insertion_point(field_get:physical.PhysicalOpr.Operator.join)
  return has_join()
      ? *op_kind_.join_
      : *reinterpret_cast< ::physical::Join*>(&::physical::_Join_default_instance_);
}
inline ::physical::Join* PhysicalOpr_Operator::mutable_join() {
  if (!has_join()) {
    clear_op_kind();
    set_has_join();
    op_kind_.join_ = CreateMaybeMessage< ::physical::Join >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:physical.PhysicalOpr.Operator.join)
  return op_kind_.join_;
}

// .physical.Union union = 12;
inline bool PhysicalOpr_Operator::has_union_() const {
  return op_kind_case() == kUnion;
}
inline void PhysicalOpr_Operator::set_has_union_() {
  _oneof_case_[0] = kUnion;
}
inline void PhysicalOpr_Operator::clear_union_() {
  if (has_union_()) {
    delete op_kind_.union__;
    clear_has_op_kind();
  }
}
inline const ::physical::Union& PhysicalOpr_Operator::_internal_union_() const {
  return *op_kind_.union__;
}
inline ::physical::Union* PhysicalOpr_Operator::release_union_() {
  // @@protoc_insertion_point(field_release:physical.PhysicalOpr.Operator.union)
  if (has_union_()) {
    clear_has_op_kind();
      ::physical::Union* temp = op_kind_.union__;
    op_kind_.union__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::physical::Union& PhysicalOpr_Operator::union_() const {
  // @@protoc_insertion_point(field_get:physical.PhysicalOpr.Operator.union)
  return has_union_()
      ? *op_kind_.union__
      : *reinterpret_cast< ::physical::Union*>(&::physical::_Union_default_instance_);
}
inline ::physical::Union* PhysicalOpr_Operator::mutable_union_() {
  if (!has_union_()) {
    clear_op_kind();
    set_has_union_();
    op_kind_.union__ = CreateMaybeMessage< ::physical::Union >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:physical.PhysicalOpr.Operator.union)
  return op_kind_.union__;
}

// .physical.Intersect intersect = 13;
inline bool PhysicalOpr_Operator::has_intersect() const {
  return op_kind_case() == kIntersect;
}
inline void PhysicalOpr_Operator::set_has_intersect() {
  _oneof_case_[0] = kIntersect;
}
inline void PhysicalOpr_Operator::clear_intersect() {
  if (has_intersect()) {
    delete op_kind_.intersect_;
    clear_has_op_kind();
  }
}
inline const ::physical::Intersect& PhysicalOpr_Operator::_internal_intersect() const {
  return *op_kind_.intersect_;
}
inline ::physical::Intersect* PhysicalOpr_Operator::release_intersect() {
  // @@protoc_insertion_point(field_release:physical.PhysicalOpr.Operator.intersect)
  if (has_intersect()) {
    clear_has_op_kind();
      ::physical::Intersect* temp = op_kind_.intersect_;
    op_kind_.intersect_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::physical::Intersect& PhysicalOpr_Operator::intersect() const {
  // @@protoc_insertion_point(field_get:physical.PhysicalOpr.Operator.intersect)
  return has_intersect()
      ? *op_kind_.intersect_
      : *reinterpret_cast< ::physical::Intersect*>(&::physical::_Intersect_default_instance_);
}
inline ::physical::Intersect* PhysicalOpr_Operator::mutable_intersect() {
  if (!has_intersect()) {
    clear_op_kind();
    set_has_intersect();
    op_kind_.intersect_ = CreateMaybeMessage< ::physical::Intersect >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:physical.PhysicalOpr.Operator.intersect)
  return op_kind_.intersect_;
}

// .physical.Repartition repartition = 14;
inline bool PhysicalOpr_Operator::has_repartition() const {
  return op_kind_case() == kRepartition;
}
inline void PhysicalOpr_Operator::set_has_repartition() {
  _oneof_case_[0] = kRepartition;
}
inline void PhysicalOpr_Operator::clear_repartition() {
  if (has_repartition()) {
    delete op_kind_.repartition_;
    clear_has_op_kind();
  }
}
inline const ::physical::Repartition& PhysicalOpr_Operator::_internal_repartition() const {
  return *op_kind_.repartition_;
}
inline ::physical::Repartition* PhysicalOpr_Operator::release_repartition() {
  // @@protoc_insertion_point(field_release:physical.PhysicalOpr.Operator.repartition)
  if (has_repartition()) {
    clear_has_op_kind();
      ::physical::Repartition* temp = op_kind_.repartition_;
    op_kind_.repartition_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::physical::Repartition& PhysicalOpr_Operator::repartition() const {
  // @@protoc_insertion_point(field_get:physical.PhysicalOpr.Operator.repartition)
  return has_repartition()
      ? *op_kind_.repartition_
      : *reinterpret_cast< ::physical::Repartition*>(&::physical::_Repartition_default_instance_);
}
inline ::physical::Repartition* PhysicalOpr_Operator::mutable_repartition() {
  if (!has_repartition()) {
    clear_op_kind();
    set_has_repartition();
    op_kind_.repartition_ = CreateMaybeMessage< ::physical::Repartition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:physical.PhysicalOpr.Operator.repartition)
  return op_kind_.repartition_;
}

// .physical.Root root = 16;
inline bool PhysicalOpr_Operator::has_root() const {
  return op_kind_case() == kRoot;
}
inline void PhysicalOpr_Operator::set_has_root() {
  _oneof_case_[0] = kRoot;
}
inline void PhysicalOpr_Operator::clear_root() {
  if (has_root()) {
    delete op_kind_.root_;
    clear_has_op_kind();
  }
}
inline const ::physical::Root& PhysicalOpr_Operator::_internal_root() const {
  return *op_kind_.root_;
}
inline ::physical::Root* PhysicalOpr_Operator::release_root() {
  // @@protoc_insertion_point(field_release:physical.PhysicalOpr.Operator.root)
  if (has_root()) {
    clear_has_op_kind();
      ::physical::Root* temp = op_kind_.root_;
    op_kind_.root_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::physical::Root& PhysicalOpr_Operator::root() const {
  // @@protoc_insertion_point(field_get:physical.PhysicalOpr.Operator.root)
  return has_root()
      ? *op_kind_.root_
      : *reinterpret_cast< ::physical::Root*>(&::physical::_Root_default_instance_);
}
inline ::physical::Root* PhysicalOpr_Operator::mutable_root() {
  if (!has_root()) {
    clear_op_kind();
    set_has_root();
    op_kind_.root_ = CreateMaybeMessage< ::physical::Root >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:physical.PhysicalOpr.Operator.root)
  return op_kind_.root_;
}

// .algebra.Sample sample = 17;
inline bool PhysicalOpr_Operator::has_sample() const {
  return op_kind_case() == kSample;
}
inline void PhysicalOpr_Operator::set_has_sample() {
  _oneof_case_[0] = kSample;
}
inline const ::algebra::Sample& PhysicalOpr_Operator::_internal_sample() const {
  return *op_kind_.sample_;
}
inline ::algebra::Sample* PhysicalOpr_Operator::release_sample() {
  // @@protoc_insertion_point(field_release:physical.PhysicalOpr.Operator.sample)
  if (has_sample()) {
    clear_has_op_kind();
      ::algebra::Sample* temp = op_kind_.sample_;
    op_kind_.sample_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::Sample& PhysicalOpr_Operator::sample() const {
  // @@protoc_insertion_point(field_get:physical.PhysicalOpr.Operator.sample)
  return has_sample()
      ? *op_kind_.sample_
      : *reinterpret_cast< ::algebra::Sample*>(&::algebra::_Sample_default_instance_);
}
inline ::algebra::Sample* PhysicalOpr_Operator::mutable_sample() {
  if (!has_sample()) {
    clear_op_kind();
    set_has_sample();
    op_kind_.sample_ = CreateMaybeMessage< ::algebra::Sample >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:physical.PhysicalOpr.Operator.sample)
  return op_kind_.sample_;
}

// .physical.GetV vertex = 30;
inline bool PhysicalOpr_Operator::has_vertex() const {
  return op_kind_case() == kVertex;
}
inline void PhysicalOpr_Operator::set_has_vertex() {
  _oneof_case_[0] = kVertex;
}
inline void PhysicalOpr_Operator::clear_vertex() {
  if (has_vertex()) {
    delete op_kind_.vertex_;
    clear_has_op_kind();
  }
}
inline const ::physical::GetV& PhysicalOpr_Operator::_internal_vertex() const {
  return *op_kind_.vertex_;
}
inline ::physical::GetV* PhysicalOpr_Operator::release_vertex() {
  // @@protoc_insertion_point(field_release:physical.PhysicalOpr.Operator.vertex)
  if (has_vertex()) {
    clear_has_op_kind();
      ::physical::GetV* temp = op_kind_.vertex_;
    op_kind_.vertex_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::physical::GetV& PhysicalOpr_Operator::vertex() const {
  // @@protoc_insertion_point(field_get:physical.PhysicalOpr.Operator.vertex)
  return has_vertex()
      ? *op_kind_.vertex_
      : *reinterpret_cast< ::physical::GetV*>(&::physical::_GetV_default_instance_);
}
inline ::physical::GetV* PhysicalOpr_Operator::mutable_vertex() {
  if (!has_vertex()) {
    clear_op_kind();
    set_has_vertex();
    op_kind_.vertex_ = CreateMaybeMessage< ::physical::GetV >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:physical.PhysicalOpr.Operator.vertex)
  return op_kind_.vertex_;
}

// .physical.EdgeExpand edge = 31;
inline bool PhysicalOpr_Operator::has_edge() const {
  return op_kind_case() == kEdge;
}
inline void PhysicalOpr_Operator::set_has_edge() {
  _oneof_case_[0] = kEdge;
}
inline void PhysicalOpr_Operator::clear_edge() {
  if (has_edge()) {
    delete op_kind_.edge_;
    clear_has_op_kind();
  }
}
inline const ::physical::EdgeExpand& PhysicalOpr_Operator::_internal_edge() const {
  return *op_kind_.edge_;
}
inline ::physical::EdgeExpand* PhysicalOpr_Operator::release_edge() {
  // @@protoc_insertion_point(field_release:physical.PhysicalOpr.Operator.edge)
  if (has_edge()) {
    clear_has_op_kind();
      ::physical::EdgeExpand* temp = op_kind_.edge_;
    op_kind_.edge_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::physical::EdgeExpand& PhysicalOpr_Operator::edge() const {
  // @@protoc_insertion_point(field_get:physical.PhysicalOpr.Operator.edge)
  return has_edge()
      ? *op_kind_.edge_
      : *reinterpret_cast< ::physical::EdgeExpand*>(&::physical::_EdgeExpand_default_instance_);
}
inline ::physical::EdgeExpand* PhysicalOpr_Operator::mutable_edge() {
  if (!has_edge()) {
    clear_op_kind();
    set_has_edge();
    op_kind_.edge_ = CreateMaybeMessage< ::physical::EdgeExpand >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:physical.PhysicalOpr.Operator.edge)
  return op_kind_.edge_;
}

// .physical.PathExpand path = 32;
inline bool PhysicalOpr_Operator::has_path() const {
  return op_kind_case() == kPath;
}
inline void PhysicalOpr_Operator::set_has_path() {
  _oneof_case_[0] = kPath;
}
inline void PhysicalOpr_Operator::clear_path() {
  if (has_path()) {
    delete op_kind_.path_;
    clear_has_op_kind();
  }
}
inline const ::physical::PathExpand& PhysicalOpr_Operator::_internal_path() const {
  return *op_kind_.path_;
}
inline ::physical::PathExpand* PhysicalOpr_Operator::release_path() {
  // @@protoc_insertion_point(field_release:physical.PhysicalOpr.Operator.path)
  if (has_path()) {
    clear_has_op_kind();
      ::physical::PathExpand* temp = op_kind_.path_;
    op_kind_.path_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::physical::PathExpand& PhysicalOpr_Operator::path() const {
  // @@protoc_insertion_point(field_get:physical.PhysicalOpr.Operator.path)
  return has_path()
      ? *op_kind_.path_
      : *reinterpret_cast< ::physical::PathExpand*>(&::physical::_PathExpand_default_instance_);
}
inline ::physical::PathExpand* PhysicalOpr_Operator::mutable_path() {
  if (!has_path()) {
    clear_op_kind();
    set_has_path();
    op_kind_.path_ = CreateMaybeMessage< ::physical::PathExpand >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:physical.PhysicalOpr.Operator.path)
  return op_kind_.path_;
}

inline bool PhysicalOpr_Operator::has_op_kind() const {
  return op_kind_case() != OP_KIND_NOT_SET;
}
inline void PhysicalOpr_Operator::clear_has_op_kind() {
  _oneof_case_[0] = OP_KIND_NOT_SET;
}
inline PhysicalOpr_Operator::OpKindCase PhysicalOpr_Operator::op_kind_case() const {
  return PhysicalOpr_Operator::OpKindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PhysicalOpr_MetaData

// .common.IrDataType type = 1;
inline bool PhysicalOpr_MetaData::has_type() const {
  return this != internal_default_instance() && type_ != NULL;
}
inline const ::common::IrDataType& PhysicalOpr_MetaData::_internal_type() const {
  return *type_;
}
inline const ::common::IrDataType& PhysicalOpr_MetaData::type() const {
  const ::common::IrDataType* p = type_;
  // @@protoc_insertion_point(field_get:physical.PhysicalOpr.MetaData.type)
  return p != NULL ? *p : *reinterpret_cast<const ::common::IrDataType*>(
      &::common::_IrDataType_default_instance_);
}
inline ::common::IrDataType* PhysicalOpr_MetaData::release_type() {
  // @@protoc_insertion_point(field_release:physical.PhysicalOpr.MetaData.type)
  
  ::common::IrDataType* temp = type_;
  type_ = NULL;
  return temp;
}
inline ::common::IrDataType* PhysicalOpr_MetaData::mutable_type() {
  
  if (type_ == NULL) {
    auto* p = CreateMaybeMessage<::common::IrDataType>(GetArenaNoVirtual());
    type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.PhysicalOpr.MetaData.type)
  return type_;
}
inline void PhysicalOpr_MetaData::set_allocated_type(::common::IrDataType* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(type_);
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:physical.PhysicalOpr.MetaData.type)
}

// int32 alias = 2;
inline void PhysicalOpr_MetaData::clear_alias() {
  alias_ = 0;
}
inline ::google::protobuf::int32 PhysicalOpr_MetaData::alias() const {
  // @@protoc_insertion_point(field_get:physical.PhysicalOpr.MetaData.alias)
  return alias_;
}
inline void PhysicalOpr_MetaData::set_alias(::google::protobuf::int32 value) {
  
  alias_ = value;
  // @@protoc_insertion_point(field_set:physical.PhysicalOpr.MetaData.alias)
}

// -------------------------------------------------------------------

// PhysicalOpr

// .physical.PhysicalOpr.Operator opr = 1;
inline bool PhysicalOpr::has_opr() const {
  return this != internal_default_instance() && opr_ != NULL;
}
inline void PhysicalOpr::clear_opr() {
  if (GetArenaNoVirtual() == NULL && opr_ != NULL) {
    delete opr_;
  }
  opr_ = NULL;
}
inline const ::physical::PhysicalOpr_Operator& PhysicalOpr::_internal_opr() const {
  return *opr_;
}
inline const ::physical::PhysicalOpr_Operator& PhysicalOpr::opr() const {
  const ::physical::PhysicalOpr_Operator* p = opr_;
  // @@protoc_insertion_point(field_get:physical.PhysicalOpr.opr)
  return p != NULL ? *p : *reinterpret_cast<const ::physical::PhysicalOpr_Operator*>(
      &::physical::_PhysicalOpr_Operator_default_instance_);
}
inline ::physical::PhysicalOpr_Operator* PhysicalOpr::release_opr() {
  // @@protoc_insertion_point(field_release:physical.PhysicalOpr.opr)
  
  ::physical::PhysicalOpr_Operator* temp = opr_;
  opr_ = NULL;
  return temp;
}
inline ::physical::PhysicalOpr_Operator* PhysicalOpr::mutable_opr() {
  
  if (opr_ == NULL) {
    auto* p = CreateMaybeMessage<::physical::PhysicalOpr_Operator>(GetArenaNoVirtual());
    opr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:physical.PhysicalOpr.opr)
  return opr_;
}
inline void PhysicalOpr::set_allocated_opr(::physical::PhysicalOpr_Operator* opr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete opr_;
  }
  if (opr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      opr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, opr, submessage_arena);
    }
    
  } else {
    
  }
  opr_ = opr;
  // @@protoc_insertion_point(field_set_allocated:physical.PhysicalOpr.opr)
}

// repeated .physical.PhysicalOpr.MetaData meta_data = 2;
inline int PhysicalOpr::meta_data_size() const {
  return meta_data_.size();
}
inline void PhysicalOpr::clear_meta_data() {
  meta_data_.Clear();
}
inline ::physical::PhysicalOpr_MetaData* PhysicalOpr::mutable_meta_data(int index) {
  // @@protoc_insertion_point(field_mutable:physical.PhysicalOpr.meta_data)
  return meta_data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::physical::PhysicalOpr_MetaData >*
PhysicalOpr::mutable_meta_data() {
  // @@protoc_insertion_point(field_mutable_list:physical.PhysicalOpr.meta_data)
  return &meta_data_;
}
inline const ::physical::PhysicalOpr_MetaData& PhysicalOpr::meta_data(int index) const {
  // @@protoc_insertion_point(field_get:physical.PhysicalOpr.meta_data)
  return meta_data_.Get(index);
}
inline ::physical::PhysicalOpr_MetaData* PhysicalOpr::add_meta_data() {
  // @@protoc_insertion_point(field_add:physical.PhysicalOpr.meta_data)
  return meta_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::physical::PhysicalOpr_MetaData >&
PhysicalOpr::meta_data() const {
  // @@protoc_insertion_point(field_list:physical.PhysicalOpr.meta_data)
  return meta_data_;
}

// -------------------------------------------------------------------

// PhysicalPlan

// repeated .physical.PhysicalOpr plan = 1;
inline int PhysicalPlan::plan_size() const {
  return plan_.size();
}
inline void PhysicalPlan::clear_plan() {
  plan_.Clear();
}
inline ::physical::PhysicalOpr* PhysicalPlan::mutable_plan(int index) {
  // @@protoc_insertion_point(field_mutable:physical.PhysicalPlan.plan)
  return plan_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::physical::PhysicalOpr >*
PhysicalPlan::mutable_plan() {
  // @@protoc_insertion_point(field_mutable_list:physical.PhysicalPlan.plan)
  return &plan_;
}
inline const ::physical::PhysicalOpr& PhysicalPlan::plan(int index) const {
  // @@protoc_insertion_point(field_get:physical.PhysicalPlan.plan)
  return plan_.Get(index);
}
inline ::physical::PhysicalOpr* PhysicalPlan::add_plan() {
  // @@protoc_insertion_point(field_add:physical.PhysicalPlan.plan)
  return plan_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::physical::PhysicalOpr >&
PhysicalPlan::plan() const {
  // @@protoc_insertion_point(field_list:physical.PhysicalPlan.plan)
  return plan_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace physical

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::physical::GroupBy_AggFunc_Aggregate> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::physical::GroupBy_AggFunc_Aggregate>() {
  return ::physical::GroupBy_AggFunc_Aggregate_descriptor();
}
template <> struct is_proto_enum< ::physical::Join_JoinKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::physical::Join_JoinKind>() {
  return ::physical::Join_JoinKind_descriptor();
}
template <> struct is_proto_enum< ::physical::Scan_ScanOpt> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::physical::Scan_ScanOpt>() {
  return ::physical::Scan_ScanOpt_descriptor();
}
template <> struct is_proto_enum< ::physical::GetV_VOpt> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::physical::GetV_VOpt>() {
  return ::physical::GetV_VOpt_descriptor();
}
template <> struct is_proto_enum< ::physical::EdgeExpand_Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::physical::EdgeExpand_Direction>() {
  return ::physical::EdgeExpand_Direction_descriptor();
}
template <> struct is_proto_enum< ::physical::EdgeExpand_ExpandOpt> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::physical::EdgeExpand_ExpandOpt>() {
  return ::physical::EdgeExpand_ExpandOpt_descriptor();
}
template <> struct is_proto_enum< ::physical::PathExpand_PathOpt> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::physical::PathExpand_PathOpt>() {
  return ::physical::PathExpand_PathOpt_descriptor();
}
template <> struct is_proto_enum< ::physical::PathExpand_ResultOpt> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::physical::PathExpand_ResultOpt>() {
  return ::physical::PathExpand_ResultOpt_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_physical_2eproto
