// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: job_service.proto

#ifndef PROTOBUF_INCLUDED_job_5fservice_2eproto
#define PROTOBUF_INCLUDED_job_5fservice_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_job_5fservice_2eproto 

namespace protobuf_job_5fservice_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_job_5fservice_2eproto
namespace protocol {
class BinaryResource;
class BinaryResourceDefaultTypeInternal;
extern BinaryResourceDefaultTypeInternal _BinaryResource_default_instance_;
class Empty;
class EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class JobConfig;
class JobConfigDefaultTypeInternal;
extern JobConfigDefaultTypeInternal _JobConfig_default_instance_;
class JobRequest;
class JobRequestDefaultTypeInternal;
extern JobRequestDefaultTypeInternal _JobRequest_default_instance_;
class JobResponse;
class JobResponseDefaultTypeInternal;
extern JobResponseDefaultTypeInternal _JobResponse_default_instance_;
class Name;
class NameDefaultTypeInternal;
extern NameDefaultTypeInternal _Name_default_instance_;
class ServerList;
class ServerListDefaultTypeInternal;
extern ServerListDefaultTypeInternal _ServerList_default_instance_;
}  // namespace protocol
namespace google {
namespace protobuf {
template<> ::protocol::BinaryResource* Arena::CreateMaybeMessage<::protocol::BinaryResource>(Arena*);
template<> ::protocol::Empty* Arena::CreateMaybeMessage<::protocol::Empty>(Arena*);
template<> ::protocol::JobConfig* Arena::CreateMaybeMessage<::protocol::JobConfig>(Arena*);
template<> ::protocol::JobRequest* Arena::CreateMaybeMessage<::protocol::JobRequest>(Arena*);
template<> ::protocol::JobResponse* Arena::CreateMaybeMessage<::protocol::JobResponse>(Arena*);
template<> ::protocol::Name* Arena::CreateMaybeMessage<::protocol::Name>(Arena*);
template<> ::protocol::ServerList* Arena::CreateMaybeMessage<::protocol::ServerList>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace protocol {

// ===================================================================

class Empty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Empty) */ {
 public:
  Empty();
  virtual ~Empty();

  Empty(const Empty& from);

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(Empty&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Empty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Empty* other);
  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Empty* New() const final {
    return CreateMaybeMessage<Empty>(NULL);
  }

  Empty* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Empty& from);
  void MergeFrom(const Empty& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Empty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protocol.Empty)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_job_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Name : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Name) */ {
 public:
  Name();
  virtual ~Name();

  Name(const Name& from);

  inline Name& operator=(const Name& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Name(Name&& from) noexcept
    : Name() {
    *this = ::std::move(from);
  }

  inline Name& operator=(Name&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Name& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Name* internal_default_instance() {
    return reinterpret_cast<const Name*>(
               &_Name_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Name* other);
  friend void swap(Name& a, Name& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Name* New() const final {
    return CreateMaybeMessage<Name>(NULL);
  }

  Name* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Name>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Name& from);
  void MergeFrom(const Name& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Name* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:protocol.Name)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_job_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BinaryResource : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.BinaryResource) */ {
 public:
  BinaryResource();
  virtual ~BinaryResource();

  BinaryResource(const BinaryResource& from);

  inline BinaryResource& operator=(const BinaryResource& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinaryResource(BinaryResource&& from) noexcept
    : BinaryResource() {
    *this = ::std::move(from);
  }

  inline BinaryResource& operator=(BinaryResource&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BinaryResource& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinaryResource* internal_default_instance() {
    return reinterpret_cast<const BinaryResource*>(
               &_BinaryResource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(BinaryResource* other);
  friend void swap(BinaryResource& a, BinaryResource& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinaryResource* New() const final {
    return CreateMaybeMessage<BinaryResource>(NULL);
  }

  BinaryResource* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinaryResource>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinaryResource& from);
  void MergeFrom(const BinaryResource& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryResource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bytes resource = 2;
  void clear_resource();
  static const int kResourceFieldNumber = 2;
  const ::std::string& resource() const;
  void set_resource(const ::std::string& value);
  #if LANG_CXX11
  void set_resource(::std::string&& value);
  #endif
  void set_resource(const char* value);
  void set_resource(const void* value, size_t size);
  ::std::string* mutable_resource();
  ::std::string* release_resource();
  void set_allocated_resource(::std::string* resource);

  // @@protoc_insertion_point(class_scope:protocol.BinaryResource)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr resource_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_job_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ServerList) */ {
 public:
  ServerList();
  virtual ~ServerList();

  ServerList(const ServerList& from);

  inline ServerList& operator=(const ServerList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerList(ServerList&& from) noexcept
    : ServerList() {
    *this = ::std::move(from);
  }

  inline ServerList& operator=(ServerList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerList* internal_default_instance() {
    return reinterpret_cast<const ServerList*>(
               &_ServerList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ServerList* other);
  friend void swap(ServerList& a, ServerList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerList* New() const final {
    return CreateMaybeMessage<ServerList>(NULL);
  }

  ServerList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerList& from);
  void MergeFrom(const ServerList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 servers = 1;
  int servers_size() const;
  void clear_servers();
  static const int kServersFieldNumber = 1;
  ::google::protobuf::uint64 servers(int index) const;
  void set_servers(int index, ::google::protobuf::uint64 value);
  void add_servers(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      servers() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_servers();

  // @@protoc_insertion_point(class_scope:protocol.ServerList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > servers_;
  mutable int _servers_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_job_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JobConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.JobConfig) */ {
 public:
  JobConfig();
  virtual ~JobConfig();

  JobConfig(const JobConfig& from);

  inline JobConfig& operator=(const JobConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JobConfig(JobConfig&& from) noexcept
    : JobConfig() {
    *this = ::std::move(from);
  }

  inline JobConfig& operator=(JobConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JobConfig& default_instance();

  enum ServersCase {
    kLocal = 9,
    kPart = 10,
    kAll = 11,
    SERVERS_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JobConfig* internal_default_instance() {
    return reinterpret_cast<const JobConfig*>(
               &_JobConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(JobConfig* other);
  friend void swap(JobConfig& a, JobConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JobConfig* New() const final {
    return CreateMaybeMessage<JobConfig>(NULL);
  }

  JobConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JobConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JobConfig& from);
  void MergeFrom(const JobConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string job_name = 2;
  void clear_job_name();
  static const int kJobNameFieldNumber = 2;
  const ::std::string& job_name() const;
  void set_job_name(const ::std::string& value);
  #if LANG_CXX11
  void set_job_name(::std::string&& value);
  #endif
  void set_job_name(const char* value);
  void set_job_name(const char* value, size_t size);
  ::std::string* mutable_job_name();
  ::std::string* release_job_name();
  void set_allocated_job_name(::std::string* job_name);

  // uint64 job_id = 1;
  void clear_job_id();
  static const int kJobIdFieldNumber = 1;
  ::google::protobuf::uint64 job_id() const;
  void set_job_id(::google::protobuf::uint64 value);

  // uint64 time_limit = 4;
  void clear_time_limit();
  static const int kTimeLimitFieldNumber = 4;
  ::google::protobuf::uint64 time_limit() const;
  void set_time_limit(::google::protobuf::uint64 value);

  // uint32 workers = 3;
  void clear_workers();
  static const int kWorkersFieldNumber = 3;
  ::google::protobuf::uint32 workers() const;
  void set_workers(::google::protobuf::uint32 value);

  // uint32 batch_size = 5;
  void clear_batch_size();
  static const int kBatchSizeFieldNumber = 5;
  ::google::protobuf::uint32 batch_size() const;
  void set_batch_size(::google::protobuf::uint32 value);

  // uint32 batch_capacity = 6;
  void clear_batch_capacity();
  static const int kBatchCapacityFieldNumber = 6;
  ::google::protobuf::uint32 batch_capacity() const;
  void set_batch_capacity(::google::protobuf::uint32 value);

  // uint32 memory_limit = 7;
  void clear_memory_limit();
  static const int kMemoryLimitFieldNumber = 7;
  ::google::protobuf::uint32 memory_limit() const;
  void set_memory_limit(::google::protobuf::uint32 value);

  // bool trace_enable = 8;
  void clear_trace_enable();
  static const int kTraceEnableFieldNumber = 8;
  bool trace_enable() const;
  void set_trace_enable(bool value);

  // .protocol.Empty local = 9;
  bool has_local() const;
  void clear_local();
  static const int kLocalFieldNumber = 9;
  private:
  const ::protocol::Empty& _internal_local() const;
  public:
  const ::protocol::Empty& local() const;
  ::protocol::Empty* release_local();
  ::protocol::Empty* mutable_local();
  void set_allocated_local(::protocol::Empty* local);

  // .protocol.ServerList part = 10;
  bool has_part() const;
  void clear_part();
  static const int kPartFieldNumber = 10;
  private:
  const ::protocol::ServerList& _internal_part() const;
  public:
  const ::protocol::ServerList& part() const;
  ::protocol::ServerList* release_part();
  ::protocol::ServerList* mutable_part();
  void set_allocated_part(::protocol::ServerList* part);

  // .protocol.Empty all = 11;
  bool has_all() const;
  void clear_all();
  static const int kAllFieldNumber = 11;
  private:
  const ::protocol::Empty& _internal_all() const;
  public:
  const ::protocol::Empty& all() const;
  ::protocol::Empty* release_all();
  ::protocol::Empty* mutable_all();
  void set_allocated_all(::protocol::Empty* all);

  void clear_servers();
  ServersCase servers_case() const;
  // @@protoc_insertion_point(class_scope:protocol.JobConfig)
 private:
  void set_has_local();
  void set_has_part();
  void set_has_all();

  inline bool has_servers() const;
  inline void clear_has_servers();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr job_name_;
  ::google::protobuf::uint64 job_id_;
  ::google::protobuf::uint64 time_limit_;
  ::google::protobuf::uint32 workers_;
  ::google::protobuf::uint32 batch_size_;
  ::google::protobuf::uint32 batch_capacity_;
  ::google::protobuf::uint32 memory_limit_;
  bool trace_enable_;
  union ServersUnion {
    ServersUnion() {}
    ::protocol::Empty* local_;
    ::protocol::ServerList* part_;
    ::protocol::Empty* all_;
  } servers_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_job_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JobRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.JobRequest) */ {
 public:
  JobRequest();
  virtual ~JobRequest();

  JobRequest(const JobRequest& from);

  inline JobRequest& operator=(const JobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JobRequest(JobRequest&& from) noexcept
    : JobRequest() {
    *this = ::std::move(from);
  }

  inline JobRequest& operator=(JobRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JobRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JobRequest* internal_default_instance() {
    return reinterpret_cast<const JobRequest*>(
               &_JobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(JobRequest* other);
  friend void swap(JobRequest& a, JobRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JobRequest* New() const final {
    return CreateMaybeMessage<JobRequest>(NULL);
  }

  JobRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JobRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JobRequest& from);
  void MergeFrom(const JobRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes source = 2;
  void clear_source();
  static const int kSourceFieldNumber = 2;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  #if LANG_CXX11
  void set_source(::std::string&& value);
  #endif
  void set_source(const char* value);
  void set_source(const void* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // bytes plan = 3;
  void clear_plan();
  static const int kPlanFieldNumber = 3;
  const ::std::string& plan() const;
  void set_plan(const ::std::string& value);
  #if LANG_CXX11
  void set_plan(::std::string&& value);
  #endif
  void set_plan(const char* value);
  void set_plan(const void* value, size_t size);
  ::std::string* mutable_plan();
  ::std::string* release_plan();
  void set_allocated_plan(::std::string* plan);

  // bytes resource = 4;
  void clear_resource();
  static const int kResourceFieldNumber = 4;
  const ::std::string& resource() const;
  void set_resource(const ::std::string& value);
  #if LANG_CXX11
  void set_resource(::std::string&& value);
  #endif
  void set_resource(const char* value);
  void set_resource(const void* value, size_t size);
  ::std::string* mutable_resource();
  ::std::string* release_resource();
  void set_allocated_resource(::std::string* resource);

  // .protocol.JobConfig conf = 1;
  bool has_conf() const;
  void clear_conf();
  static const int kConfFieldNumber = 1;
  private:
  const ::protocol::JobConfig& _internal_conf() const;
  public:
  const ::protocol::JobConfig& conf() const;
  ::protocol::JobConfig* release_conf();
  ::protocol::JobConfig* mutable_conf();
  void set_allocated_conf(::protocol::JobConfig* conf);

  // @@protoc_insertion_point(class_scope:protocol.JobRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  ::google::protobuf::internal::ArenaStringPtr plan_;
  ::google::protobuf::internal::ArenaStringPtr resource_;
  ::protocol::JobConfig* conf_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_job_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JobResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.JobResponse) */ {
 public:
  JobResponse();
  virtual ~JobResponse();

  JobResponse(const JobResponse& from);

  inline JobResponse& operator=(const JobResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JobResponse(JobResponse&& from) noexcept
    : JobResponse() {
    *this = ::std::move(from);
  }

  inline JobResponse& operator=(JobResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JobResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JobResponse* internal_default_instance() {
    return reinterpret_cast<const JobResponse*>(
               &_JobResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(JobResponse* other);
  friend void swap(JobResponse& a, JobResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JobResponse* New() const final {
    return CreateMaybeMessage<JobResponse>(NULL);
  }

  JobResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JobResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JobResponse& from);
  void MergeFrom(const JobResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes resp = 2;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  const ::std::string& resp() const;
  void set_resp(const ::std::string& value);
  #if LANG_CXX11
  void set_resp(::std::string&& value);
  #endif
  void set_resp(const char* value);
  void set_resp(const void* value, size_t size);
  ::std::string* mutable_resp();
  ::std::string* release_resp();
  void set_allocated_resp(::std::string* resp);

  // uint64 job_id = 1;
  void clear_job_id();
  static const int kJobIdFieldNumber = 1;
  ::google::protobuf::uint64 job_id() const;
  void set_job_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:protocol.JobResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr resp_;
  ::google::protobuf::uint64 job_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_job_5fservice_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Empty

// -------------------------------------------------------------------

// Name

// string name = 1;
inline void Name::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Name::name() const {
  // @@protoc_insertion_point(field_get:protocol.Name.name)
  return name_.GetNoArena();
}
inline void Name::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Name.name)
}
#if LANG_CXX11
inline void Name::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Name.name)
}
#endif
inline void Name::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Name.name)
}
inline void Name::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Name.name)
}
inline ::std::string* Name::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Name.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Name::release_name() {
  // @@protoc_insertion_point(field_release:protocol.Name.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Name::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:protocol.Name.name)
}

// -------------------------------------------------------------------

// BinaryResource

// string name = 1;
inline void BinaryResource::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BinaryResource::name() const {
  // @@protoc_insertion_point(field_get:protocol.BinaryResource.name)
  return name_.GetNoArena();
}
inline void BinaryResource::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.BinaryResource.name)
}
#if LANG_CXX11
inline void BinaryResource::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.BinaryResource.name)
}
#endif
inline void BinaryResource::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.BinaryResource.name)
}
inline void BinaryResource::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.BinaryResource.name)
}
inline ::std::string* BinaryResource::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:protocol.BinaryResource.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinaryResource::release_name() {
  // @@protoc_insertion_point(field_release:protocol.BinaryResource.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinaryResource::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:protocol.BinaryResource.name)
}

// bytes resource = 2;
inline void BinaryResource::clear_resource() {
  resource_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BinaryResource::resource() const {
  // @@protoc_insertion_point(field_get:protocol.BinaryResource.resource)
  return resource_.GetNoArena();
}
inline void BinaryResource::set_resource(const ::std::string& value) {
  
  resource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.BinaryResource.resource)
}
#if LANG_CXX11
inline void BinaryResource::set_resource(::std::string&& value) {
  
  resource_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.BinaryResource.resource)
}
#endif
inline void BinaryResource::set_resource(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  resource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.BinaryResource.resource)
}
inline void BinaryResource::set_resource(const void* value, size_t size) {
  
  resource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.BinaryResource.resource)
}
inline ::std::string* BinaryResource::mutable_resource() {
  
  // @@protoc_insertion_point(field_mutable:protocol.BinaryResource.resource)
  return resource_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinaryResource::release_resource() {
  // @@protoc_insertion_point(field_release:protocol.BinaryResource.resource)
  
  return resource_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinaryResource::set_allocated_resource(::std::string* resource) {
  if (resource != NULL) {
    
  } else {
    
  }
  resource_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), resource);
  // @@protoc_insertion_point(field_set_allocated:protocol.BinaryResource.resource)
}

// -------------------------------------------------------------------

// ServerList

// repeated uint64 servers = 1;
inline int ServerList::servers_size() const {
  return servers_.size();
}
inline void ServerList::clear_servers() {
  servers_.Clear();
}
inline ::google::protobuf::uint64 ServerList::servers(int index) const {
  // @@protoc_insertion_point(field_get:protocol.ServerList.servers)
  return servers_.Get(index);
}
inline void ServerList::set_servers(int index, ::google::protobuf::uint64 value) {
  servers_.Set(index, value);
  // @@protoc_insertion_point(field_set:protocol.ServerList.servers)
}
inline void ServerList::add_servers(::google::protobuf::uint64 value) {
  servers_.Add(value);
  // @@protoc_insertion_point(field_add:protocol.ServerList.servers)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ServerList::servers() const {
  // @@protoc_insertion_point(field_list:protocol.ServerList.servers)
  return servers_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ServerList::mutable_servers() {
  // @@protoc_insertion_point(field_mutable_list:protocol.ServerList.servers)
  return &servers_;
}

// -------------------------------------------------------------------

// JobConfig

// uint64 job_id = 1;
inline void JobConfig::clear_job_id() {
  job_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 JobConfig::job_id() const {
  // @@protoc_insertion_point(field_get:protocol.JobConfig.job_id)
  return job_id_;
}
inline void JobConfig::set_job_id(::google::protobuf::uint64 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.JobConfig.job_id)
}

// string job_name = 2;
inline void JobConfig::clear_job_name() {
  job_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JobConfig::job_name() const {
  // @@protoc_insertion_point(field_get:protocol.JobConfig.job_name)
  return job_name_.GetNoArena();
}
inline void JobConfig::set_job_name(const ::std::string& value) {
  
  job_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.JobConfig.job_name)
}
#if LANG_CXX11
inline void JobConfig::set_job_name(::std::string&& value) {
  
  job_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.JobConfig.job_name)
}
#endif
inline void JobConfig::set_job_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  job_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.JobConfig.job_name)
}
inline void JobConfig::set_job_name(const char* value, size_t size) {
  
  job_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.JobConfig.job_name)
}
inline ::std::string* JobConfig::mutable_job_name() {
  
  // @@protoc_insertion_point(field_mutable:protocol.JobConfig.job_name)
  return job_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JobConfig::release_job_name() {
  // @@protoc_insertion_point(field_release:protocol.JobConfig.job_name)
  
  return job_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JobConfig::set_allocated_job_name(::std::string* job_name) {
  if (job_name != NULL) {
    
  } else {
    
  }
  job_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), job_name);
  // @@protoc_insertion_point(field_set_allocated:protocol.JobConfig.job_name)
}

// uint32 workers = 3;
inline void JobConfig::clear_workers() {
  workers_ = 0u;
}
inline ::google::protobuf::uint32 JobConfig::workers() const {
  // @@protoc_insertion_point(field_get:protocol.JobConfig.workers)
  return workers_;
}
inline void JobConfig::set_workers(::google::protobuf::uint32 value) {
  
  workers_ = value;
  // @@protoc_insertion_point(field_set:protocol.JobConfig.workers)
}

// uint64 time_limit = 4;
inline void JobConfig::clear_time_limit() {
  time_limit_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 JobConfig::time_limit() const {
  // @@protoc_insertion_point(field_get:protocol.JobConfig.time_limit)
  return time_limit_;
}
inline void JobConfig::set_time_limit(::google::protobuf::uint64 value) {
  
  time_limit_ = value;
  // @@protoc_insertion_point(field_set:protocol.JobConfig.time_limit)
}

// uint32 batch_size = 5;
inline void JobConfig::clear_batch_size() {
  batch_size_ = 0u;
}
inline ::google::protobuf::uint32 JobConfig::batch_size() const {
  // @@protoc_insertion_point(field_get:protocol.JobConfig.batch_size)
  return batch_size_;
}
inline void JobConfig::set_batch_size(::google::protobuf::uint32 value) {
  
  batch_size_ = value;
  // @@protoc_insertion_point(field_set:protocol.JobConfig.batch_size)
}

// uint32 batch_capacity = 6;
inline void JobConfig::clear_batch_capacity() {
  batch_capacity_ = 0u;
}
inline ::google::protobuf::uint32 JobConfig::batch_capacity() const {
  // @@protoc_insertion_point(field_get:protocol.JobConfig.batch_capacity)
  return batch_capacity_;
}
inline void JobConfig::set_batch_capacity(::google::protobuf::uint32 value) {
  
  batch_capacity_ = value;
  // @@protoc_insertion_point(field_set:protocol.JobConfig.batch_capacity)
}

// uint32 memory_limit = 7;
inline void JobConfig::clear_memory_limit() {
  memory_limit_ = 0u;
}
inline ::google::protobuf::uint32 JobConfig::memory_limit() const {
  // @@protoc_insertion_point(field_get:protocol.JobConfig.memory_limit)
  return memory_limit_;
}
inline void JobConfig::set_memory_limit(::google::protobuf::uint32 value) {
  
  memory_limit_ = value;
  // @@protoc_insertion_point(field_set:protocol.JobConfig.memory_limit)
}

// bool trace_enable = 8;
inline void JobConfig::clear_trace_enable() {
  trace_enable_ = false;
}
inline bool JobConfig::trace_enable() const {
  // @@protoc_insertion_point(field_get:protocol.JobConfig.trace_enable)
  return trace_enable_;
}
inline void JobConfig::set_trace_enable(bool value) {
  
  trace_enable_ = value;
  // @@protoc_insertion_point(field_set:protocol.JobConfig.trace_enable)
}

// .protocol.Empty local = 9;
inline bool JobConfig::has_local() const {
  return servers_case() == kLocal;
}
inline void JobConfig::set_has_local() {
  _oneof_case_[0] = kLocal;
}
inline void JobConfig::clear_local() {
  if (has_local()) {
    delete servers_.local_;
    clear_has_servers();
  }
}
inline const ::protocol::Empty& JobConfig::_internal_local() const {
  return *servers_.local_;
}
inline ::protocol::Empty* JobConfig::release_local() {
  // @@protoc_insertion_point(field_release:protocol.JobConfig.local)
  if (has_local()) {
    clear_has_servers();
      ::protocol::Empty* temp = servers_.local_;
    servers_.local_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::protocol::Empty& JobConfig::local() const {
  // @@protoc_insertion_point(field_get:protocol.JobConfig.local)
  return has_local()
      ? *servers_.local_
      : *reinterpret_cast< ::protocol::Empty*>(&::protocol::_Empty_default_instance_);
}
inline ::protocol::Empty* JobConfig::mutable_local() {
  if (!has_local()) {
    clear_servers();
    set_has_local();
    servers_.local_ = CreateMaybeMessage< ::protocol::Empty >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:protocol.JobConfig.local)
  return servers_.local_;
}

// .protocol.ServerList part = 10;
inline bool JobConfig::has_part() const {
  return servers_case() == kPart;
}
inline void JobConfig::set_has_part() {
  _oneof_case_[0] = kPart;
}
inline void JobConfig::clear_part() {
  if (has_part()) {
    delete servers_.part_;
    clear_has_servers();
  }
}
inline const ::protocol::ServerList& JobConfig::_internal_part() const {
  return *servers_.part_;
}
inline ::protocol::ServerList* JobConfig::release_part() {
  // @@protoc_insertion_point(field_release:protocol.JobConfig.part)
  if (has_part()) {
    clear_has_servers();
      ::protocol::ServerList* temp = servers_.part_;
    servers_.part_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::protocol::ServerList& JobConfig::part() const {
  // @@protoc_insertion_point(field_get:protocol.JobConfig.part)
  return has_part()
      ? *servers_.part_
      : *reinterpret_cast< ::protocol::ServerList*>(&::protocol::_ServerList_default_instance_);
}
inline ::protocol::ServerList* JobConfig::mutable_part() {
  if (!has_part()) {
    clear_servers();
    set_has_part();
    servers_.part_ = CreateMaybeMessage< ::protocol::ServerList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:protocol.JobConfig.part)
  return servers_.part_;
}

// .protocol.Empty all = 11;
inline bool JobConfig::has_all() const {
  return servers_case() == kAll;
}
inline void JobConfig::set_has_all() {
  _oneof_case_[0] = kAll;
}
inline void JobConfig::clear_all() {
  if (has_all()) {
    delete servers_.all_;
    clear_has_servers();
  }
}
inline const ::protocol::Empty& JobConfig::_internal_all() const {
  return *servers_.all_;
}
inline ::protocol::Empty* JobConfig::release_all() {
  // @@protoc_insertion_point(field_release:protocol.JobConfig.all)
  if (has_all()) {
    clear_has_servers();
      ::protocol::Empty* temp = servers_.all_;
    servers_.all_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::protocol::Empty& JobConfig::all() const {
  // @@protoc_insertion_point(field_get:protocol.JobConfig.all)
  return has_all()
      ? *servers_.all_
      : *reinterpret_cast< ::protocol::Empty*>(&::protocol::_Empty_default_instance_);
}
inline ::protocol::Empty* JobConfig::mutable_all() {
  if (!has_all()) {
    clear_servers();
    set_has_all();
    servers_.all_ = CreateMaybeMessage< ::protocol::Empty >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:protocol.JobConfig.all)
  return servers_.all_;
}

inline bool JobConfig::has_servers() const {
  return servers_case() != SERVERS_NOT_SET;
}
inline void JobConfig::clear_has_servers() {
  _oneof_case_[0] = SERVERS_NOT_SET;
}
inline JobConfig::ServersCase JobConfig::servers_case() const {
  return JobConfig::ServersCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// JobRequest

// .protocol.JobConfig conf = 1;
inline bool JobRequest::has_conf() const {
  return this != internal_default_instance() && conf_ != NULL;
}
inline void JobRequest::clear_conf() {
  if (GetArenaNoVirtual() == NULL && conf_ != NULL) {
    delete conf_;
  }
  conf_ = NULL;
}
inline const ::protocol::JobConfig& JobRequest::_internal_conf() const {
  return *conf_;
}
inline const ::protocol::JobConfig& JobRequest::conf() const {
  const ::protocol::JobConfig* p = conf_;
  // @@protoc_insertion_point(field_get:protocol.JobRequest.conf)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::JobConfig*>(
      &::protocol::_JobConfig_default_instance_);
}
inline ::protocol::JobConfig* JobRequest::release_conf() {
  // @@protoc_insertion_point(field_release:protocol.JobRequest.conf)
  
  ::protocol::JobConfig* temp = conf_;
  conf_ = NULL;
  return temp;
}
inline ::protocol::JobConfig* JobRequest::mutable_conf() {
  
  if (conf_ == NULL) {
    auto* p = CreateMaybeMessage<::protocol::JobConfig>(GetArenaNoVirtual());
    conf_ = p;
  }
  // @@protoc_insertion_point(field_mutable:protocol.JobRequest.conf)
  return conf_;
}
inline void JobRequest::set_allocated_conf(::protocol::JobConfig* conf) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete conf_;
  }
  if (conf) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      conf = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, conf, submessage_arena);
    }
    
  } else {
    
  }
  conf_ = conf;
  // @@protoc_insertion_point(field_set_allocated:protocol.JobRequest.conf)
}

// bytes source = 2;
inline void JobRequest::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JobRequest::source() const {
  // @@protoc_insertion_point(field_get:protocol.JobRequest.source)
  return source_.GetNoArena();
}
inline void JobRequest::set_source(const ::std::string& value) {
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.JobRequest.source)
}
#if LANG_CXX11
inline void JobRequest::set_source(::std::string&& value) {
  
  source_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.JobRequest.source)
}
#endif
inline void JobRequest::set_source(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.JobRequest.source)
}
inline void JobRequest::set_source(const void* value, size_t size) {
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.JobRequest.source)
}
inline ::std::string* JobRequest::mutable_source() {
  
  // @@protoc_insertion_point(field_mutable:protocol.JobRequest.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JobRequest::release_source() {
  // @@protoc_insertion_point(field_release:protocol.JobRequest.source)
  
  return source_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JobRequest::set_allocated_source(::std::string* source) {
  if (source != NULL) {
    
  } else {
    
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:protocol.JobRequest.source)
}

// bytes plan = 3;
inline void JobRequest::clear_plan() {
  plan_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JobRequest::plan() const {
  // @@protoc_insertion_point(field_get:protocol.JobRequest.plan)
  return plan_.GetNoArena();
}
inline void JobRequest::set_plan(const ::std::string& value) {
  
  plan_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.JobRequest.plan)
}
#if LANG_CXX11
inline void JobRequest::set_plan(::std::string&& value) {
  
  plan_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.JobRequest.plan)
}
#endif
inline void JobRequest::set_plan(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  plan_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.JobRequest.plan)
}
inline void JobRequest::set_plan(const void* value, size_t size) {
  
  plan_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.JobRequest.plan)
}
inline ::std::string* JobRequest::mutable_plan() {
  
  // @@protoc_insertion_point(field_mutable:protocol.JobRequest.plan)
  return plan_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JobRequest::release_plan() {
  // @@protoc_insertion_point(field_release:protocol.JobRequest.plan)
  
  return plan_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JobRequest::set_allocated_plan(::std::string* plan) {
  if (plan != NULL) {
    
  } else {
    
  }
  plan_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), plan);
  // @@protoc_insertion_point(field_set_allocated:protocol.JobRequest.plan)
}

// bytes resource = 4;
inline void JobRequest::clear_resource() {
  resource_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JobRequest::resource() const {
  // @@protoc_insertion_point(field_get:protocol.JobRequest.resource)
  return resource_.GetNoArena();
}
inline void JobRequest::set_resource(const ::std::string& value) {
  
  resource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.JobRequest.resource)
}
#if LANG_CXX11
inline void JobRequest::set_resource(::std::string&& value) {
  
  resource_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.JobRequest.resource)
}
#endif
inline void JobRequest::set_resource(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  resource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.JobRequest.resource)
}
inline void JobRequest::set_resource(const void* value, size_t size) {
  
  resource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.JobRequest.resource)
}
inline ::std::string* JobRequest::mutable_resource() {
  
  // @@protoc_insertion_point(field_mutable:protocol.JobRequest.resource)
  return resource_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JobRequest::release_resource() {
  // @@protoc_insertion_point(field_release:protocol.JobRequest.resource)
  
  return resource_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JobRequest::set_allocated_resource(::std::string* resource) {
  if (resource != NULL) {
    
  } else {
    
  }
  resource_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), resource);
  // @@protoc_insertion_point(field_set_allocated:protocol.JobRequest.resource)
}

// -------------------------------------------------------------------

// JobResponse

// uint64 job_id = 1;
inline void JobResponse::clear_job_id() {
  job_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 JobResponse::job_id() const {
  // @@protoc_insertion_point(field_get:protocol.JobResponse.job_id)
  return job_id_;
}
inline void JobResponse::set_job_id(::google::protobuf::uint64 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.JobResponse.job_id)
}

// bytes resp = 2;
inline void JobResponse::clear_resp() {
  resp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JobResponse::resp() const {
  // @@protoc_insertion_point(field_get:protocol.JobResponse.resp)
  return resp_.GetNoArena();
}
inline void JobResponse::set_resp(const ::std::string& value) {
  
  resp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.JobResponse.resp)
}
#if LANG_CXX11
inline void JobResponse::set_resp(::std::string&& value) {
  
  resp_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.JobResponse.resp)
}
#endif
inline void JobResponse::set_resp(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  resp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.JobResponse.resp)
}
inline void JobResponse::set_resp(const void* value, size_t size) {
  
  resp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.JobResponse.resp)
}
inline ::std::string* JobResponse::mutable_resp() {
  
  // @@protoc_insertion_point(field_mutable:protocol.JobResponse.resp)
  return resp_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JobResponse::release_resp() {
  // @@protoc_insertion_point(field_release:protocol.JobResponse.resp)
  
  return resp_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JobResponse::set_allocated_resp(::std::string* resp) {
  if (resp != NULL) {
    
  } else {
    
  }
  resp_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), resp);
  // @@protoc_insertion_point(field_set_allocated:protocol.JobResponse.resp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_job_5fservice_2eproto
