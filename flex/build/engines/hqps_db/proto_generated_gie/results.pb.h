// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: results.proto

#ifndef PROTOBUF_INCLUDED_results_2eproto
#define PROTOBUF_INCLUDED_results_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "expr.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_results_2eproto 

namespace protobuf_results_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_results_2eproto
namespace results {
class Collection;
class CollectionDefaultTypeInternal;
extern CollectionDefaultTypeInternal _Collection_default_instance_;
class CollectiveResults;
class CollectiveResultsDefaultTypeInternal;
extern CollectiveResultsDefaultTypeInternal _CollectiveResults_default_instance_;
class Column;
class ColumnDefaultTypeInternal;
extern ColumnDefaultTypeInternal _Column_default_instance_;
class Edge;
class EdgeDefaultTypeInternal;
extern EdgeDefaultTypeInternal _Edge_default_instance_;
class Element;
class ElementDefaultTypeInternal;
extern ElementDefaultTypeInternal _Element_default_instance_;
class Entry;
class EntryDefaultTypeInternal;
extern EntryDefaultTypeInternal _Entry_default_instance_;
class GraphPath;
class GraphPathDefaultTypeInternal;
extern GraphPathDefaultTypeInternal _GraphPath_default_instance_;
class GraphPath_VertexOrEdge;
class GraphPath_VertexOrEdgeDefaultTypeInternal;
extern GraphPath_VertexOrEdgeDefaultTypeInternal _GraphPath_VertexOrEdge_default_instance_;
class Property;
class PropertyDefaultTypeInternal;
extern PropertyDefaultTypeInternal _Property_default_instance_;
class Record;
class RecordDefaultTypeInternal;
extern RecordDefaultTypeInternal _Record_default_instance_;
class Results;
class ResultsDefaultTypeInternal;
extern ResultsDefaultTypeInternal _Results_default_instance_;
class Vertex;
class VertexDefaultTypeInternal;
extern VertexDefaultTypeInternal _Vertex_default_instance_;
}  // namespace results
namespace google {
namespace protobuf {
template<> ::results::Collection* Arena::CreateMaybeMessage<::results::Collection>(Arena*);
template<> ::results::CollectiveResults* Arena::CreateMaybeMessage<::results::CollectiveResults>(Arena*);
template<> ::results::Column* Arena::CreateMaybeMessage<::results::Column>(Arena*);
template<> ::results::Edge* Arena::CreateMaybeMessage<::results::Edge>(Arena*);
template<> ::results::Element* Arena::CreateMaybeMessage<::results::Element>(Arena*);
template<> ::results::Entry* Arena::CreateMaybeMessage<::results::Entry>(Arena*);
template<> ::results::GraphPath* Arena::CreateMaybeMessage<::results::GraphPath>(Arena*);
template<> ::results::GraphPath_VertexOrEdge* Arena::CreateMaybeMessage<::results::GraphPath_VertexOrEdge>(Arena*);
template<> ::results::Property* Arena::CreateMaybeMessage<::results::Property>(Arena*);
template<> ::results::Record* Arena::CreateMaybeMessage<::results::Record>(Arena*);
template<> ::results::Results* Arena::CreateMaybeMessage<::results::Results>(Arena*);
template<> ::results::Vertex* Arena::CreateMaybeMessage<::results::Vertex>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace results {

// ===================================================================

class Property : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:results.Property) */ {
 public:
  Property();
  virtual ~Property();

  Property(const Property& from);

  inline Property& operator=(const Property& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Property(Property&& from) noexcept
    : Property() {
    *this = ::std::move(from);
  }

  inline Property& operator=(Property&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Property& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Property* internal_default_instance() {
    return reinterpret_cast<const Property*>(
               &_Property_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Property* other);
  friend void swap(Property& a, Property& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Property* New() const final {
    return CreateMaybeMessage<Property>(NULL);
  }

  Property* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Property>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Property& from);
  void MergeFrom(const Property& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Property* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.NameOrId key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  private:
  const ::common::NameOrId& _internal_key() const;
  public:
  const ::common::NameOrId& key() const;
  ::common::NameOrId* release_key();
  ::common::NameOrId* mutable_key();
  void set_allocated_key(::common::NameOrId* key);

  // .common.Value value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::common::Value& _internal_value() const;
  public:
  const ::common::Value& value() const;
  ::common::Value* release_value();
  ::common::Value* mutable_value();
  void set_allocated_value(::common::Value* value);

  // @@protoc_insertion_point(class_scope:results.Property)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::NameOrId* key_;
  ::common::Value* value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_results_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vertex : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:results.Vertex) */ {
 public:
  Vertex();
  virtual ~Vertex();

  Vertex(const Vertex& from);

  inline Vertex& operator=(const Vertex& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vertex(Vertex&& from) noexcept
    : Vertex() {
    *this = ::std::move(from);
  }

  inline Vertex& operator=(Vertex&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vertex& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vertex* internal_default_instance() {
    return reinterpret_cast<const Vertex*>(
               &_Vertex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Vertex* other);
  friend void swap(Vertex& a, Vertex& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vertex* New() const final {
    return CreateMaybeMessage<Vertex>(NULL);
  }

  Vertex* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vertex>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vertex& from);
  void MergeFrom(const Vertex& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vertex* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .results.Property properties = 3;
  int properties_size() const;
  void clear_properties();
  static const int kPropertiesFieldNumber = 3;
  ::results::Property* mutable_properties(int index);
  ::google::protobuf::RepeatedPtrField< ::results::Property >*
      mutable_properties();
  const ::results::Property& properties(int index) const;
  ::results::Property* add_properties();
  const ::google::protobuf::RepeatedPtrField< ::results::Property >&
      properties() const;

  // .common.NameOrId label = 2;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 2;
  private:
  const ::common::NameOrId& _internal_label() const;
  public:
  const ::common::NameOrId& label() const;
  ::common::NameOrId* release_label();
  ::common::NameOrId* mutable_label();
  void set_allocated_label(::common::NameOrId* label);

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:results.Vertex)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::results::Property > properties_;
  ::common::NameOrId* label_;
  ::google::protobuf::int64 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_results_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Edge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:results.Edge) */ {
 public:
  Edge();
  virtual ~Edge();

  Edge(const Edge& from);

  inline Edge& operator=(const Edge& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Edge(Edge&& from) noexcept
    : Edge() {
    *this = ::std::move(from);
  }

  inline Edge& operator=(Edge&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Edge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Edge* internal_default_instance() {
    return reinterpret_cast<const Edge*>(
               &_Edge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Edge* other);
  friend void swap(Edge& a, Edge& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Edge* New() const final {
    return CreateMaybeMessage<Edge>(NULL);
  }

  Edge* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Edge>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Edge& from);
  void MergeFrom(const Edge& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Edge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .results.Property properties = 7;
  int properties_size() const;
  void clear_properties();
  static const int kPropertiesFieldNumber = 7;
  ::results::Property* mutable_properties(int index);
  ::google::protobuf::RepeatedPtrField< ::results::Property >*
      mutable_properties();
  const ::results::Property& properties(int index) const;
  ::results::Property* add_properties();
  const ::google::protobuf::RepeatedPtrField< ::results::Property >&
      properties() const;

  // .common.NameOrId label = 2;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 2;
  private:
  const ::common::NameOrId& _internal_label() const;
  public:
  const ::common::NameOrId& label() const;
  ::common::NameOrId* release_label();
  ::common::NameOrId* mutable_label();
  void set_allocated_label(::common::NameOrId* label);

  // .common.NameOrId src_label = 4;
  bool has_src_label() const;
  void clear_src_label();
  static const int kSrcLabelFieldNumber = 4;
  private:
  const ::common::NameOrId& _internal_src_label() const;
  public:
  const ::common::NameOrId& src_label() const;
  ::common::NameOrId* release_src_label();
  ::common::NameOrId* mutable_src_label();
  void set_allocated_src_label(::common::NameOrId* src_label);

  // .common.NameOrId dst_label = 6;
  bool has_dst_label() const;
  void clear_dst_label();
  static const int kDstLabelFieldNumber = 6;
  private:
  const ::common::NameOrId& _internal_dst_label() const;
  public:
  const ::common::NameOrId& dst_label() const;
  ::common::NameOrId* release_dst_label();
  ::common::NameOrId* mutable_dst_label();
  void set_allocated_dst_label(::common::NameOrId* dst_label);

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // int64 src_id = 3;
  void clear_src_id();
  static const int kSrcIdFieldNumber = 3;
  ::google::protobuf::int64 src_id() const;
  void set_src_id(::google::protobuf::int64 value);

  // int64 dst_id = 5;
  void clear_dst_id();
  static const int kDstIdFieldNumber = 5;
  ::google::protobuf::int64 dst_id() const;
  void set_dst_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:results.Edge)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::results::Property > properties_;
  ::common::NameOrId* label_;
  ::common::NameOrId* src_label_;
  ::common::NameOrId* dst_label_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 src_id_;
  ::google::protobuf::int64 dst_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_results_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GraphPath_VertexOrEdge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:results.GraphPath.VertexOrEdge) */ {
 public:
  GraphPath_VertexOrEdge();
  virtual ~GraphPath_VertexOrEdge();

  GraphPath_VertexOrEdge(const GraphPath_VertexOrEdge& from);

  inline GraphPath_VertexOrEdge& operator=(const GraphPath_VertexOrEdge& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GraphPath_VertexOrEdge(GraphPath_VertexOrEdge&& from) noexcept
    : GraphPath_VertexOrEdge() {
    *this = ::std::move(from);
  }

  inline GraphPath_VertexOrEdge& operator=(GraphPath_VertexOrEdge&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GraphPath_VertexOrEdge& default_instance();

  enum InnerCase {
    kVertex = 1,
    kEdge = 2,
    INNER_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GraphPath_VertexOrEdge* internal_default_instance() {
    return reinterpret_cast<const GraphPath_VertexOrEdge*>(
               &_GraphPath_VertexOrEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GraphPath_VertexOrEdge* other);
  friend void swap(GraphPath_VertexOrEdge& a, GraphPath_VertexOrEdge& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GraphPath_VertexOrEdge* New() const final {
    return CreateMaybeMessage<GraphPath_VertexOrEdge>(NULL);
  }

  GraphPath_VertexOrEdge* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GraphPath_VertexOrEdge>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GraphPath_VertexOrEdge& from);
  void MergeFrom(const GraphPath_VertexOrEdge& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphPath_VertexOrEdge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .results.Vertex vertex = 1;
  bool has_vertex() const;
  void clear_vertex();
  static const int kVertexFieldNumber = 1;
  private:
  const ::results::Vertex& _internal_vertex() const;
  public:
  const ::results::Vertex& vertex() const;
  ::results::Vertex* release_vertex();
  ::results::Vertex* mutable_vertex();
  void set_allocated_vertex(::results::Vertex* vertex);

  // .results.Edge edge = 2;
  bool has_edge() const;
  void clear_edge();
  static const int kEdgeFieldNumber = 2;
  private:
  const ::results::Edge& _internal_edge() const;
  public:
  const ::results::Edge& edge() const;
  ::results::Edge* release_edge();
  ::results::Edge* mutable_edge();
  void set_allocated_edge(::results::Edge* edge);

  void clear_inner();
  InnerCase inner_case() const;
  // @@protoc_insertion_point(class_scope:results.GraphPath.VertexOrEdge)
 private:
  void set_has_vertex();
  void set_has_edge();

  inline bool has_inner() const;
  inline void clear_has_inner();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union InnerUnion {
    InnerUnion() {}
    ::results::Vertex* vertex_;
    ::results::Edge* edge_;
  } inner_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_results_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GraphPath : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:results.GraphPath) */ {
 public:
  GraphPath();
  virtual ~GraphPath();

  GraphPath(const GraphPath& from);

  inline GraphPath& operator=(const GraphPath& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GraphPath(GraphPath&& from) noexcept
    : GraphPath() {
    *this = ::std::move(from);
  }

  inline GraphPath& operator=(GraphPath&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GraphPath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GraphPath* internal_default_instance() {
    return reinterpret_cast<const GraphPath*>(
               &_GraphPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(GraphPath* other);
  friend void swap(GraphPath& a, GraphPath& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GraphPath* New() const final {
    return CreateMaybeMessage<GraphPath>(NULL);
  }

  GraphPath* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GraphPath>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GraphPath& from);
  void MergeFrom(const GraphPath& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphPath* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GraphPath_VertexOrEdge VertexOrEdge;

  // accessors -------------------------------------------------------

  // repeated .results.GraphPath.VertexOrEdge path = 1;
  int path_size() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  ::results::GraphPath_VertexOrEdge* mutable_path(int index);
  ::google::protobuf::RepeatedPtrField< ::results::GraphPath_VertexOrEdge >*
      mutable_path();
  const ::results::GraphPath_VertexOrEdge& path(int index) const;
  ::results::GraphPath_VertexOrEdge* add_path();
  const ::google::protobuf::RepeatedPtrField< ::results::GraphPath_VertexOrEdge >&
      path() const;

  // @@protoc_insertion_point(class_scope:results.GraphPath)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::results::GraphPath_VertexOrEdge > path_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_results_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Element : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:results.Element) */ {
 public:
  Element();
  virtual ~Element();

  Element(const Element& from);

  inline Element& operator=(const Element& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Element(Element&& from) noexcept
    : Element() {
    *this = ::std::move(from);
  }

  inline Element& operator=(Element&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Element& default_instance();

  enum InnerCase {
    kVertex = 1,
    kEdge = 2,
    kGraphPath = 3,
    kObject = 4,
    INNER_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Element* internal_default_instance() {
    return reinterpret_cast<const Element*>(
               &_Element_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Element* other);
  friend void swap(Element& a, Element& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Element* New() const final {
    return CreateMaybeMessage<Element>(NULL);
  }

  Element* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Element>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Element& from);
  void MergeFrom(const Element& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Element* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .results.Vertex vertex = 1;
  bool has_vertex() const;
  void clear_vertex();
  static const int kVertexFieldNumber = 1;
  private:
  const ::results::Vertex& _internal_vertex() const;
  public:
  const ::results::Vertex& vertex() const;
  ::results::Vertex* release_vertex();
  ::results::Vertex* mutable_vertex();
  void set_allocated_vertex(::results::Vertex* vertex);

  // .results.Edge edge = 2;
  bool has_edge() const;
  void clear_edge();
  static const int kEdgeFieldNumber = 2;
  private:
  const ::results::Edge& _internal_edge() const;
  public:
  const ::results::Edge& edge() const;
  ::results::Edge* release_edge();
  ::results::Edge* mutable_edge();
  void set_allocated_edge(::results::Edge* edge);

  // .results.GraphPath graph_path = 3;
  bool has_graph_path() const;
  void clear_graph_path();
  static const int kGraphPathFieldNumber = 3;
  private:
  const ::results::GraphPath& _internal_graph_path() const;
  public:
  const ::results::GraphPath& graph_path() const;
  ::results::GraphPath* release_graph_path();
  ::results::GraphPath* mutable_graph_path();
  void set_allocated_graph_path(::results::GraphPath* graph_path);

  // .common.Value object = 4;
  bool has_object() const;
  void clear_object();
  static const int kObjectFieldNumber = 4;
  private:
  const ::common::Value& _internal_object() const;
  public:
  const ::common::Value& object() const;
  ::common::Value* release_object();
  ::common::Value* mutable_object();
  void set_allocated_object(::common::Value* object);

  void clear_inner();
  InnerCase inner_case() const;
  // @@protoc_insertion_point(class_scope:results.Element)
 private:
  void set_has_vertex();
  void set_has_edge();
  void set_has_graph_path();
  void set_has_object();

  inline bool has_inner() const;
  inline void clear_has_inner();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union InnerUnion {
    InnerUnion() {}
    ::results::Vertex* vertex_;
    ::results::Edge* edge_;
    ::results::GraphPath* graph_path_;
    ::common::Value* object_;
  } inner_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_results_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Collection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:results.Collection) */ {
 public:
  Collection();
  virtual ~Collection();

  Collection(const Collection& from);

  inline Collection& operator=(const Collection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Collection(Collection&& from) noexcept
    : Collection() {
    *this = ::std::move(from);
  }

  inline Collection& operator=(Collection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Collection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Collection* internal_default_instance() {
    return reinterpret_cast<const Collection*>(
               &_Collection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Collection* other);
  friend void swap(Collection& a, Collection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Collection* New() const final {
    return CreateMaybeMessage<Collection>(NULL);
  }

  Collection* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Collection>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Collection& from);
  void MergeFrom(const Collection& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Collection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .results.Element collection = 1;
  int collection_size() const;
  void clear_collection();
  static const int kCollectionFieldNumber = 1;
  ::results::Element* mutable_collection(int index);
  ::google::protobuf::RepeatedPtrField< ::results::Element >*
      mutable_collection();
  const ::results::Element& collection(int index) const;
  ::results::Element* add_collection();
  const ::google::protobuf::RepeatedPtrField< ::results::Element >&
      collection() const;

  // @@protoc_insertion_point(class_scope:results.Collection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::results::Element > collection_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_results_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Entry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:results.Entry) */ {
 public:
  Entry();
  virtual ~Entry();

  Entry(const Entry& from);

  inline Entry& operator=(const Entry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Entry(Entry&& from) noexcept
    : Entry() {
    *this = ::std::move(from);
  }

  inline Entry& operator=(Entry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Entry& default_instance();

  enum InnerCase {
    kElement = 1,
    kCollection = 2,
    INNER_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Entry* internal_default_instance() {
    return reinterpret_cast<const Entry*>(
               &_Entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Entry* other);
  friend void swap(Entry& a, Entry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Entry* New() const final {
    return CreateMaybeMessage<Entry>(NULL);
  }

  Entry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Entry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Entry& from);
  void MergeFrom(const Entry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Entry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .results.Element element = 1;
  bool has_element() const;
  void clear_element();
  static const int kElementFieldNumber = 1;
  private:
  const ::results::Element& _internal_element() const;
  public:
  const ::results::Element& element() const;
  ::results::Element* release_element();
  ::results::Element* mutable_element();
  void set_allocated_element(::results::Element* element);

  // .results.Collection collection = 2;
  bool has_collection() const;
  void clear_collection();
  static const int kCollectionFieldNumber = 2;
  private:
  const ::results::Collection& _internal_collection() const;
  public:
  const ::results::Collection& collection() const;
  ::results::Collection* release_collection();
  ::results::Collection* mutable_collection();
  void set_allocated_collection(::results::Collection* collection);

  void clear_inner();
  InnerCase inner_case() const;
  // @@protoc_insertion_point(class_scope:results.Entry)
 private:
  void set_has_element();
  void set_has_collection();

  inline bool has_inner() const;
  inline void clear_has_inner();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union InnerUnion {
    InnerUnion() {}
    ::results::Element* element_;
    ::results::Collection* collection_;
  } inner_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_results_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Column : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:results.Column) */ {
 public:
  Column();
  virtual ~Column();

  Column(const Column& from);

  inline Column& operator=(const Column& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Column(Column&& from) noexcept
    : Column() {
    *this = ::std::move(from);
  }

  inline Column& operator=(Column&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Column& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Column* internal_default_instance() {
    return reinterpret_cast<const Column*>(
               &_Column_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Column* other);
  friend void swap(Column& a, Column& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Column* New() const final {
    return CreateMaybeMessage<Column>(NULL);
  }

  Column* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Column>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Column& from);
  void MergeFrom(const Column& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Column* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.NameOrId name_or_id = 1;
  bool has_name_or_id() const;
  void clear_name_or_id();
  static const int kNameOrIdFieldNumber = 1;
  private:
  const ::common::NameOrId& _internal_name_or_id() const;
  public:
  const ::common::NameOrId& name_or_id() const;
  ::common::NameOrId* release_name_or_id();
  ::common::NameOrId* mutable_name_or_id();
  void set_allocated_name_or_id(::common::NameOrId* name_or_id);

  // .results.Entry entry = 2;
  bool has_entry() const;
  void clear_entry();
  static const int kEntryFieldNumber = 2;
  private:
  const ::results::Entry& _internal_entry() const;
  public:
  const ::results::Entry& entry() const;
  ::results::Entry* release_entry();
  ::results::Entry* mutable_entry();
  void set_allocated_entry(::results::Entry* entry);

  // @@protoc_insertion_point(class_scope:results.Column)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::NameOrId* name_or_id_;
  ::results::Entry* entry_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_results_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Record : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:results.Record) */ {
 public:
  Record();
  virtual ~Record();

  Record(const Record& from);

  inline Record& operator=(const Record& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Record(Record&& from) noexcept
    : Record() {
    *this = ::std::move(from);
  }

  inline Record& operator=(Record&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Record& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Record* internal_default_instance() {
    return reinterpret_cast<const Record*>(
               &_Record_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Record* other);
  friend void swap(Record& a, Record& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Record* New() const final {
    return CreateMaybeMessage<Record>(NULL);
  }

  Record* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Record>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Record& from);
  void MergeFrom(const Record& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Record* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .results.Column columns = 1;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 1;
  ::results::Column* mutable_columns(int index);
  ::google::protobuf::RepeatedPtrField< ::results::Column >*
      mutable_columns();
  const ::results::Column& columns(int index) const;
  ::results::Column* add_columns();
  const ::google::protobuf::RepeatedPtrField< ::results::Column >&
      columns() const;

  // @@protoc_insertion_point(class_scope:results.Record)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::results::Column > columns_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_results_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Results : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:results.Results) */ {
 public:
  Results();
  virtual ~Results();

  Results(const Results& from);

  inline Results& operator=(const Results& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Results(Results&& from) noexcept
    : Results() {
    *this = ::std::move(from);
  }

  inline Results& operator=(Results&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Results& default_instance();

  enum InnerCase {
    kRecord = 1,
    INNER_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Results* internal_default_instance() {
    return reinterpret_cast<const Results*>(
               &_Results_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Results* other);
  friend void swap(Results& a, Results& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Results* New() const final {
    return CreateMaybeMessage<Results>(NULL);
  }

  Results* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Results>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Results& from);
  void MergeFrom(const Results& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Results* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .results.Record record = 1;
  bool has_record() const;
  void clear_record();
  static const int kRecordFieldNumber = 1;
  private:
  const ::results::Record& _internal_record() const;
  public:
  const ::results::Record& record() const;
  ::results::Record* release_record();
  ::results::Record* mutable_record();
  void set_allocated_record(::results::Record* record);

  void clear_inner();
  InnerCase inner_case() const;
  // @@protoc_insertion_point(class_scope:results.Results)
 private:
  void set_has_record();

  inline bool has_inner() const;
  inline void clear_has_inner();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union InnerUnion {
    InnerUnion() {}
    ::results::Record* record_;
  } inner_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_results_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CollectiveResults : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:results.CollectiveResults) */ {
 public:
  CollectiveResults();
  virtual ~CollectiveResults();

  CollectiveResults(const CollectiveResults& from);

  inline CollectiveResults& operator=(const CollectiveResults& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CollectiveResults(CollectiveResults&& from) noexcept
    : CollectiveResults() {
    *this = ::std::move(from);
  }

  inline CollectiveResults& operator=(CollectiveResults&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CollectiveResults& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CollectiveResults* internal_default_instance() {
    return reinterpret_cast<const CollectiveResults*>(
               &_CollectiveResults_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(CollectiveResults* other);
  friend void swap(CollectiveResults& a, CollectiveResults& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CollectiveResults* New() const final {
    return CreateMaybeMessage<CollectiveResults>(NULL);
  }

  CollectiveResults* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CollectiveResults>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CollectiveResults& from);
  void MergeFrom(const CollectiveResults& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CollectiveResults* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .results.Results results = 1;
  int results_size() const;
  void clear_results();
  static const int kResultsFieldNumber = 1;
  ::results::Results* mutable_results(int index);
  ::google::protobuf::RepeatedPtrField< ::results::Results >*
      mutable_results();
  const ::results::Results& results(int index) const;
  ::results::Results* add_results();
  const ::google::protobuf::RepeatedPtrField< ::results::Results >&
      results() const;

  // @@protoc_insertion_point(class_scope:results.CollectiveResults)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::results::Results > results_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_results_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Property

// .common.NameOrId key = 1;
inline bool Property::has_key() const {
  return this != internal_default_instance() && key_ != NULL;
}
inline const ::common::NameOrId& Property::_internal_key() const {
  return *key_;
}
inline const ::common::NameOrId& Property::key() const {
  const ::common::NameOrId* p = key_;
  // @@protoc_insertion_point(field_get:results.Property.key)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* Property::release_key() {
  // @@protoc_insertion_point(field_release:results.Property.key)
  
  ::common::NameOrId* temp = key_;
  key_ = NULL;
  return temp;
}
inline ::common::NameOrId* Property::mutable_key() {
  
  if (key_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:results.Property.key)
  return key_;
}
inline void Property::set_allocated_key(::common::NameOrId* key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(key_);
  }
  if (key) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:results.Property.key)
}

// .common.Value value = 2;
inline bool Property::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline const ::common::Value& Property::_internal_value() const {
  return *value_;
}
inline const ::common::Value& Property::value() const {
  const ::common::Value* p = value_;
  // @@protoc_insertion_point(field_get:results.Property.value)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Value*>(
      &::common::_Value_default_instance_);
}
inline ::common::Value* Property::release_value() {
  // @@protoc_insertion_point(field_release:results.Property.value)
  
  ::common::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::common::Value* Property::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Value>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:results.Property.value)
  return value_;
}
inline void Property::set_allocated_value(::common::Value* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:results.Property.value)
}

// -------------------------------------------------------------------

// Vertex

// int64 id = 1;
inline void Vertex::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Vertex::id() const {
  // @@protoc_insertion_point(field_get:results.Vertex.id)
  return id_;
}
inline void Vertex::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:results.Vertex.id)
}

// .common.NameOrId label = 2;
inline bool Vertex::has_label() const {
  return this != internal_default_instance() && label_ != NULL;
}
inline const ::common::NameOrId& Vertex::_internal_label() const {
  return *label_;
}
inline const ::common::NameOrId& Vertex::label() const {
  const ::common::NameOrId* p = label_;
  // @@protoc_insertion_point(field_get:results.Vertex.label)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* Vertex::release_label() {
  // @@protoc_insertion_point(field_release:results.Vertex.label)
  
  ::common::NameOrId* temp = label_;
  label_ = NULL;
  return temp;
}
inline ::common::NameOrId* Vertex::mutable_label() {
  
  if (label_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    label_ = p;
  }
  // @@protoc_insertion_point(field_mutable:results.Vertex.label)
  return label_;
}
inline void Vertex::set_allocated_label(::common::NameOrId* label) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(label_);
  }
  if (label) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      label = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, label, submessage_arena);
    }
    
  } else {
    
  }
  label_ = label;
  // @@protoc_insertion_point(field_set_allocated:results.Vertex.label)
}

// repeated .results.Property properties = 3;
inline int Vertex::properties_size() const {
  return properties_.size();
}
inline void Vertex::clear_properties() {
  properties_.Clear();
}
inline ::results::Property* Vertex::mutable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:results.Vertex.properties)
  return properties_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::results::Property >*
Vertex::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_list:results.Vertex.properties)
  return &properties_;
}
inline const ::results::Property& Vertex::properties(int index) const {
  // @@protoc_insertion_point(field_get:results.Vertex.properties)
  return properties_.Get(index);
}
inline ::results::Property* Vertex::add_properties() {
  // @@protoc_insertion_point(field_add:results.Vertex.properties)
  return properties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::results::Property >&
Vertex::properties() const {
  // @@protoc_insertion_point(field_list:results.Vertex.properties)
  return properties_;
}

// -------------------------------------------------------------------

// Edge

// int64 id = 1;
inline void Edge::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Edge::id() const {
  // @@protoc_insertion_point(field_get:results.Edge.id)
  return id_;
}
inline void Edge::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:results.Edge.id)
}

// .common.NameOrId label = 2;
inline bool Edge::has_label() const {
  return this != internal_default_instance() && label_ != NULL;
}
inline const ::common::NameOrId& Edge::_internal_label() const {
  return *label_;
}
inline const ::common::NameOrId& Edge::label() const {
  const ::common::NameOrId* p = label_;
  // @@protoc_insertion_point(field_get:results.Edge.label)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* Edge::release_label() {
  // @@protoc_insertion_point(field_release:results.Edge.label)
  
  ::common::NameOrId* temp = label_;
  label_ = NULL;
  return temp;
}
inline ::common::NameOrId* Edge::mutable_label() {
  
  if (label_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    label_ = p;
  }
  // @@protoc_insertion_point(field_mutable:results.Edge.label)
  return label_;
}
inline void Edge::set_allocated_label(::common::NameOrId* label) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(label_);
  }
  if (label) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      label = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, label, submessage_arena);
    }
    
  } else {
    
  }
  label_ = label;
  // @@protoc_insertion_point(field_set_allocated:results.Edge.label)
}

// int64 src_id = 3;
inline void Edge::clear_src_id() {
  src_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Edge::src_id() const {
  // @@protoc_insertion_point(field_get:results.Edge.src_id)
  return src_id_;
}
inline void Edge::set_src_id(::google::protobuf::int64 value) {
  
  src_id_ = value;
  // @@protoc_insertion_point(field_set:results.Edge.src_id)
}

// .common.NameOrId src_label = 4;
inline bool Edge::has_src_label() const {
  return this != internal_default_instance() && src_label_ != NULL;
}
inline const ::common::NameOrId& Edge::_internal_src_label() const {
  return *src_label_;
}
inline const ::common::NameOrId& Edge::src_label() const {
  const ::common::NameOrId* p = src_label_;
  // @@protoc_insertion_point(field_get:results.Edge.src_label)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* Edge::release_src_label() {
  // @@protoc_insertion_point(field_release:results.Edge.src_label)
  
  ::common::NameOrId* temp = src_label_;
  src_label_ = NULL;
  return temp;
}
inline ::common::NameOrId* Edge::mutable_src_label() {
  
  if (src_label_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    src_label_ = p;
  }
  // @@protoc_insertion_point(field_mutable:results.Edge.src_label)
  return src_label_;
}
inline void Edge::set_allocated_src_label(::common::NameOrId* src_label) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(src_label_);
  }
  if (src_label) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      src_label = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, src_label, submessage_arena);
    }
    
  } else {
    
  }
  src_label_ = src_label;
  // @@protoc_insertion_point(field_set_allocated:results.Edge.src_label)
}

// int64 dst_id = 5;
inline void Edge::clear_dst_id() {
  dst_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Edge::dst_id() const {
  // @@protoc_insertion_point(field_get:results.Edge.dst_id)
  return dst_id_;
}
inline void Edge::set_dst_id(::google::protobuf::int64 value) {
  
  dst_id_ = value;
  // @@protoc_insertion_point(field_set:results.Edge.dst_id)
}

// .common.NameOrId dst_label = 6;
inline bool Edge::has_dst_label() const {
  return this != internal_default_instance() && dst_label_ != NULL;
}
inline const ::common::NameOrId& Edge::_internal_dst_label() const {
  return *dst_label_;
}
inline const ::common::NameOrId& Edge::dst_label() const {
  const ::common::NameOrId* p = dst_label_;
  // @@protoc_insertion_point(field_get:results.Edge.dst_label)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* Edge::release_dst_label() {
  // @@protoc_insertion_point(field_release:results.Edge.dst_label)
  
  ::common::NameOrId* temp = dst_label_;
  dst_label_ = NULL;
  return temp;
}
inline ::common::NameOrId* Edge::mutable_dst_label() {
  
  if (dst_label_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    dst_label_ = p;
  }
  // @@protoc_insertion_point(field_mutable:results.Edge.dst_label)
  return dst_label_;
}
inline void Edge::set_allocated_dst_label(::common::NameOrId* dst_label) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(dst_label_);
  }
  if (dst_label) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dst_label = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dst_label, submessage_arena);
    }
    
  } else {
    
  }
  dst_label_ = dst_label;
  // @@protoc_insertion_point(field_set_allocated:results.Edge.dst_label)
}

// repeated .results.Property properties = 7;
inline int Edge::properties_size() const {
  return properties_.size();
}
inline void Edge::clear_properties() {
  properties_.Clear();
}
inline ::results::Property* Edge::mutable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:results.Edge.properties)
  return properties_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::results::Property >*
Edge::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_list:results.Edge.properties)
  return &properties_;
}
inline const ::results::Property& Edge::properties(int index) const {
  // @@protoc_insertion_point(field_get:results.Edge.properties)
  return properties_.Get(index);
}
inline ::results::Property* Edge::add_properties() {
  // @@protoc_insertion_point(field_add:results.Edge.properties)
  return properties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::results::Property >&
Edge::properties() const {
  // @@protoc_insertion_point(field_list:results.Edge.properties)
  return properties_;
}

// -------------------------------------------------------------------

// GraphPath_VertexOrEdge

// .results.Vertex vertex = 1;
inline bool GraphPath_VertexOrEdge::has_vertex() const {
  return inner_case() == kVertex;
}
inline void GraphPath_VertexOrEdge::set_has_vertex() {
  _oneof_case_[0] = kVertex;
}
inline void GraphPath_VertexOrEdge::clear_vertex() {
  if (has_vertex()) {
    delete inner_.vertex_;
    clear_has_inner();
  }
}
inline const ::results::Vertex& GraphPath_VertexOrEdge::_internal_vertex() const {
  return *inner_.vertex_;
}
inline ::results::Vertex* GraphPath_VertexOrEdge::release_vertex() {
  // @@protoc_insertion_point(field_release:results.GraphPath.VertexOrEdge.vertex)
  if (has_vertex()) {
    clear_has_inner();
      ::results::Vertex* temp = inner_.vertex_;
    inner_.vertex_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::results::Vertex& GraphPath_VertexOrEdge::vertex() const {
  // @@protoc_insertion_point(field_get:results.GraphPath.VertexOrEdge.vertex)
  return has_vertex()
      ? *inner_.vertex_
      : *reinterpret_cast< ::results::Vertex*>(&::results::_Vertex_default_instance_);
}
inline ::results::Vertex* GraphPath_VertexOrEdge::mutable_vertex() {
  if (!has_vertex()) {
    clear_inner();
    set_has_vertex();
    inner_.vertex_ = CreateMaybeMessage< ::results::Vertex >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:results.GraphPath.VertexOrEdge.vertex)
  return inner_.vertex_;
}

// .results.Edge edge = 2;
inline bool GraphPath_VertexOrEdge::has_edge() const {
  return inner_case() == kEdge;
}
inline void GraphPath_VertexOrEdge::set_has_edge() {
  _oneof_case_[0] = kEdge;
}
inline void GraphPath_VertexOrEdge::clear_edge() {
  if (has_edge()) {
    delete inner_.edge_;
    clear_has_inner();
  }
}
inline const ::results::Edge& GraphPath_VertexOrEdge::_internal_edge() const {
  return *inner_.edge_;
}
inline ::results::Edge* GraphPath_VertexOrEdge::release_edge() {
  // @@protoc_insertion_point(field_release:results.GraphPath.VertexOrEdge.edge)
  if (has_edge()) {
    clear_has_inner();
      ::results::Edge* temp = inner_.edge_;
    inner_.edge_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::results::Edge& GraphPath_VertexOrEdge::edge() const {
  // @@protoc_insertion_point(field_get:results.GraphPath.VertexOrEdge.edge)
  return has_edge()
      ? *inner_.edge_
      : *reinterpret_cast< ::results::Edge*>(&::results::_Edge_default_instance_);
}
inline ::results::Edge* GraphPath_VertexOrEdge::mutable_edge() {
  if (!has_edge()) {
    clear_inner();
    set_has_edge();
    inner_.edge_ = CreateMaybeMessage< ::results::Edge >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:results.GraphPath.VertexOrEdge.edge)
  return inner_.edge_;
}

inline bool GraphPath_VertexOrEdge::has_inner() const {
  return inner_case() != INNER_NOT_SET;
}
inline void GraphPath_VertexOrEdge::clear_has_inner() {
  _oneof_case_[0] = INNER_NOT_SET;
}
inline GraphPath_VertexOrEdge::InnerCase GraphPath_VertexOrEdge::inner_case() const {
  return GraphPath_VertexOrEdge::InnerCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GraphPath

// repeated .results.GraphPath.VertexOrEdge path = 1;
inline int GraphPath::path_size() const {
  return path_.size();
}
inline void GraphPath::clear_path() {
  path_.Clear();
}
inline ::results::GraphPath_VertexOrEdge* GraphPath::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:results.GraphPath.path)
  return path_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::results::GraphPath_VertexOrEdge >*
GraphPath::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:results.GraphPath.path)
  return &path_;
}
inline const ::results::GraphPath_VertexOrEdge& GraphPath::path(int index) const {
  // @@protoc_insertion_point(field_get:results.GraphPath.path)
  return path_.Get(index);
}
inline ::results::GraphPath_VertexOrEdge* GraphPath::add_path() {
  // @@protoc_insertion_point(field_add:results.GraphPath.path)
  return path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::results::GraphPath_VertexOrEdge >&
GraphPath::path() const {
  // @@protoc_insertion_point(field_list:results.GraphPath.path)
  return path_;
}

// -------------------------------------------------------------------

// Element

// .results.Vertex vertex = 1;
inline bool Element::has_vertex() const {
  return inner_case() == kVertex;
}
inline void Element::set_has_vertex() {
  _oneof_case_[0] = kVertex;
}
inline void Element::clear_vertex() {
  if (has_vertex()) {
    delete inner_.vertex_;
    clear_has_inner();
  }
}
inline const ::results::Vertex& Element::_internal_vertex() const {
  return *inner_.vertex_;
}
inline ::results::Vertex* Element::release_vertex() {
  // @@protoc_insertion_point(field_release:results.Element.vertex)
  if (has_vertex()) {
    clear_has_inner();
      ::results::Vertex* temp = inner_.vertex_;
    inner_.vertex_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::results::Vertex& Element::vertex() const {
  // @@protoc_insertion_point(field_get:results.Element.vertex)
  return has_vertex()
      ? *inner_.vertex_
      : *reinterpret_cast< ::results::Vertex*>(&::results::_Vertex_default_instance_);
}
inline ::results::Vertex* Element::mutable_vertex() {
  if (!has_vertex()) {
    clear_inner();
    set_has_vertex();
    inner_.vertex_ = CreateMaybeMessage< ::results::Vertex >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:results.Element.vertex)
  return inner_.vertex_;
}

// .results.Edge edge = 2;
inline bool Element::has_edge() const {
  return inner_case() == kEdge;
}
inline void Element::set_has_edge() {
  _oneof_case_[0] = kEdge;
}
inline void Element::clear_edge() {
  if (has_edge()) {
    delete inner_.edge_;
    clear_has_inner();
  }
}
inline const ::results::Edge& Element::_internal_edge() const {
  return *inner_.edge_;
}
inline ::results::Edge* Element::release_edge() {
  // @@protoc_insertion_point(field_release:results.Element.edge)
  if (has_edge()) {
    clear_has_inner();
      ::results::Edge* temp = inner_.edge_;
    inner_.edge_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::results::Edge& Element::edge() const {
  // @@protoc_insertion_point(field_get:results.Element.edge)
  return has_edge()
      ? *inner_.edge_
      : *reinterpret_cast< ::results::Edge*>(&::results::_Edge_default_instance_);
}
inline ::results::Edge* Element::mutable_edge() {
  if (!has_edge()) {
    clear_inner();
    set_has_edge();
    inner_.edge_ = CreateMaybeMessage< ::results::Edge >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:results.Element.edge)
  return inner_.edge_;
}

// .results.GraphPath graph_path = 3;
inline bool Element::has_graph_path() const {
  return inner_case() == kGraphPath;
}
inline void Element::set_has_graph_path() {
  _oneof_case_[0] = kGraphPath;
}
inline void Element::clear_graph_path() {
  if (has_graph_path()) {
    delete inner_.graph_path_;
    clear_has_inner();
  }
}
inline const ::results::GraphPath& Element::_internal_graph_path() const {
  return *inner_.graph_path_;
}
inline ::results::GraphPath* Element::release_graph_path() {
  // @@protoc_insertion_point(field_release:results.Element.graph_path)
  if (has_graph_path()) {
    clear_has_inner();
      ::results::GraphPath* temp = inner_.graph_path_;
    inner_.graph_path_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::results::GraphPath& Element::graph_path() const {
  // @@protoc_insertion_point(field_get:results.Element.graph_path)
  return has_graph_path()
      ? *inner_.graph_path_
      : *reinterpret_cast< ::results::GraphPath*>(&::results::_GraphPath_default_instance_);
}
inline ::results::GraphPath* Element::mutable_graph_path() {
  if (!has_graph_path()) {
    clear_inner();
    set_has_graph_path();
    inner_.graph_path_ = CreateMaybeMessage< ::results::GraphPath >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:results.Element.graph_path)
  return inner_.graph_path_;
}

// .common.Value object = 4;
inline bool Element::has_object() const {
  return inner_case() == kObject;
}
inline void Element::set_has_object() {
  _oneof_case_[0] = kObject;
}
inline const ::common::Value& Element::_internal_object() const {
  return *inner_.object_;
}
inline ::common::Value* Element::release_object() {
  // @@protoc_insertion_point(field_release:results.Element.object)
  if (has_object()) {
    clear_has_inner();
      ::common::Value* temp = inner_.object_;
    inner_.object_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::common::Value& Element::object() const {
  // @@protoc_insertion_point(field_get:results.Element.object)
  return has_object()
      ? *inner_.object_
      : *reinterpret_cast< ::common::Value*>(&::common::_Value_default_instance_);
}
inline ::common::Value* Element::mutable_object() {
  if (!has_object()) {
    clear_inner();
    set_has_object();
    inner_.object_ = CreateMaybeMessage< ::common::Value >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:results.Element.object)
  return inner_.object_;
}

inline bool Element::has_inner() const {
  return inner_case() != INNER_NOT_SET;
}
inline void Element::clear_has_inner() {
  _oneof_case_[0] = INNER_NOT_SET;
}
inline Element::InnerCase Element::inner_case() const {
  return Element::InnerCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Collection

// repeated .results.Element collection = 1;
inline int Collection::collection_size() const {
  return collection_.size();
}
inline void Collection::clear_collection() {
  collection_.Clear();
}
inline ::results::Element* Collection::mutable_collection(int index) {
  // @@protoc_insertion_point(field_mutable:results.Collection.collection)
  return collection_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::results::Element >*
Collection::mutable_collection() {
  // @@protoc_insertion_point(field_mutable_list:results.Collection.collection)
  return &collection_;
}
inline const ::results::Element& Collection::collection(int index) const {
  // @@protoc_insertion_point(field_get:results.Collection.collection)
  return collection_.Get(index);
}
inline ::results::Element* Collection::add_collection() {
  // @@protoc_insertion_point(field_add:results.Collection.collection)
  return collection_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::results::Element >&
Collection::collection() const {
  // @@protoc_insertion_point(field_list:results.Collection.collection)
  return collection_;
}

// -------------------------------------------------------------------

// Entry

// .results.Element element = 1;
inline bool Entry::has_element() const {
  return inner_case() == kElement;
}
inline void Entry::set_has_element() {
  _oneof_case_[0] = kElement;
}
inline void Entry::clear_element() {
  if (has_element()) {
    delete inner_.element_;
    clear_has_inner();
  }
}
inline const ::results::Element& Entry::_internal_element() const {
  return *inner_.element_;
}
inline ::results::Element* Entry::release_element() {
  // @@protoc_insertion_point(field_release:results.Entry.element)
  if (has_element()) {
    clear_has_inner();
      ::results::Element* temp = inner_.element_;
    inner_.element_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::results::Element& Entry::element() const {
  // @@protoc_insertion_point(field_get:results.Entry.element)
  return has_element()
      ? *inner_.element_
      : *reinterpret_cast< ::results::Element*>(&::results::_Element_default_instance_);
}
inline ::results::Element* Entry::mutable_element() {
  if (!has_element()) {
    clear_inner();
    set_has_element();
    inner_.element_ = CreateMaybeMessage< ::results::Element >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:results.Entry.element)
  return inner_.element_;
}

// .results.Collection collection = 2;
inline bool Entry::has_collection() const {
  return inner_case() == kCollection;
}
inline void Entry::set_has_collection() {
  _oneof_case_[0] = kCollection;
}
inline void Entry::clear_collection() {
  if (has_collection()) {
    delete inner_.collection_;
    clear_has_inner();
  }
}
inline const ::results::Collection& Entry::_internal_collection() const {
  return *inner_.collection_;
}
inline ::results::Collection* Entry::release_collection() {
  // @@protoc_insertion_point(field_release:results.Entry.collection)
  if (has_collection()) {
    clear_has_inner();
      ::results::Collection* temp = inner_.collection_;
    inner_.collection_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::results::Collection& Entry::collection() const {
  // @@protoc_insertion_point(field_get:results.Entry.collection)
  return has_collection()
      ? *inner_.collection_
      : *reinterpret_cast< ::results::Collection*>(&::results::_Collection_default_instance_);
}
inline ::results::Collection* Entry::mutable_collection() {
  if (!has_collection()) {
    clear_inner();
    set_has_collection();
    inner_.collection_ = CreateMaybeMessage< ::results::Collection >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:results.Entry.collection)
  return inner_.collection_;
}

inline bool Entry::has_inner() const {
  return inner_case() != INNER_NOT_SET;
}
inline void Entry::clear_has_inner() {
  _oneof_case_[0] = INNER_NOT_SET;
}
inline Entry::InnerCase Entry::inner_case() const {
  return Entry::InnerCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Column

// .common.NameOrId name_or_id = 1;
inline bool Column::has_name_or_id() const {
  return this != internal_default_instance() && name_or_id_ != NULL;
}
inline const ::common::NameOrId& Column::_internal_name_or_id() const {
  return *name_or_id_;
}
inline const ::common::NameOrId& Column::name_or_id() const {
  const ::common::NameOrId* p = name_or_id_;
  // @@protoc_insertion_point(field_get:results.Column.name_or_id)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* Column::release_name_or_id() {
  // @@protoc_insertion_point(field_release:results.Column.name_or_id)
  
  ::common::NameOrId* temp = name_or_id_;
  name_or_id_ = NULL;
  return temp;
}
inline ::common::NameOrId* Column::mutable_name_or_id() {
  
  if (name_or_id_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    name_or_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:results.Column.name_or_id)
  return name_or_id_;
}
inline void Column::set_allocated_name_or_id(::common::NameOrId* name_or_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(name_or_id_);
  }
  if (name_or_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      name_or_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, name_or_id, submessage_arena);
    }
    
  } else {
    
  }
  name_or_id_ = name_or_id;
  // @@protoc_insertion_point(field_set_allocated:results.Column.name_or_id)
}

// .results.Entry entry = 2;
inline bool Column::has_entry() const {
  return this != internal_default_instance() && entry_ != NULL;
}
inline void Column::clear_entry() {
  if (GetArenaNoVirtual() == NULL && entry_ != NULL) {
    delete entry_;
  }
  entry_ = NULL;
}
inline const ::results::Entry& Column::_internal_entry() const {
  return *entry_;
}
inline const ::results::Entry& Column::entry() const {
  const ::results::Entry* p = entry_;
  // @@protoc_insertion_point(field_get:results.Column.entry)
  return p != NULL ? *p : *reinterpret_cast<const ::results::Entry*>(
      &::results::_Entry_default_instance_);
}
inline ::results::Entry* Column::release_entry() {
  // @@protoc_insertion_point(field_release:results.Column.entry)
  
  ::results::Entry* temp = entry_;
  entry_ = NULL;
  return temp;
}
inline ::results::Entry* Column::mutable_entry() {
  
  if (entry_ == NULL) {
    auto* p = CreateMaybeMessage<::results::Entry>(GetArenaNoVirtual());
    entry_ = p;
  }
  // @@protoc_insertion_point(field_mutable:results.Column.entry)
  return entry_;
}
inline void Column::set_allocated_entry(::results::Entry* entry) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete entry_;
  }
  if (entry) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      entry = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, entry, submessage_arena);
    }
    
  } else {
    
  }
  entry_ = entry;
  // @@protoc_insertion_point(field_set_allocated:results.Column.entry)
}

// -------------------------------------------------------------------

// Record

// repeated .results.Column columns = 1;
inline int Record::columns_size() const {
  return columns_.size();
}
inline void Record::clear_columns() {
  columns_.Clear();
}
inline ::results::Column* Record::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:results.Record.columns)
  return columns_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::results::Column >*
Record::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:results.Record.columns)
  return &columns_;
}
inline const ::results::Column& Record::columns(int index) const {
  // @@protoc_insertion_point(field_get:results.Record.columns)
  return columns_.Get(index);
}
inline ::results::Column* Record::add_columns() {
  // @@protoc_insertion_point(field_add:results.Record.columns)
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::results::Column >&
Record::columns() const {
  // @@protoc_insertion_point(field_list:results.Record.columns)
  return columns_;
}

// -------------------------------------------------------------------

// Results

// .results.Record record = 1;
inline bool Results::has_record() const {
  return inner_case() == kRecord;
}
inline void Results::set_has_record() {
  _oneof_case_[0] = kRecord;
}
inline void Results::clear_record() {
  if (has_record()) {
    delete inner_.record_;
    clear_has_inner();
  }
}
inline const ::results::Record& Results::_internal_record() const {
  return *inner_.record_;
}
inline ::results::Record* Results::release_record() {
  // @@protoc_insertion_point(field_release:results.Results.record)
  if (has_record()) {
    clear_has_inner();
      ::results::Record* temp = inner_.record_;
    inner_.record_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::results::Record& Results::record() const {
  // @@protoc_insertion_point(field_get:results.Results.record)
  return has_record()
      ? *inner_.record_
      : *reinterpret_cast< ::results::Record*>(&::results::_Record_default_instance_);
}
inline ::results::Record* Results::mutable_record() {
  if (!has_record()) {
    clear_inner();
    set_has_record();
    inner_.record_ = CreateMaybeMessage< ::results::Record >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:results.Results.record)
  return inner_.record_;
}

inline bool Results::has_inner() const {
  return inner_case() != INNER_NOT_SET;
}
inline void Results::clear_has_inner() {
  _oneof_case_[0] = INNER_NOT_SET;
}
inline Results::InnerCase Results::inner_case() const {
  return Results::InnerCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CollectiveResults

// repeated .results.Results results = 1;
inline int CollectiveResults::results_size() const {
  return results_.size();
}
inline void CollectiveResults::clear_results() {
  results_.Clear();
}
inline ::results::Results* CollectiveResults::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:results.CollectiveResults.results)
  return results_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::results::Results >*
CollectiveResults::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:results.CollectiveResults.results)
  return &results_;
}
inline const ::results::Results& CollectiveResults::results(int index) const {
  // @@protoc_insertion_point(field_get:results.CollectiveResults.results)
  return results_.Get(index);
}
inline ::results::Results* CollectiveResults::add_results() {
  // @@protoc_insertion_point(field_add:results.CollectiveResults.results)
  return results_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::results::Results >&
CollectiveResults::results() const {
  // @@protoc_insertion_point(field_list:results.CollectiveResults.results)
  return results_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace results

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_results_2eproto
