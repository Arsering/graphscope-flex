// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: algebra.proto

#ifndef PROTOBUF_INCLUDED_algebra_2eproto
#define PROTOBUF_INCLUDED_algebra_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "expr.pb.h"
#include "schema.pb.h"
#include "type.pb.h"
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_algebra_2eproto 

namespace protobuf_algebra_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[46];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_algebra_2eproto
namespace algebra {
class Apply;
class ApplyDefaultTypeInternal;
extern ApplyDefaultTypeInternal _Apply_default_instance_;
class As;
class AsDefaultTypeInternal;
extern AsDefaultTypeInternal _As_default_instance_;
class Branch;
class BranchDefaultTypeInternal;
extern BranchDefaultTypeInternal _Branch_default_instance_;
class Dedup;
class DedupDefaultTypeInternal;
extern DedupDefaultTypeInternal _Dedup_default_instance_;
class EdgeExpand;
class EdgeExpandDefaultTypeInternal;
extern EdgeExpandDefaultTypeInternal _EdgeExpand_default_instance_;
class GetV;
class GetVDefaultTypeInternal;
extern GetVDefaultTypeInternal _GetV_default_instance_;
class GroupBy;
class GroupByDefaultTypeInternal;
extern GroupByDefaultTypeInternal _GroupBy_default_instance_;
class GroupBy_AggFunc;
class GroupBy_AggFuncDefaultTypeInternal;
extern GroupBy_AggFuncDefaultTypeInternal _GroupBy_AggFunc_default_instance_;
class GroupBy_KeyAlias;
class GroupBy_KeyAliasDefaultTypeInternal;
extern GroupBy_KeyAliasDefaultTypeInternal _GroupBy_KeyAlias_default_instance_;
class IndexPredicate;
class IndexPredicateDefaultTypeInternal;
extern IndexPredicateDefaultTypeInternal _IndexPredicate_default_instance_;
class IndexPredicate_AndPredicate;
class IndexPredicate_AndPredicateDefaultTypeInternal;
extern IndexPredicate_AndPredicateDefaultTypeInternal _IndexPredicate_AndPredicate_default_instance_;
class IndexPredicate_Triplet;
class IndexPredicate_TripletDefaultTypeInternal;
extern IndexPredicate_TripletDefaultTypeInternal _IndexPredicate_Triplet_default_instance_;
class Intersect;
class IntersectDefaultTypeInternal;
extern IntersectDefaultTypeInternal _Intersect_default_instance_;
class Join;
class JoinDefaultTypeInternal;
extern JoinDefaultTypeInternal _Join_default_instance_;
class Limit;
class LimitDefaultTypeInternal;
extern LimitDefaultTypeInternal _Limit_default_instance_;
class LogicalPlan;
class LogicalPlanDefaultTypeInternal;
extern LogicalPlanDefaultTypeInternal _LogicalPlan_default_instance_;
class LogicalPlan_Node;
class LogicalPlan_NodeDefaultTypeInternal;
extern LogicalPlan_NodeDefaultTypeInternal _LogicalPlan_Node_default_instance_;
class LogicalPlan_Operator;
class LogicalPlan_OperatorDefaultTypeInternal;
extern LogicalPlan_OperatorDefaultTypeInternal _LogicalPlan_Operator_default_instance_;
class MetaData;
class MetaDataDefaultTypeInternal;
extern MetaDataDefaultTypeInternal _MetaData_default_instance_;
class OrderBy;
class OrderByDefaultTypeInternal;
extern OrderByDefaultTypeInternal _OrderBy_default_instance_;
class OrderBy_OrderingPair;
class OrderBy_OrderingPairDefaultTypeInternal;
extern OrderBy_OrderingPairDefaultTypeInternal _OrderBy_OrderingPair_default_instance_;
class PathExpand;
class PathExpandDefaultTypeInternal;
extern PathExpandDefaultTypeInternal _PathExpand_default_instance_;
class PathExpand_ExpandBase;
class PathExpand_ExpandBaseDefaultTypeInternal;
extern PathExpand_ExpandBaseDefaultTypeInternal _PathExpand_ExpandBase_default_instance_;
class Pattern;
class PatternDefaultTypeInternal;
extern PatternDefaultTypeInternal _Pattern_default_instance_;
class Pattern_Binder;
class Pattern_BinderDefaultTypeInternal;
extern Pattern_BinderDefaultTypeInternal _Pattern_Binder_default_instance_;
class Pattern_Sentence;
class Pattern_SentenceDefaultTypeInternal;
extern Pattern_SentenceDefaultTypeInternal _Pattern_Sentence_default_instance_;
class Project;
class ProjectDefaultTypeInternal;
extern ProjectDefaultTypeInternal _Project_default_instance_;
class Project_ExprAlias;
class Project_ExprAliasDefaultTypeInternal;
extern Project_ExprAliasDefaultTypeInternal _Project_ExprAlias_default_instance_;
class QueryParams;
class QueryParamsDefaultTypeInternal;
extern QueryParamsDefaultTypeInternal _QueryParams_default_instance_;
class QueryParams_ExtraEntry_DoNotUse;
class QueryParams_ExtraEntry_DoNotUseDefaultTypeInternal;
extern QueryParams_ExtraEntry_DoNotUseDefaultTypeInternal _QueryParams_ExtraEntry_DoNotUse_default_instance_;
class Range;
class RangeDefaultTypeInternal;
extern RangeDefaultTypeInternal _Range_default_instance_;
class Root;
class RootDefaultTypeInternal;
extern RootDefaultTypeInternal _Root_default_instance_;
class Sample;
class SampleDefaultTypeInternal;
extern SampleDefaultTypeInternal _Sample_default_instance_;
class Sample_SampleByNum;
class Sample_SampleByNumDefaultTypeInternal;
extern Sample_SampleByNumDefaultTypeInternal _Sample_SampleByNum_default_instance_;
class Sample_SampleByRatio;
class Sample_SampleByRatioDefaultTypeInternal;
extern Sample_SampleByRatioDefaultTypeInternal _Sample_SampleByRatio_default_instance_;
class Sample_SampleType;
class Sample_SampleTypeDefaultTypeInternal;
extern Sample_SampleTypeDefaultTypeInternal _Sample_SampleType_default_instance_;
class Scan;
class ScanDefaultTypeInternal;
extern ScanDefaultTypeInternal _Scan_default_instance_;
class SegmentApply;
class SegmentApplyDefaultTypeInternal;
extern SegmentApplyDefaultTypeInternal _SegmentApply_default_instance_;
class Select;
class SelectDefaultTypeInternal;
extern SelectDefaultTypeInternal _Select_default_instance_;
class Sink;
class SinkDefaultTypeInternal;
extern SinkDefaultTypeInternal _Sink_default_instance_;
class SinkDefault;
class SinkDefaultDefaultTypeInternal;
extern SinkDefaultDefaultTypeInternal _SinkDefault_default_instance_;
class SinkDefault_IdNameMapping;
class SinkDefault_IdNameMappingDefaultTypeInternal;
extern SinkDefault_IdNameMappingDefaultTypeInternal _SinkDefault_IdNameMapping_default_instance_;
class SinkVineyard;
class SinkVineyardDefaultTypeInternal;
extern SinkVineyardDefaultTypeInternal _SinkVineyard_default_instance_;
class Sink_SinkTarget;
class Sink_SinkTargetDefaultTypeInternal;
extern Sink_SinkTargetDefaultTypeInternal _Sink_SinkTarget_default_instance_;
class Unfold;
class UnfoldDefaultTypeInternal;
extern UnfoldDefaultTypeInternal _Unfold_default_instance_;
class Union;
class UnionDefaultTypeInternal;
extern UnionDefaultTypeInternal _Union_default_instance_;
}  // namespace algebra
namespace google {
namespace protobuf {
template<> ::algebra::Apply* Arena::CreateMaybeMessage<::algebra::Apply>(Arena*);
template<> ::algebra::As* Arena::CreateMaybeMessage<::algebra::As>(Arena*);
template<> ::algebra::Branch* Arena::CreateMaybeMessage<::algebra::Branch>(Arena*);
template<> ::algebra::Dedup* Arena::CreateMaybeMessage<::algebra::Dedup>(Arena*);
template<> ::algebra::EdgeExpand* Arena::CreateMaybeMessage<::algebra::EdgeExpand>(Arena*);
template<> ::algebra::GetV* Arena::CreateMaybeMessage<::algebra::GetV>(Arena*);
template<> ::algebra::GroupBy* Arena::CreateMaybeMessage<::algebra::GroupBy>(Arena*);
template<> ::algebra::GroupBy_AggFunc* Arena::CreateMaybeMessage<::algebra::GroupBy_AggFunc>(Arena*);
template<> ::algebra::GroupBy_KeyAlias* Arena::CreateMaybeMessage<::algebra::GroupBy_KeyAlias>(Arena*);
template<> ::algebra::IndexPredicate* Arena::CreateMaybeMessage<::algebra::IndexPredicate>(Arena*);
template<> ::algebra::IndexPredicate_AndPredicate* Arena::CreateMaybeMessage<::algebra::IndexPredicate_AndPredicate>(Arena*);
template<> ::algebra::IndexPredicate_Triplet* Arena::CreateMaybeMessage<::algebra::IndexPredicate_Triplet>(Arena*);
template<> ::algebra::Intersect* Arena::CreateMaybeMessage<::algebra::Intersect>(Arena*);
template<> ::algebra::Join* Arena::CreateMaybeMessage<::algebra::Join>(Arena*);
template<> ::algebra::Limit* Arena::CreateMaybeMessage<::algebra::Limit>(Arena*);
template<> ::algebra::LogicalPlan* Arena::CreateMaybeMessage<::algebra::LogicalPlan>(Arena*);
template<> ::algebra::LogicalPlan_Node* Arena::CreateMaybeMessage<::algebra::LogicalPlan_Node>(Arena*);
template<> ::algebra::LogicalPlan_Operator* Arena::CreateMaybeMessage<::algebra::LogicalPlan_Operator>(Arena*);
template<> ::algebra::MetaData* Arena::CreateMaybeMessage<::algebra::MetaData>(Arena*);
template<> ::algebra::OrderBy* Arena::CreateMaybeMessage<::algebra::OrderBy>(Arena*);
template<> ::algebra::OrderBy_OrderingPair* Arena::CreateMaybeMessage<::algebra::OrderBy_OrderingPair>(Arena*);
template<> ::algebra::PathExpand* Arena::CreateMaybeMessage<::algebra::PathExpand>(Arena*);
template<> ::algebra::PathExpand_ExpandBase* Arena::CreateMaybeMessage<::algebra::PathExpand_ExpandBase>(Arena*);
template<> ::algebra::Pattern* Arena::CreateMaybeMessage<::algebra::Pattern>(Arena*);
template<> ::algebra::Pattern_Binder* Arena::CreateMaybeMessage<::algebra::Pattern_Binder>(Arena*);
template<> ::algebra::Pattern_Sentence* Arena::CreateMaybeMessage<::algebra::Pattern_Sentence>(Arena*);
template<> ::algebra::Project* Arena::CreateMaybeMessage<::algebra::Project>(Arena*);
template<> ::algebra::Project_ExprAlias* Arena::CreateMaybeMessage<::algebra::Project_ExprAlias>(Arena*);
template<> ::algebra::QueryParams* Arena::CreateMaybeMessage<::algebra::QueryParams>(Arena*);
template<> ::algebra::QueryParams_ExtraEntry_DoNotUse* Arena::CreateMaybeMessage<::algebra::QueryParams_ExtraEntry_DoNotUse>(Arena*);
template<> ::algebra::Range* Arena::CreateMaybeMessage<::algebra::Range>(Arena*);
template<> ::algebra::Root* Arena::CreateMaybeMessage<::algebra::Root>(Arena*);
template<> ::algebra::Sample* Arena::CreateMaybeMessage<::algebra::Sample>(Arena*);
template<> ::algebra::Sample_SampleByNum* Arena::CreateMaybeMessage<::algebra::Sample_SampleByNum>(Arena*);
template<> ::algebra::Sample_SampleByRatio* Arena::CreateMaybeMessage<::algebra::Sample_SampleByRatio>(Arena*);
template<> ::algebra::Sample_SampleType* Arena::CreateMaybeMessage<::algebra::Sample_SampleType>(Arena*);
template<> ::algebra::Scan* Arena::CreateMaybeMessage<::algebra::Scan>(Arena*);
template<> ::algebra::SegmentApply* Arena::CreateMaybeMessage<::algebra::SegmentApply>(Arena*);
template<> ::algebra::Select* Arena::CreateMaybeMessage<::algebra::Select>(Arena*);
template<> ::algebra::Sink* Arena::CreateMaybeMessage<::algebra::Sink>(Arena*);
template<> ::algebra::SinkDefault* Arena::CreateMaybeMessage<::algebra::SinkDefault>(Arena*);
template<> ::algebra::SinkDefault_IdNameMapping* Arena::CreateMaybeMessage<::algebra::SinkDefault_IdNameMapping>(Arena*);
template<> ::algebra::SinkVineyard* Arena::CreateMaybeMessage<::algebra::SinkVineyard>(Arena*);
template<> ::algebra::Sink_SinkTarget* Arena::CreateMaybeMessage<::algebra::Sink_SinkTarget>(Arena*);
template<> ::algebra::Unfold* Arena::CreateMaybeMessage<::algebra::Unfold>(Arena*);
template<> ::algebra::Union* Arena::CreateMaybeMessage<::algebra::Union>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace algebra {

enum Join_JoinKind {
  Join_JoinKind_INNER = 0,
  Join_JoinKind_LEFT_OUTER = 1,
  Join_JoinKind_RIGHT_OUTER = 2,
  Join_JoinKind_FULL_OUTER = 3,
  Join_JoinKind_SEMI = 4,
  Join_JoinKind_ANTI = 5,
  Join_JoinKind_TIMES = 6,
  Join_JoinKind_Join_JoinKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Join_JoinKind_Join_JoinKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Join_JoinKind_IsValid(int value);
const Join_JoinKind Join_JoinKind_JoinKind_MIN = Join_JoinKind_INNER;
const Join_JoinKind Join_JoinKind_JoinKind_MAX = Join_JoinKind_TIMES;
const int Join_JoinKind_JoinKind_ARRAYSIZE = Join_JoinKind_JoinKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Join_JoinKind_descriptor();
inline const ::std::string& Join_JoinKind_Name(Join_JoinKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Join_JoinKind_descriptor(), value);
}
inline bool Join_JoinKind_Parse(
    const ::std::string& name, Join_JoinKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Join_JoinKind>(
    Join_JoinKind_descriptor(), name, value);
}
enum GroupBy_AggFunc_Aggregate {
  GroupBy_AggFunc_Aggregate_SUM = 0,
  GroupBy_AggFunc_Aggregate_MIN = 1,
  GroupBy_AggFunc_Aggregate_MAX = 2,
  GroupBy_AggFunc_Aggregate_COUNT = 3,
  GroupBy_AggFunc_Aggregate_COUNT_DISTINCT = 4,
  GroupBy_AggFunc_Aggregate_TO_LIST = 5,
  GroupBy_AggFunc_Aggregate_TO_SET = 6,
  GroupBy_AggFunc_Aggregate_AVG = 7,
  GroupBy_AggFunc_Aggregate_FIRST = 8,
  GroupBy_AggFunc_Aggregate_GroupBy_AggFunc_Aggregate_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GroupBy_AggFunc_Aggregate_GroupBy_AggFunc_Aggregate_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GroupBy_AggFunc_Aggregate_IsValid(int value);
const GroupBy_AggFunc_Aggregate GroupBy_AggFunc_Aggregate_Aggregate_MIN = GroupBy_AggFunc_Aggregate_SUM;
const GroupBy_AggFunc_Aggregate GroupBy_AggFunc_Aggregate_Aggregate_MAX = GroupBy_AggFunc_Aggregate_FIRST;
const int GroupBy_AggFunc_Aggregate_Aggregate_ARRAYSIZE = GroupBy_AggFunc_Aggregate_Aggregate_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupBy_AggFunc_Aggregate_descriptor();
inline const ::std::string& GroupBy_AggFunc_Aggregate_Name(GroupBy_AggFunc_Aggregate value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupBy_AggFunc_Aggregate_descriptor(), value);
}
inline bool GroupBy_AggFunc_Aggregate_Parse(
    const ::std::string& name, GroupBy_AggFunc_Aggregate* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupBy_AggFunc_Aggregate>(
    GroupBy_AggFunc_Aggregate_descriptor(), name, value);
}
enum OrderBy_OrderingPair_Order {
  OrderBy_OrderingPair_Order_SHUFFLE = 0,
  OrderBy_OrderingPair_Order_ASC = 1,
  OrderBy_OrderingPair_Order_DESC = 2,
  OrderBy_OrderingPair_Order_OrderBy_OrderingPair_Order_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OrderBy_OrderingPair_Order_OrderBy_OrderingPair_Order_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OrderBy_OrderingPair_Order_IsValid(int value);
const OrderBy_OrderingPair_Order OrderBy_OrderingPair_Order_Order_MIN = OrderBy_OrderingPair_Order_SHUFFLE;
const OrderBy_OrderingPair_Order OrderBy_OrderingPair_Order_Order_MAX = OrderBy_OrderingPair_Order_DESC;
const int OrderBy_OrderingPair_Order_Order_ARRAYSIZE = OrderBy_OrderingPair_Order_Order_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderBy_OrderingPair_Order_descriptor();
inline const ::std::string& OrderBy_OrderingPair_Order_Name(OrderBy_OrderingPair_Order value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderBy_OrderingPair_Order_descriptor(), value);
}
inline bool OrderBy_OrderingPair_Order_Parse(
    const ::std::string& name, OrderBy_OrderingPair_Order* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderBy_OrderingPair_Order>(
    OrderBy_OrderingPair_Order_descriptor(), name, value);
}
enum Scan_ScanOpt {
  Scan_ScanOpt_VERTEX = 0,
  Scan_ScanOpt_EDGE = 1,
  Scan_ScanOpt_TABLE = 2,
  Scan_ScanOpt_Scan_ScanOpt_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Scan_ScanOpt_Scan_ScanOpt_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Scan_ScanOpt_IsValid(int value);
const Scan_ScanOpt Scan_ScanOpt_ScanOpt_MIN = Scan_ScanOpt_VERTEX;
const Scan_ScanOpt Scan_ScanOpt_ScanOpt_MAX = Scan_ScanOpt_TABLE;
const int Scan_ScanOpt_ScanOpt_ARRAYSIZE = Scan_ScanOpt_ScanOpt_MAX + 1;

const ::google::protobuf::EnumDescriptor* Scan_ScanOpt_descriptor();
inline const ::std::string& Scan_ScanOpt_Name(Scan_ScanOpt value) {
  return ::google::protobuf::internal::NameOfEnum(
    Scan_ScanOpt_descriptor(), value);
}
inline bool Scan_ScanOpt_Parse(
    const ::std::string& name, Scan_ScanOpt* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Scan_ScanOpt>(
    Scan_ScanOpt_descriptor(), name, value);
}
enum GetV_VOpt {
  GetV_VOpt_START = 0,
  GetV_VOpt_END = 1,
  GetV_VOpt_OTHER = 2,
  GetV_VOpt_BOTH = 3,
  GetV_VOpt_GetV_VOpt_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GetV_VOpt_GetV_VOpt_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GetV_VOpt_IsValid(int value);
const GetV_VOpt GetV_VOpt_VOpt_MIN = GetV_VOpt_START;
const GetV_VOpt GetV_VOpt_VOpt_MAX = GetV_VOpt_BOTH;
const int GetV_VOpt_VOpt_ARRAYSIZE = GetV_VOpt_VOpt_MAX + 1;

const ::google::protobuf::EnumDescriptor* GetV_VOpt_descriptor();
inline const ::std::string& GetV_VOpt_Name(GetV_VOpt value) {
  return ::google::protobuf::internal::NameOfEnum(
    GetV_VOpt_descriptor(), value);
}
inline bool GetV_VOpt_Parse(
    const ::std::string& name, GetV_VOpt* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GetV_VOpt>(
    GetV_VOpt_descriptor(), name, value);
}
enum EdgeExpand_Direction {
  EdgeExpand_Direction_OUT = 0,
  EdgeExpand_Direction_IN = 1,
  EdgeExpand_Direction_BOTH = 2,
  EdgeExpand_Direction_EdgeExpand_Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EdgeExpand_Direction_EdgeExpand_Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EdgeExpand_Direction_IsValid(int value);
const EdgeExpand_Direction EdgeExpand_Direction_Direction_MIN = EdgeExpand_Direction_OUT;
const EdgeExpand_Direction EdgeExpand_Direction_Direction_MAX = EdgeExpand_Direction_BOTH;
const int EdgeExpand_Direction_Direction_ARRAYSIZE = EdgeExpand_Direction_Direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* EdgeExpand_Direction_descriptor();
inline const ::std::string& EdgeExpand_Direction_Name(EdgeExpand_Direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    EdgeExpand_Direction_descriptor(), value);
}
inline bool EdgeExpand_Direction_Parse(
    const ::std::string& name, EdgeExpand_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EdgeExpand_Direction>(
    EdgeExpand_Direction_descriptor(), name, value);
}
enum EdgeExpand_ExpandOpt {
  EdgeExpand_ExpandOpt_VERTEX = 0,
  EdgeExpand_ExpandOpt_EDGE = 1,
  EdgeExpand_ExpandOpt_DEGREE = 2,
  EdgeExpand_ExpandOpt_EdgeExpand_ExpandOpt_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EdgeExpand_ExpandOpt_EdgeExpand_ExpandOpt_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EdgeExpand_ExpandOpt_IsValid(int value);
const EdgeExpand_ExpandOpt EdgeExpand_ExpandOpt_ExpandOpt_MIN = EdgeExpand_ExpandOpt_VERTEX;
const EdgeExpand_ExpandOpt EdgeExpand_ExpandOpt_ExpandOpt_MAX = EdgeExpand_ExpandOpt_DEGREE;
const int EdgeExpand_ExpandOpt_ExpandOpt_ARRAYSIZE = EdgeExpand_ExpandOpt_ExpandOpt_MAX + 1;

const ::google::protobuf::EnumDescriptor* EdgeExpand_ExpandOpt_descriptor();
inline const ::std::string& EdgeExpand_ExpandOpt_Name(EdgeExpand_ExpandOpt value) {
  return ::google::protobuf::internal::NameOfEnum(
    EdgeExpand_ExpandOpt_descriptor(), value);
}
inline bool EdgeExpand_ExpandOpt_Parse(
    const ::std::string& name, EdgeExpand_ExpandOpt* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EdgeExpand_ExpandOpt>(
    EdgeExpand_ExpandOpt_descriptor(), name, value);
}
enum PathExpand_PathOpt {
  PathExpand_PathOpt_ARBITRARY = 0,
  PathExpand_PathOpt_SIMPLE = 1,
  PathExpand_PathOpt_PathExpand_PathOpt_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PathExpand_PathOpt_PathExpand_PathOpt_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PathExpand_PathOpt_IsValid(int value);
const PathExpand_PathOpt PathExpand_PathOpt_PathOpt_MIN = PathExpand_PathOpt_ARBITRARY;
const PathExpand_PathOpt PathExpand_PathOpt_PathOpt_MAX = PathExpand_PathOpt_SIMPLE;
const int PathExpand_PathOpt_PathOpt_ARRAYSIZE = PathExpand_PathOpt_PathOpt_MAX + 1;

const ::google::protobuf::EnumDescriptor* PathExpand_PathOpt_descriptor();
inline const ::std::string& PathExpand_PathOpt_Name(PathExpand_PathOpt value) {
  return ::google::protobuf::internal::NameOfEnum(
    PathExpand_PathOpt_descriptor(), value);
}
inline bool PathExpand_PathOpt_Parse(
    const ::std::string& name, PathExpand_PathOpt* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PathExpand_PathOpt>(
    PathExpand_PathOpt_descriptor(), name, value);
}
enum PathExpand_ResultOpt {
  PathExpand_ResultOpt_END_V = 0,
  PathExpand_ResultOpt_ALL_V = 1,
  PathExpand_ResultOpt_ALL_V_E = 2,
  PathExpand_ResultOpt_PathExpand_ResultOpt_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PathExpand_ResultOpt_PathExpand_ResultOpt_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PathExpand_ResultOpt_IsValid(int value);
const PathExpand_ResultOpt PathExpand_ResultOpt_ResultOpt_MIN = PathExpand_ResultOpt_END_V;
const PathExpand_ResultOpt PathExpand_ResultOpt_ResultOpt_MAX = PathExpand_ResultOpt_ALL_V_E;
const int PathExpand_ResultOpt_ResultOpt_ARRAYSIZE = PathExpand_ResultOpt_ResultOpt_MAX + 1;

const ::google::protobuf::EnumDescriptor* PathExpand_ResultOpt_descriptor();
inline const ::std::string& PathExpand_ResultOpt_Name(PathExpand_ResultOpt value) {
  return ::google::protobuf::internal::NameOfEnum(
    PathExpand_ResultOpt_descriptor(), value);
}
inline bool PathExpand_ResultOpt_Parse(
    const ::std::string& name, PathExpand_ResultOpt* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PathExpand_ResultOpt>(
    PathExpand_ResultOpt_descriptor(), name, value);
}
enum SinkDefault_MetaType {
  SinkDefault_MetaType_ENTITY = 0,
  SinkDefault_MetaType_RELATION = 1,
  SinkDefault_MetaType_COLUMN = 2,
  SinkDefault_MetaType_TAG = 3,
  SinkDefault_MetaType_SinkDefault_MetaType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SinkDefault_MetaType_SinkDefault_MetaType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SinkDefault_MetaType_IsValid(int value);
const SinkDefault_MetaType SinkDefault_MetaType_MetaType_MIN = SinkDefault_MetaType_ENTITY;
const SinkDefault_MetaType SinkDefault_MetaType_MetaType_MAX = SinkDefault_MetaType_TAG;
const int SinkDefault_MetaType_MetaType_ARRAYSIZE = SinkDefault_MetaType_MetaType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SinkDefault_MetaType_descriptor();
inline const ::std::string& SinkDefault_MetaType_Name(SinkDefault_MetaType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SinkDefault_MetaType_descriptor(), value);
}
inline bool SinkDefault_MetaType_Parse(
    const ::std::string& name, SinkDefault_MetaType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SinkDefault_MetaType>(
    SinkDefault_MetaType_descriptor(), name, value);
}
// ===================================================================

class MetaData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.MetaData) */ {
 public:
  MetaData();
  virtual ~MetaData();

  MetaData(const MetaData& from);

  inline MetaData& operator=(const MetaData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MetaData(MetaData&& from) noexcept
    : MetaData() {
    *this = ::std::move(from);
  }

  inline MetaData& operator=(MetaData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MetaData* internal_default_instance() {
    return reinterpret_cast<const MetaData*>(
               &_MetaData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(MetaData* other);
  friend void swap(MetaData& a, MetaData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MetaData* New() const final {
    return CreateMaybeMessage<MetaData>(NULL);
  }

  MetaData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MetaData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MetaData& from);
  void MergeFrom(const MetaData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetaData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.IrDataType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  private:
  const ::common::IrDataType& _internal_type() const;
  public:
  const ::common::IrDataType& type() const;
  ::common::IrDataType* release_type();
  ::common::IrDataType* mutable_type();
  void set_allocated_type(::common::IrDataType* type);

  // int32 alias = 2;
  void clear_alias();
  static const int kAliasFieldNumber = 2;
  ::google::protobuf::int32 alias() const;
  void set_alias(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:algebra.MetaData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::IrDataType* type_;
  ::google::protobuf::int32 alias_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Project_ExprAlias : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.Project.ExprAlias) */ {
 public:
  Project_ExprAlias();
  virtual ~Project_ExprAlias();

  Project_ExprAlias(const Project_ExprAlias& from);

  inline Project_ExprAlias& operator=(const Project_ExprAlias& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Project_ExprAlias(Project_ExprAlias&& from) noexcept
    : Project_ExprAlias() {
    *this = ::std::move(from);
  }

  inline Project_ExprAlias& operator=(Project_ExprAlias&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Project_ExprAlias& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Project_ExprAlias* internal_default_instance() {
    return reinterpret_cast<const Project_ExprAlias*>(
               &_Project_ExprAlias_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Project_ExprAlias* other);
  friend void swap(Project_ExprAlias& a, Project_ExprAlias& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Project_ExprAlias* New() const final {
    return CreateMaybeMessage<Project_ExprAlias>(NULL);
  }

  Project_ExprAlias* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Project_ExprAlias>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Project_ExprAlias& from);
  void MergeFrom(const Project_ExprAlias& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Project_ExprAlias* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.Expression expr = 1;
  bool has_expr() const;
  void clear_expr();
  static const int kExprFieldNumber = 1;
  private:
  const ::common::Expression& _internal_expr() const;
  public:
  const ::common::Expression& expr() const;
  ::common::Expression* release_expr();
  ::common::Expression* mutable_expr();
  void set_allocated_expr(::common::Expression* expr);

  // .common.NameOrId alias = 2;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 2;
  private:
  const ::common::NameOrId& _internal_alias() const;
  public:
  const ::common::NameOrId& alias() const;
  ::common::NameOrId* release_alias();
  ::common::NameOrId* mutable_alias();
  void set_allocated_alias(::common::NameOrId* alias);

  // @@protoc_insertion_point(class_scope:algebra.Project.ExprAlias)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::Expression* expr_;
  ::common::NameOrId* alias_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Project : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.Project) */ {
 public:
  Project();
  virtual ~Project();

  Project(const Project& from);

  inline Project& operator=(const Project& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Project(Project&& from) noexcept
    : Project() {
    *this = ::std::move(from);
  }

  inline Project& operator=(Project&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Project& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Project* internal_default_instance() {
    return reinterpret_cast<const Project*>(
               &_Project_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Project* other);
  friend void swap(Project& a, Project& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Project* New() const final {
    return CreateMaybeMessage<Project>(NULL);
  }

  Project* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Project>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Project& from);
  void MergeFrom(const Project& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Project* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Project_ExprAlias ExprAlias;

  // accessors -------------------------------------------------------

  // repeated .algebra.Project.ExprAlias mappings = 1;
  int mappings_size() const;
  void clear_mappings();
  static const int kMappingsFieldNumber = 1;
  ::algebra::Project_ExprAlias* mutable_mappings(int index);
  ::google::protobuf::RepeatedPtrField< ::algebra::Project_ExprAlias >*
      mutable_mappings();
  const ::algebra::Project_ExprAlias& mappings(int index) const;
  ::algebra::Project_ExprAlias* add_mappings();
  const ::google::protobuf::RepeatedPtrField< ::algebra::Project_ExprAlias >&
      mappings() const;

  // repeated .algebra.MetaData meta_data = 3;
  int meta_data_size() const;
  void clear_meta_data();
  static const int kMetaDataFieldNumber = 3;
  ::algebra::MetaData* mutable_meta_data(int index);
  ::google::protobuf::RepeatedPtrField< ::algebra::MetaData >*
      mutable_meta_data();
  const ::algebra::MetaData& meta_data(int index) const;
  ::algebra::MetaData* add_meta_data();
  const ::google::protobuf::RepeatedPtrField< ::algebra::MetaData >&
      meta_data() const;

  // bool is_append = 2;
  void clear_is_append();
  static const int kIsAppendFieldNumber = 2;
  bool is_append() const;
  void set_is_append(bool value);

  // @@protoc_insertion_point(class_scope:algebra.Project)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::algebra::Project_ExprAlias > mappings_;
  ::google::protobuf::RepeatedPtrField< ::algebra::MetaData > meta_data_;
  bool is_append_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Select : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.Select) */ {
 public:
  Select();
  virtual ~Select();

  Select(const Select& from);

  inline Select& operator=(const Select& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Select(Select&& from) noexcept
    : Select() {
    *this = ::std::move(from);
  }

  inline Select& operator=(Select&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Select& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Select* internal_default_instance() {
    return reinterpret_cast<const Select*>(
               &_Select_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Select* other);
  friend void swap(Select& a, Select& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Select* New() const final {
    return CreateMaybeMessage<Select>(NULL);
  }

  Select* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Select>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Select& from);
  void MergeFrom(const Select& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Select* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.Expression predicate = 1;
  bool has_predicate() const;
  void clear_predicate();
  static const int kPredicateFieldNumber = 1;
  private:
  const ::common::Expression& _internal_predicate() const;
  public:
  const ::common::Expression& predicate() const;
  ::common::Expression* release_predicate();
  ::common::Expression* mutable_predicate();
  void set_allocated_predicate(::common::Expression* predicate);

  // @@protoc_insertion_point(class_scope:algebra.Select)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::Expression* predicate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Join : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.Join) */ {
 public:
  Join();
  virtual ~Join();

  Join(const Join& from);

  inline Join& operator=(const Join& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Join(Join&& from) noexcept
    : Join() {
    *this = ::std::move(from);
  }

  inline Join& operator=(Join&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Join& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Join* internal_default_instance() {
    return reinterpret_cast<const Join*>(
               &_Join_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Join* other);
  friend void swap(Join& a, Join& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Join* New() const final {
    return CreateMaybeMessage<Join>(NULL);
  }

  Join* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Join>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Join& from);
  void MergeFrom(const Join& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Join* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Join_JoinKind JoinKind;
  static const JoinKind INNER =
    Join_JoinKind_INNER;
  static const JoinKind LEFT_OUTER =
    Join_JoinKind_LEFT_OUTER;
  static const JoinKind RIGHT_OUTER =
    Join_JoinKind_RIGHT_OUTER;
  static const JoinKind FULL_OUTER =
    Join_JoinKind_FULL_OUTER;
  static const JoinKind SEMI =
    Join_JoinKind_SEMI;
  static const JoinKind ANTI =
    Join_JoinKind_ANTI;
  static const JoinKind TIMES =
    Join_JoinKind_TIMES;
  static inline bool JoinKind_IsValid(int value) {
    return Join_JoinKind_IsValid(value);
  }
  static const JoinKind JoinKind_MIN =
    Join_JoinKind_JoinKind_MIN;
  static const JoinKind JoinKind_MAX =
    Join_JoinKind_JoinKind_MAX;
  static const int JoinKind_ARRAYSIZE =
    Join_JoinKind_JoinKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  JoinKind_descriptor() {
    return Join_JoinKind_descriptor();
  }
  static inline const ::std::string& JoinKind_Name(JoinKind value) {
    return Join_JoinKind_Name(value);
  }
  static inline bool JoinKind_Parse(const ::std::string& name,
      JoinKind* value) {
    return Join_JoinKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .common.Variable left_keys = 1;
  int left_keys_size() const;
  void clear_left_keys();
  static const int kLeftKeysFieldNumber = 1;
  ::common::Variable* mutable_left_keys(int index);
  ::google::protobuf::RepeatedPtrField< ::common::Variable >*
      mutable_left_keys();
  const ::common::Variable& left_keys(int index) const;
  ::common::Variable* add_left_keys();
  const ::google::protobuf::RepeatedPtrField< ::common::Variable >&
      left_keys() const;

  // repeated .common.Variable right_keys = 2;
  int right_keys_size() const;
  void clear_right_keys();
  static const int kRightKeysFieldNumber = 2;
  ::common::Variable* mutable_right_keys(int index);
  ::google::protobuf::RepeatedPtrField< ::common::Variable >*
      mutable_right_keys();
  const ::common::Variable& right_keys(int index) const;
  ::common::Variable* add_right_keys();
  const ::google::protobuf::RepeatedPtrField< ::common::Variable >&
      right_keys() const;

  // .algebra.Join.JoinKind kind = 3;
  void clear_kind();
  static const int kKindFieldNumber = 3;
  ::algebra::Join_JoinKind kind() const;
  void set_kind(::algebra::Join_JoinKind value);

  // @@protoc_insertion_point(class_scope:algebra.Join)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::common::Variable > left_keys_;
  ::google::protobuf::RepeatedPtrField< ::common::Variable > right_keys_;
  int kind_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Union : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.Union) */ {
 public:
  Union();
  virtual ~Union();

  Union(const Union& from);

  inline Union& operator=(const Union& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Union(Union&& from) noexcept
    : Union() {
    *this = ::std::move(from);
  }

  inline Union& operator=(Union&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Union& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Union* internal_default_instance() {
    return reinterpret_cast<const Union*>(
               &_Union_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Union* other);
  friend void swap(Union& a, Union& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Union* New() const final {
    return CreateMaybeMessage<Union>(NULL);
  }

  Union* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Union>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Union& from);
  void MergeFrom(const Union& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Union* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 parents = 1;
  int parents_size() const;
  void clear_parents();
  static const int kParentsFieldNumber = 1;
  ::google::protobuf::int32 parents(int index) const;
  void set_parents(int index, ::google::protobuf::int32 value);
  void add_parents(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      parents() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_parents();

  // @@protoc_insertion_point(class_scope:algebra.Union)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > parents_;
  mutable int _parents_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Intersect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.Intersect) */ {
 public:
  Intersect();
  virtual ~Intersect();

  Intersect(const Intersect& from);

  inline Intersect& operator=(const Intersect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Intersect(Intersect&& from) noexcept
    : Intersect() {
    *this = ::std::move(from);
  }

  inline Intersect& operator=(Intersect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Intersect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Intersect* internal_default_instance() {
    return reinterpret_cast<const Intersect*>(
               &_Intersect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Intersect* other);
  friend void swap(Intersect& a, Intersect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Intersect* New() const final {
    return CreateMaybeMessage<Intersect>(NULL);
  }

  Intersect* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Intersect>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Intersect& from);
  void MergeFrom(const Intersect& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Intersect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 parents = 1;
  int parents_size() const;
  void clear_parents();
  static const int kParentsFieldNumber = 1;
  ::google::protobuf::int32 parents(int index) const;
  void set_parents(int index, ::google::protobuf::int32 value);
  void add_parents(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      parents() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_parents();

  // .common.NameOrId key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  private:
  const ::common::NameOrId& _internal_key() const;
  public:
  const ::common::NameOrId& key() const;
  ::common::NameOrId* release_key();
  ::common::NameOrId* mutable_key();
  void set_allocated_key(::common::NameOrId* key);

  // @@protoc_insertion_point(class_scope:algebra.Intersect)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > parents_;
  mutable int _parents_cached_byte_size_;
  ::common::NameOrId* key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroupBy_AggFunc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.GroupBy.AggFunc) */ {
 public:
  GroupBy_AggFunc();
  virtual ~GroupBy_AggFunc();

  GroupBy_AggFunc(const GroupBy_AggFunc& from);

  inline GroupBy_AggFunc& operator=(const GroupBy_AggFunc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroupBy_AggFunc(GroupBy_AggFunc&& from) noexcept
    : GroupBy_AggFunc() {
    *this = ::std::move(from);
  }

  inline GroupBy_AggFunc& operator=(GroupBy_AggFunc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupBy_AggFunc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GroupBy_AggFunc* internal_default_instance() {
    return reinterpret_cast<const GroupBy_AggFunc*>(
               &_GroupBy_AggFunc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(GroupBy_AggFunc* other);
  friend void swap(GroupBy_AggFunc& a, GroupBy_AggFunc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroupBy_AggFunc* New() const final {
    return CreateMaybeMessage<GroupBy_AggFunc>(NULL);
  }

  GroupBy_AggFunc* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GroupBy_AggFunc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GroupBy_AggFunc& from);
  void MergeFrom(const GroupBy_AggFunc& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupBy_AggFunc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GroupBy_AggFunc_Aggregate Aggregate;
  static const Aggregate SUM =
    GroupBy_AggFunc_Aggregate_SUM;
  static const Aggregate MIN =
    GroupBy_AggFunc_Aggregate_MIN;
  static const Aggregate MAX =
    GroupBy_AggFunc_Aggregate_MAX;
  static const Aggregate COUNT =
    GroupBy_AggFunc_Aggregate_COUNT;
  static const Aggregate COUNT_DISTINCT =
    GroupBy_AggFunc_Aggregate_COUNT_DISTINCT;
  static const Aggregate TO_LIST =
    GroupBy_AggFunc_Aggregate_TO_LIST;
  static const Aggregate TO_SET =
    GroupBy_AggFunc_Aggregate_TO_SET;
  static const Aggregate AVG =
    GroupBy_AggFunc_Aggregate_AVG;
  static const Aggregate FIRST =
    GroupBy_AggFunc_Aggregate_FIRST;
  static inline bool Aggregate_IsValid(int value) {
    return GroupBy_AggFunc_Aggregate_IsValid(value);
  }
  static const Aggregate Aggregate_MIN =
    GroupBy_AggFunc_Aggregate_Aggregate_MIN;
  static const Aggregate Aggregate_MAX =
    GroupBy_AggFunc_Aggregate_Aggregate_MAX;
  static const int Aggregate_ARRAYSIZE =
    GroupBy_AggFunc_Aggregate_Aggregate_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Aggregate_descriptor() {
    return GroupBy_AggFunc_Aggregate_descriptor();
  }
  static inline const ::std::string& Aggregate_Name(Aggregate value) {
    return GroupBy_AggFunc_Aggregate_Name(value);
  }
  static inline bool Aggregate_Parse(const ::std::string& name,
      Aggregate* value) {
    return GroupBy_AggFunc_Aggregate_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .common.Variable vars = 1;
  int vars_size() const;
  void clear_vars();
  static const int kVarsFieldNumber = 1;
  ::common::Variable* mutable_vars(int index);
  ::google::protobuf::RepeatedPtrField< ::common::Variable >*
      mutable_vars();
  const ::common::Variable& vars(int index) const;
  ::common::Variable* add_vars();
  const ::google::protobuf::RepeatedPtrField< ::common::Variable >&
      vars() const;

  // .common.NameOrId alias = 3;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 3;
  private:
  const ::common::NameOrId& _internal_alias() const;
  public:
  const ::common::NameOrId& alias() const;
  ::common::NameOrId* release_alias();
  ::common::NameOrId* mutable_alias();
  void set_allocated_alias(::common::NameOrId* alias);

  // .algebra.GroupBy.AggFunc.Aggregate aggregate = 2;
  void clear_aggregate();
  static const int kAggregateFieldNumber = 2;
  ::algebra::GroupBy_AggFunc_Aggregate aggregate() const;
  void set_aggregate(::algebra::GroupBy_AggFunc_Aggregate value);

  // @@protoc_insertion_point(class_scope:algebra.GroupBy.AggFunc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::common::Variable > vars_;
  ::common::NameOrId* alias_;
  int aggregate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroupBy_KeyAlias : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.GroupBy.KeyAlias) */ {
 public:
  GroupBy_KeyAlias();
  virtual ~GroupBy_KeyAlias();

  GroupBy_KeyAlias(const GroupBy_KeyAlias& from);

  inline GroupBy_KeyAlias& operator=(const GroupBy_KeyAlias& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroupBy_KeyAlias(GroupBy_KeyAlias&& from) noexcept
    : GroupBy_KeyAlias() {
    *this = ::std::move(from);
  }

  inline GroupBy_KeyAlias& operator=(GroupBy_KeyAlias&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupBy_KeyAlias& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GroupBy_KeyAlias* internal_default_instance() {
    return reinterpret_cast<const GroupBy_KeyAlias*>(
               &_GroupBy_KeyAlias_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(GroupBy_KeyAlias* other);
  friend void swap(GroupBy_KeyAlias& a, GroupBy_KeyAlias& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroupBy_KeyAlias* New() const final {
    return CreateMaybeMessage<GroupBy_KeyAlias>(NULL);
  }

  GroupBy_KeyAlias* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GroupBy_KeyAlias>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GroupBy_KeyAlias& from);
  void MergeFrom(const GroupBy_KeyAlias& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupBy_KeyAlias* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.Variable key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  private:
  const ::common::Variable& _internal_key() const;
  public:
  const ::common::Variable& key() const;
  ::common::Variable* release_key();
  ::common::Variable* mutable_key();
  void set_allocated_key(::common::Variable* key);

  // .common.NameOrId alias = 2;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 2;
  private:
  const ::common::NameOrId& _internal_alias() const;
  public:
  const ::common::NameOrId& alias() const;
  ::common::NameOrId* release_alias();
  ::common::NameOrId* mutable_alias();
  void set_allocated_alias(::common::NameOrId* alias);

  // @@protoc_insertion_point(class_scope:algebra.GroupBy.KeyAlias)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::Variable* key_;
  ::common::NameOrId* alias_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroupBy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.GroupBy) */ {
 public:
  GroupBy();
  virtual ~GroupBy();

  GroupBy(const GroupBy& from);

  inline GroupBy& operator=(const GroupBy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroupBy(GroupBy&& from) noexcept
    : GroupBy() {
    *this = ::std::move(from);
  }

  inline GroupBy& operator=(GroupBy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupBy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GroupBy* internal_default_instance() {
    return reinterpret_cast<const GroupBy*>(
               &_GroupBy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(GroupBy* other);
  friend void swap(GroupBy& a, GroupBy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroupBy* New() const final {
    return CreateMaybeMessage<GroupBy>(NULL);
  }

  GroupBy* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GroupBy>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GroupBy& from);
  void MergeFrom(const GroupBy& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupBy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GroupBy_AggFunc AggFunc;
  typedef GroupBy_KeyAlias KeyAlias;

  // accessors -------------------------------------------------------

  // repeated .algebra.GroupBy.KeyAlias mappings = 1;
  int mappings_size() const;
  void clear_mappings();
  static const int kMappingsFieldNumber = 1;
  ::algebra::GroupBy_KeyAlias* mutable_mappings(int index);
  ::google::protobuf::RepeatedPtrField< ::algebra::GroupBy_KeyAlias >*
      mutable_mappings();
  const ::algebra::GroupBy_KeyAlias& mappings(int index) const;
  ::algebra::GroupBy_KeyAlias* add_mappings();
  const ::google::protobuf::RepeatedPtrField< ::algebra::GroupBy_KeyAlias >&
      mappings() const;

  // repeated .algebra.GroupBy.AggFunc functions = 2;
  int functions_size() const;
  void clear_functions();
  static const int kFunctionsFieldNumber = 2;
  ::algebra::GroupBy_AggFunc* mutable_functions(int index);
  ::google::protobuf::RepeatedPtrField< ::algebra::GroupBy_AggFunc >*
      mutable_functions();
  const ::algebra::GroupBy_AggFunc& functions(int index) const;
  ::algebra::GroupBy_AggFunc* add_functions();
  const ::google::protobuf::RepeatedPtrField< ::algebra::GroupBy_AggFunc >&
      functions() const;

  // repeated .algebra.MetaData meta_data = 3;
  int meta_data_size() const;
  void clear_meta_data();
  static const int kMetaDataFieldNumber = 3;
  ::algebra::MetaData* mutable_meta_data(int index);
  ::google::protobuf::RepeatedPtrField< ::algebra::MetaData >*
      mutable_meta_data();
  const ::algebra::MetaData& meta_data(int index) const;
  ::algebra::MetaData* add_meta_data();
  const ::google::protobuf::RepeatedPtrField< ::algebra::MetaData >&
      meta_data() const;

  // @@protoc_insertion_point(class_scope:algebra.GroupBy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::algebra::GroupBy_KeyAlias > mappings_;
  ::google::protobuf::RepeatedPtrField< ::algebra::GroupBy_AggFunc > functions_;
  ::google::protobuf::RepeatedPtrField< ::algebra::MetaData > meta_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OrderBy_OrderingPair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.OrderBy.OrderingPair) */ {
 public:
  OrderBy_OrderingPair();
  virtual ~OrderBy_OrderingPair();

  OrderBy_OrderingPair(const OrderBy_OrderingPair& from);

  inline OrderBy_OrderingPair& operator=(const OrderBy_OrderingPair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OrderBy_OrderingPair(OrderBy_OrderingPair&& from) noexcept
    : OrderBy_OrderingPair() {
    *this = ::std::move(from);
  }

  inline OrderBy_OrderingPair& operator=(OrderBy_OrderingPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderBy_OrderingPair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrderBy_OrderingPair* internal_default_instance() {
    return reinterpret_cast<const OrderBy_OrderingPair*>(
               &_OrderBy_OrderingPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(OrderBy_OrderingPair* other);
  friend void swap(OrderBy_OrderingPair& a, OrderBy_OrderingPair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OrderBy_OrderingPair* New() const final {
    return CreateMaybeMessage<OrderBy_OrderingPair>(NULL);
  }

  OrderBy_OrderingPair* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OrderBy_OrderingPair>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OrderBy_OrderingPair& from);
  void MergeFrom(const OrderBy_OrderingPair& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderBy_OrderingPair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OrderBy_OrderingPair_Order Order;
  static const Order SHUFFLE =
    OrderBy_OrderingPair_Order_SHUFFLE;
  static const Order ASC =
    OrderBy_OrderingPair_Order_ASC;
  static const Order DESC =
    OrderBy_OrderingPair_Order_DESC;
  static inline bool Order_IsValid(int value) {
    return OrderBy_OrderingPair_Order_IsValid(value);
  }
  static const Order Order_MIN =
    OrderBy_OrderingPair_Order_Order_MIN;
  static const Order Order_MAX =
    OrderBy_OrderingPair_Order_Order_MAX;
  static const int Order_ARRAYSIZE =
    OrderBy_OrderingPair_Order_Order_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Order_descriptor() {
    return OrderBy_OrderingPair_Order_descriptor();
  }
  static inline const ::std::string& Order_Name(Order value) {
    return OrderBy_OrderingPair_Order_Name(value);
  }
  static inline bool Order_Parse(const ::std::string& name,
      Order* value) {
    return OrderBy_OrderingPair_Order_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .common.Variable key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  private:
  const ::common::Variable& _internal_key() const;
  public:
  const ::common::Variable& key() const;
  ::common::Variable* release_key();
  ::common::Variable* mutable_key();
  void set_allocated_key(::common::Variable* key);

  // .algebra.OrderBy.OrderingPair.Order order = 2;
  void clear_order();
  static const int kOrderFieldNumber = 2;
  ::algebra::OrderBy_OrderingPair_Order order() const;
  void set_order(::algebra::OrderBy_OrderingPair_Order value);

  // @@protoc_insertion_point(class_scope:algebra.OrderBy.OrderingPair)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::Variable* key_;
  int order_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OrderBy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.OrderBy) */ {
 public:
  OrderBy();
  virtual ~OrderBy();

  OrderBy(const OrderBy& from);

  inline OrderBy& operator=(const OrderBy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OrderBy(OrderBy&& from) noexcept
    : OrderBy() {
    *this = ::std::move(from);
  }

  inline OrderBy& operator=(OrderBy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderBy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrderBy* internal_default_instance() {
    return reinterpret_cast<const OrderBy*>(
               &_OrderBy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(OrderBy* other);
  friend void swap(OrderBy& a, OrderBy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OrderBy* New() const final {
    return CreateMaybeMessage<OrderBy>(NULL);
  }

  OrderBy* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OrderBy>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OrderBy& from);
  void MergeFrom(const OrderBy& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderBy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OrderBy_OrderingPair OrderingPair;

  // accessors -------------------------------------------------------

  // repeated .algebra.OrderBy.OrderingPair pairs = 2;
  int pairs_size() const;
  void clear_pairs();
  static const int kPairsFieldNumber = 2;
  ::algebra::OrderBy_OrderingPair* mutable_pairs(int index);
  ::google::protobuf::RepeatedPtrField< ::algebra::OrderBy_OrderingPair >*
      mutable_pairs();
  const ::algebra::OrderBy_OrderingPair& pairs(int index) const;
  ::algebra::OrderBy_OrderingPair* add_pairs();
  const ::google::protobuf::RepeatedPtrField< ::algebra::OrderBy_OrderingPair >&
      pairs() const;

  // .algebra.Range limit = 3;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 3;
  private:
  const ::algebra::Range& _internal_limit() const;
  public:
  const ::algebra::Range& limit() const;
  ::algebra::Range* release_limit();
  ::algebra::Range* mutable_limit();
  void set_allocated_limit(::algebra::Range* limit);

  // @@protoc_insertion_point(class_scope:algebra.OrderBy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::algebra::OrderBy_OrderingPair > pairs_;
  ::algebra::Range* limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Dedup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.Dedup) */ {
 public:
  Dedup();
  virtual ~Dedup();

  Dedup(const Dedup& from);

  inline Dedup& operator=(const Dedup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Dedup(Dedup&& from) noexcept
    : Dedup() {
    *this = ::std::move(from);
  }

  inline Dedup& operator=(Dedup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Dedup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Dedup* internal_default_instance() {
    return reinterpret_cast<const Dedup*>(
               &_Dedup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Dedup* other);
  friend void swap(Dedup& a, Dedup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Dedup* New() const final {
    return CreateMaybeMessage<Dedup>(NULL);
  }

  Dedup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Dedup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Dedup& from);
  void MergeFrom(const Dedup& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dedup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .common.Variable keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  ::common::Variable* mutable_keys(int index);
  ::google::protobuf::RepeatedPtrField< ::common::Variable >*
      mutable_keys();
  const ::common::Variable& keys(int index) const;
  ::common::Variable* add_keys();
  const ::google::protobuf::RepeatedPtrField< ::common::Variable >&
      keys() const;

  // @@protoc_insertion_point(class_scope:algebra.Dedup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::common::Variable > keys_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Unfold : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.Unfold) */ {
 public:
  Unfold();
  virtual ~Unfold();

  Unfold(const Unfold& from);

  inline Unfold& operator=(const Unfold& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Unfold(Unfold&& from) noexcept
    : Unfold() {
    *this = ::std::move(from);
  }

  inline Unfold& operator=(Unfold&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Unfold& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Unfold* internal_default_instance() {
    return reinterpret_cast<const Unfold*>(
               &_Unfold_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Unfold* other);
  friend void swap(Unfold& a, Unfold& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Unfold* New() const final {
    return CreateMaybeMessage<Unfold>(NULL);
  }

  Unfold* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Unfold>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Unfold& from);
  void MergeFrom(const Unfold& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Unfold* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.NameOrId tag = 1;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  private:
  const ::common::NameOrId& _internal_tag() const;
  public:
  const ::common::NameOrId& tag() const;
  ::common::NameOrId* release_tag();
  ::common::NameOrId* mutable_tag();
  void set_allocated_tag(::common::NameOrId* tag);

  // .common.NameOrId alias = 2;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 2;
  private:
  const ::common::NameOrId& _internal_alias() const;
  public:
  const ::common::NameOrId& alias() const;
  ::common::NameOrId* release_alias();
  ::common::NameOrId* mutable_alias();
  void set_allocated_alias(::common::NameOrId* alias);

  // .algebra.MetaData meta_data = 3;
  bool has_meta_data() const;
  void clear_meta_data();
  static const int kMetaDataFieldNumber = 3;
  private:
  const ::algebra::MetaData& _internal_meta_data() const;
  public:
  const ::algebra::MetaData& meta_data() const;
  ::algebra::MetaData* release_meta_data();
  ::algebra::MetaData* mutable_meta_data();
  void set_allocated_meta_data(::algebra::MetaData* meta_data);

  // @@protoc_insertion_point(class_scope:algebra.Unfold)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::NameOrId* tag_;
  ::common::NameOrId* alias_;
  ::algebra::MetaData* meta_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Range : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.Range) */ {
 public:
  Range();
  virtual ~Range();

  Range(const Range& from);

  inline Range& operator=(const Range& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Range(Range&& from) noexcept
    : Range() {
    *this = ::std::move(from);
  }

  inline Range& operator=(Range&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Range& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Range* internal_default_instance() {
    return reinterpret_cast<const Range*>(
               &_Range_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Range* other);
  friend void swap(Range& a, Range& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Range* New() const final {
    return CreateMaybeMessage<Range>(NULL);
  }

  Range* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Range>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Range& from);
  void MergeFrom(const Range& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Range* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 lower = 1;
  void clear_lower();
  static const int kLowerFieldNumber = 1;
  ::google::protobuf::int32 lower() const;
  void set_lower(::google::protobuf::int32 value);

  // int32 upper = 2;
  void clear_upper();
  static const int kUpperFieldNumber = 2;
  ::google::protobuf::int32 upper() const;
  void set_upper(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:algebra.Range)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 lower_;
  ::google::protobuf::int32 upper_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Limit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.Limit) */ {
 public:
  Limit();
  virtual ~Limit();

  Limit(const Limit& from);

  inline Limit& operator=(const Limit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Limit(Limit&& from) noexcept
    : Limit() {
    *this = ::std::move(from);
  }

  inline Limit& operator=(Limit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Limit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Limit* internal_default_instance() {
    return reinterpret_cast<const Limit*>(
               &_Limit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(Limit* other);
  friend void swap(Limit& a, Limit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Limit* New() const final {
    return CreateMaybeMessage<Limit>(NULL);
  }

  Limit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Limit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Limit& from);
  void MergeFrom(const Limit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Limit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .algebra.Range range = 1;
  bool has_range() const;
  void clear_range();
  static const int kRangeFieldNumber = 1;
  private:
  const ::algebra::Range& _internal_range() const;
  public:
  const ::algebra::Range& range() const;
  ::algebra::Range* release_range();
  ::algebra::Range* mutable_range();
  void set_allocated_range(::algebra::Range* range);

  // @@protoc_insertion_point(class_scope:algebra.Limit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::algebra::Range* range_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IndexPredicate_Triplet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.IndexPredicate.Triplet) */ {
 public:
  IndexPredicate_Triplet();
  virtual ~IndexPredicate_Triplet();

  IndexPredicate_Triplet(const IndexPredicate_Triplet& from);

  inline IndexPredicate_Triplet& operator=(const IndexPredicate_Triplet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IndexPredicate_Triplet(IndexPredicate_Triplet&& from) noexcept
    : IndexPredicate_Triplet() {
    *this = ::std::move(from);
  }

  inline IndexPredicate_Triplet& operator=(IndexPredicate_Triplet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IndexPredicate_Triplet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IndexPredicate_Triplet* internal_default_instance() {
    return reinterpret_cast<const IndexPredicate_Triplet*>(
               &_IndexPredicate_Triplet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(IndexPredicate_Triplet* other);
  friend void swap(IndexPredicate_Triplet& a, IndexPredicate_Triplet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IndexPredicate_Triplet* New() const final {
    return CreateMaybeMessage<IndexPredicate_Triplet>(NULL);
  }

  IndexPredicate_Triplet* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IndexPredicate_Triplet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IndexPredicate_Triplet& from);
  void MergeFrom(const IndexPredicate_Triplet& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexPredicate_Triplet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.Property key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  private:
  const ::common::Property& _internal_key() const;
  public:
  const ::common::Property& key() const;
  ::common::Property* release_key();
  ::common::Property* mutable_key();
  void set_allocated_key(::common::Property* key);

  // .common.Value value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::common::Value& _internal_value() const;
  public:
  const ::common::Value& value() const;
  ::common::Value* release_value();
  ::common::Value* mutable_value();
  void set_allocated_value(::common::Value* value);

  // .common.None cmp = 3;
  bool has_cmp() const;
  void clear_cmp();
  static const int kCmpFieldNumber = 3;
  private:
  const ::common::None& _internal_cmp() const;
  public:
  const ::common::None& cmp() const;
  ::common::None* release_cmp();
  ::common::None* mutable_cmp();
  void set_allocated_cmp(::common::None* cmp);

  // @@protoc_insertion_point(class_scope:algebra.IndexPredicate.Triplet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::Property* key_;
  ::common::Value* value_;
  ::common::None* cmp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IndexPredicate_AndPredicate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.IndexPredicate.AndPredicate) */ {
 public:
  IndexPredicate_AndPredicate();
  virtual ~IndexPredicate_AndPredicate();

  IndexPredicate_AndPredicate(const IndexPredicate_AndPredicate& from);

  inline IndexPredicate_AndPredicate& operator=(const IndexPredicate_AndPredicate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IndexPredicate_AndPredicate(IndexPredicate_AndPredicate&& from) noexcept
    : IndexPredicate_AndPredicate() {
    *this = ::std::move(from);
  }

  inline IndexPredicate_AndPredicate& operator=(IndexPredicate_AndPredicate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IndexPredicate_AndPredicate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IndexPredicate_AndPredicate* internal_default_instance() {
    return reinterpret_cast<const IndexPredicate_AndPredicate*>(
               &_IndexPredicate_AndPredicate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(IndexPredicate_AndPredicate* other);
  friend void swap(IndexPredicate_AndPredicate& a, IndexPredicate_AndPredicate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IndexPredicate_AndPredicate* New() const final {
    return CreateMaybeMessage<IndexPredicate_AndPredicate>(NULL);
  }

  IndexPredicate_AndPredicate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IndexPredicate_AndPredicate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IndexPredicate_AndPredicate& from);
  void MergeFrom(const IndexPredicate_AndPredicate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexPredicate_AndPredicate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .algebra.IndexPredicate.Triplet predicates = 1;
  int predicates_size() const;
  void clear_predicates();
  static const int kPredicatesFieldNumber = 1;
  ::algebra::IndexPredicate_Triplet* mutable_predicates(int index);
  ::google::protobuf::RepeatedPtrField< ::algebra::IndexPredicate_Triplet >*
      mutable_predicates();
  const ::algebra::IndexPredicate_Triplet& predicates(int index) const;
  ::algebra::IndexPredicate_Triplet* add_predicates();
  const ::google::protobuf::RepeatedPtrField< ::algebra::IndexPredicate_Triplet >&
      predicates() const;

  // @@protoc_insertion_point(class_scope:algebra.IndexPredicate.AndPredicate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::algebra::IndexPredicate_Triplet > predicates_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IndexPredicate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.IndexPredicate) */ {
 public:
  IndexPredicate();
  virtual ~IndexPredicate();

  IndexPredicate(const IndexPredicate& from);

  inline IndexPredicate& operator=(const IndexPredicate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IndexPredicate(IndexPredicate&& from) noexcept
    : IndexPredicate() {
    *this = ::std::move(from);
  }

  inline IndexPredicate& operator=(IndexPredicate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IndexPredicate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IndexPredicate* internal_default_instance() {
    return reinterpret_cast<const IndexPredicate*>(
               &_IndexPredicate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(IndexPredicate* other);
  friend void swap(IndexPredicate& a, IndexPredicate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IndexPredicate* New() const final {
    return CreateMaybeMessage<IndexPredicate>(NULL);
  }

  IndexPredicate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IndexPredicate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IndexPredicate& from);
  void MergeFrom(const IndexPredicate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexPredicate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef IndexPredicate_Triplet Triplet;
  typedef IndexPredicate_AndPredicate AndPredicate;

  // accessors -------------------------------------------------------

  // repeated .algebra.IndexPredicate.AndPredicate or_predicates = 1;
  int or_predicates_size() const;
  void clear_or_predicates();
  static const int kOrPredicatesFieldNumber = 1;
  ::algebra::IndexPredicate_AndPredicate* mutable_or_predicates(int index);
  ::google::protobuf::RepeatedPtrField< ::algebra::IndexPredicate_AndPredicate >*
      mutable_or_predicates();
  const ::algebra::IndexPredicate_AndPredicate& or_predicates(int index) const;
  ::algebra::IndexPredicate_AndPredicate* add_or_predicates();
  const ::google::protobuf::RepeatedPtrField< ::algebra::IndexPredicate_AndPredicate >&
      or_predicates() const;

  // @@protoc_insertion_point(class_scope:algebra.IndexPredicate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::algebra::IndexPredicate_AndPredicate > or_predicates_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QueryParams_ExtraEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<QueryParams_ExtraEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<QueryParams_ExtraEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  QueryParams_ExtraEntry_DoNotUse();
  QueryParams_ExtraEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const QueryParams_ExtraEntry_DoNotUse& other);
  static const QueryParams_ExtraEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const QueryParams_ExtraEntry_DoNotUse*>(&_QueryParams_ExtraEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class QueryParams : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.QueryParams) */ {
 public:
  QueryParams();
  virtual ~QueryParams();

  QueryParams(const QueryParams& from);

  inline QueryParams& operator=(const QueryParams& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryParams(QueryParams&& from) noexcept
    : QueryParams() {
    *this = ::std::move(from);
  }

  inline QueryParams& operator=(QueryParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QueryParams* internal_default_instance() {
    return reinterpret_cast<const QueryParams*>(
               &_QueryParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(QueryParams* other);
  friend void swap(QueryParams& a, QueryParams& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryParams* New() const final {
    return CreateMaybeMessage<QueryParams>(NULL);
  }

  QueryParams* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<QueryParams>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const QueryParams& from);
  void MergeFrom(const QueryParams& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated .common.NameOrId tables = 1;
  int tables_size() const;
  void clear_tables();
  static const int kTablesFieldNumber = 1;
  ::common::NameOrId* mutable_tables(int index);
  ::google::protobuf::RepeatedPtrField< ::common::NameOrId >*
      mutable_tables();
  const ::common::NameOrId& tables(int index) const;
  ::common::NameOrId* add_tables();
  const ::google::protobuf::RepeatedPtrField< ::common::NameOrId >&
      tables() const;

  // repeated .common.NameOrId columns = 2;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 2;
  ::common::NameOrId* mutable_columns(int index);
  ::google::protobuf::RepeatedPtrField< ::common::NameOrId >*
      mutable_columns();
  const ::common::NameOrId& columns(int index) const;
  ::common::NameOrId* add_columns();
  const ::google::protobuf::RepeatedPtrField< ::common::NameOrId >&
      columns() const;

  // map<string, string> extra = 7;
  int extra_size() const;
  void clear_extra();
  static const int kExtraFieldNumber = 7;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      extra() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_extra();

  // .algebra.Range limit = 4;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 4;
  private:
  const ::algebra::Range& _internal_limit() const;
  public:
  const ::algebra::Range& limit() const;
  ::algebra::Range* release_limit();
  ::algebra::Range* mutable_limit();
  void set_allocated_limit(::algebra::Range* limit);

  // .common.Expression predicate = 5;
  bool has_predicate() const;
  void clear_predicate();
  static const int kPredicateFieldNumber = 5;
  private:
  const ::common::Expression& _internal_predicate() const;
  public:
  const ::common::Expression& predicate() const;
  ::common::Expression* release_predicate();
  ::common::Expression* mutable_predicate();
  void set_allocated_predicate(::common::Expression* predicate);

  // double sample_ratio = 6;
  void clear_sample_ratio();
  static const int kSampleRatioFieldNumber = 6;
  double sample_ratio() const;
  void set_sample_ratio(double value);

  // bool is_all_columns = 3;
  void clear_is_all_columns();
  static const int kIsAllColumnsFieldNumber = 3;
  bool is_all_columns() const;
  void set_is_all_columns(bool value);

  // @@protoc_insertion_point(class_scope:algebra.QueryParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::common::NameOrId > tables_;
  ::google::protobuf::RepeatedPtrField< ::common::NameOrId > columns_;
  ::google::protobuf::internal::MapField<
      QueryParams_ExtraEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > extra_;
  ::algebra::Range* limit_;
  ::common::Expression* predicate_;
  double sample_ratio_;
  bool is_all_columns_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.Scan) */ {
 public:
  Scan();
  virtual ~Scan();

  Scan(const Scan& from);

  inline Scan& operator=(const Scan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scan(Scan&& from) noexcept
    : Scan() {
    *this = ::std::move(from);
  }

  inline Scan& operator=(Scan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scan* internal_default_instance() {
    return reinterpret_cast<const Scan*>(
               &_Scan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(Scan* other);
  friend void swap(Scan& a, Scan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scan* New() const final {
    return CreateMaybeMessage<Scan>(NULL);
  }

  Scan* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scan>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scan& from);
  void MergeFrom(const Scan& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Scan_ScanOpt ScanOpt;
  static const ScanOpt VERTEX =
    Scan_ScanOpt_VERTEX;
  static const ScanOpt EDGE =
    Scan_ScanOpt_EDGE;
  static const ScanOpt TABLE =
    Scan_ScanOpt_TABLE;
  static inline bool ScanOpt_IsValid(int value) {
    return Scan_ScanOpt_IsValid(value);
  }
  static const ScanOpt ScanOpt_MIN =
    Scan_ScanOpt_ScanOpt_MIN;
  static const ScanOpt ScanOpt_MAX =
    Scan_ScanOpt_ScanOpt_MAX;
  static const int ScanOpt_ARRAYSIZE =
    Scan_ScanOpt_ScanOpt_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ScanOpt_descriptor() {
    return Scan_ScanOpt_descriptor();
  }
  static inline const ::std::string& ScanOpt_Name(ScanOpt value) {
    return Scan_ScanOpt_Name(value);
  }
  static inline bool ScanOpt_Parse(const ::std::string& name,
      ScanOpt* value) {
    return Scan_ScanOpt_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .common.NameOrId alias = 2;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 2;
  private:
  const ::common::NameOrId& _internal_alias() const;
  public:
  const ::common::NameOrId& alias() const;
  ::common::NameOrId* release_alias();
  ::common::NameOrId* mutable_alias();
  void set_allocated_alias(::common::NameOrId* alias);

  // .algebra.QueryParams params = 3;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 3;
  private:
  const ::algebra::QueryParams& _internal_params() const;
  public:
  const ::algebra::QueryParams& params() const;
  ::algebra::QueryParams* release_params();
  ::algebra::QueryParams* mutable_params();
  void set_allocated_params(::algebra::QueryParams* params);

  // .algebra.IndexPredicate idx_predicate = 4;
  bool has_idx_predicate() const;
  void clear_idx_predicate();
  static const int kIdxPredicateFieldNumber = 4;
  private:
  const ::algebra::IndexPredicate& _internal_idx_predicate() const;
  public:
  const ::algebra::IndexPredicate& idx_predicate() const;
  ::algebra::IndexPredicate* release_idx_predicate();
  ::algebra::IndexPredicate* mutable_idx_predicate();
  void set_allocated_idx_predicate(::algebra::IndexPredicate* idx_predicate);

  // .algebra.MetaData meta_data = 5;
  bool has_meta_data() const;
  void clear_meta_data();
  static const int kMetaDataFieldNumber = 5;
  private:
  const ::algebra::MetaData& _internal_meta_data() const;
  public:
  const ::algebra::MetaData& meta_data() const;
  ::algebra::MetaData* release_meta_data();
  ::algebra::MetaData* mutable_meta_data();
  void set_allocated_meta_data(::algebra::MetaData* meta_data);

  // .algebra.Scan.ScanOpt scan_opt = 1;
  void clear_scan_opt();
  static const int kScanOptFieldNumber = 1;
  ::algebra::Scan_ScanOpt scan_opt() const;
  void set_scan_opt(::algebra::Scan_ScanOpt value);

  // @@protoc_insertion_point(class_scope:algebra.Scan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::NameOrId* alias_;
  ::algebra::QueryParams* params_;
  ::algebra::IndexPredicate* idx_predicate_;
  ::algebra::MetaData* meta_data_;
  int scan_opt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetV : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.GetV) */ {
 public:
  GetV();
  virtual ~GetV();

  GetV(const GetV& from);

  inline GetV& operator=(const GetV& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetV(GetV&& from) noexcept
    : GetV() {
    *this = ::std::move(from);
  }

  inline GetV& operator=(GetV&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetV& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetV* internal_default_instance() {
    return reinterpret_cast<const GetV*>(
               &_GetV_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(GetV* other);
  friend void swap(GetV& a, GetV& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetV* New() const final {
    return CreateMaybeMessage<GetV>(NULL);
  }

  GetV* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetV>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetV& from);
  void MergeFrom(const GetV& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetV* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetV_VOpt VOpt;
  static const VOpt START =
    GetV_VOpt_START;
  static const VOpt END =
    GetV_VOpt_END;
  static const VOpt OTHER =
    GetV_VOpt_OTHER;
  static const VOpt BOTH =
    GetV_VOpt_BOTH;
  static inline bool VOpt_IsValid(int value) {
    return GetV_VOpt_IsValid(value);
  }
  static const VOpt VOpt_MIN =
    GetV_VOpt_VOpt_MIN;
  static const VOpt VOpt_MAX =
    GetV_VOpt_VOpt_MAX;
  static const int VOpt_ARRAYSIZE =
    GetV_VOpt_VOpt_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VOpt_descriptor() {
    return GetV_VOpt_descriptor();
  }
  static inline const ::std::string& VOpt_Name(VOpt value) {
    return GetV_VOpt_Name(value);
  }
  static inline bool VOpt_Parse(const ::std::string& name,
      VOpt* value) {
    return GetV_VOpt_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .common.NameOrId tag = 1;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  private:
  const ::common::NameOrId& _internal_tag() const;
  public:
  const ::common::NameOrId& tag() const;
  ::common::NameOrId* release_tag();
  ::common::NameOrId* mutable_tag();
  void set_allocated_tag(::common::NameOrId* tag);

  // .algebra.QueryParams params = 3;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 3;
  private:
  const ::algebra::QueryParams& _internal_params() const;
  public:
  const ::algebra::QueryParams& params() const;
  ::algebra::QueryParams* release_params();
  ::algebra::QueryParams* mutable_params();
  void set_allocated_params(::algebra::QueryParams* params);

  // .common.NameOrId alias = 4;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 4;
  private:
  const ::common::NameOrId& _internal_alias() const;
  public:
  const ::common::NameOrId& alias() const;
  ::common::NameOrId* release_alias();
  ::common::NameOrId* mutable_alias();
  void set_allocated_alias(::common::NameOrId* alias);

  // .algebra.MetaData meta_data = 5;
  bool has_meta_data() const;
  void clear_meta_data();
  static const int kMetaDataFieldNumber = 5;
  private:
  const ::algebra::MetaData& _internal_meta_data() const;
  public:
  const ::algebra::MetaData& meta_data() const;
  ::algebra::MetaData* release_meta_data();
  ::algebra::MetaData* mutable_meta_data();
  void set_allocated_meta_data(::algebra::MetaData* meta_data);

  // .algebra.GetV.VOpt opt = 2;
  void clear_opt();
  static const int kOptFieldNumber = 2;
  ::algebra::GetV_VOpt opt() const;
  void set_opt(::algebra::GetV_VOpt value);

  // @@protoc_insertion_point(class_scope:algebra.GetV)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::NameOrId* tag_;
  ::algebra::QueryParams* params_;
  ::common::NameOrId* alias_;
  ::algebra::MetaData* meta_data_;
  int opt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class As : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.As) */ {
 public:
  As();
  virtual ~As();

  As(const As& from);

  inline As& operator=(const As& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  As(As&& from) noexcept
    : As() {
    *this = ::std::move(from);
  }

  inline As& operator=(As&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const As& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const As* internal_default_instance() {
    return reinterpret_cast<const As*>(
               &_As_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(As* other);
  friend void swap(As& a, As& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline As* New() const final {
    return CreateMaybeMessage<As>(NULL);
  }

  As* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<As>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const As& from);
  void MergeFrom(const As& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(As* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.NameOrId alias = 1;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 1;
  private:
  const ::common::NameOrId& _internal_alias() const;
  public:
  const ::common::NameOrId& alias() const;
  ::common::NameOrId* release_alias();
  ::common::NameOrId* mutable_alias();
  void set_allocated_alias(::common::NameOrId* alias);

  // @@protoc_insertion_point(class_scope:algebra.As)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::NameOrId* alias_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EdgeExpand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.EdgeExpand) */ {
 public:
  EdgeExpand();
  virtual ~EdgeExpand();

  EdgeExpand(const EdgeExpand& from);

  inline EdgeExpand& operator=(const EdgeExpand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EdgeExpand(EdgeExpand&& from) noexcept
    : EdgeExpand() {
    *this = ::std::move(from);
  }

  inline EdgeExpand& operator=(EdgeExpand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EdgeExpand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EdgeExpand* internal_default_instance() {
    return reinterpret_cast<const EdgeExpand*>(
               &_EdgeExpand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(EdgeExpand* other);
  friend void swap(EdgeExpand& a, EdgeExpand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EdgeExpand* New() const final {
    return CreateMaybeMessage<EdgeExpand>(NULL);
  }

  EdgeExpand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EdgeExpand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EdgeExpand& from);
  void MergeFrom(const EdgeExpand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EdgeExpand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EdgeExpand_Direction Direction;
  static const Direction OUT =
    EdgeExpand_Direction_OUT;
  static const Direction IN =
    EdgeExpand_Direction_IN;
  static const Direction BOTH =
    EdgeExpand_Direction_BOTH;
  static inline bool Direction_IsValid(int value) {
    return EdgeExpand_Direction_IsValid(value);
  }
  static const Direction Direction_MIN =
    EdgeExpand_Direction_Direction_MIN;
  static const Direction Direction_MAX =
    EdgeExpand_Direction_Direction_MAX;
  static const int Direction_ARRAYSIZE =
    EdgeExpand_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Direction_descriptor() {
    return EdgeExpand_Direction_descriptor();
  }
  static inline const ::std::string& Direction_Name(Direction value) {
    return EdgeExpand_Direction_Name(value);
  }
  static inline bool Direction_Parse(const ::std::string& name,
      Direction* value) {
    return EdgeExpand_Direction_Parse(name, value);
  }

  typedef EdgeExpand_ExpandOpt ExpandOpt;
  static const ExpandOpt VERTEX =
    EdgeExpand_ExpandOpt_VERTEX;
  static const ExpandOpt EDGE =
    EdgeExpand_ExpandOpt_EDGE;
  static const ExpandOpt DEGREE =
    EdgeExpand_ExpandOpt_DEGREE;
  static inline bool ExpandOpt_IsValid(int value) {
    return EdgeExpand_ExpandOpt_IsValid(value);
  }
  static const ExpandOpt ExpandOpt_MIN =
    EdgeExpand_ExpandOpt_ExpandOpt_MIN;
  static const ExpandOpt ExpandOpt_MAX =
    EdgeExpand_ExpandOpt_ExpandOpt_MAX;
  static const int ExpandOpt_ARRAYSIZE =
    EdgeExpand_ExpandOpt_ExpandOpt_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ExpandOpt_descriptor() {
    return EdgeExpand_ExpandOpt_descriptor();
  }
  static inline const ::std::string& ExpandOpt_Name(ExpandOpt value) {
    return EdgeExpand_ExpandOpt_Name(value);
  }
  static inline bool ExpandOpt_Parse(const ::std::string& name,
      ExpandOpt* value) {
    return EdgeExpand_ExpandOpt_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .common.NameOrId v_tag = 1;
  bool has_v_tag() const;
  void clear_v_tag();
  static const int kVTagFieldNumber = 1;
  private:
  const ::common::NameOrId& _internal_v_tag() const;
  public:
  const ::common::NameOrId& v_tag() const;
  ::common::NameOrId* release_v_tag();
  ::common::NameOrId* mutable_v_tag();
  void set_allocated_v_tag(::common::NameOrId* v_tag);

  // .algebra.QueryParams params = 3;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 3;
  private:
  const ::algebra::QueryParams& _internal_params() const;
  public:
  const ::algebra::QueryParams& params() const;
  ::algebra::QueryParams* release_params();
  ::algebra::QueryParams* mutable_params();
  void set_allocated_params(::algebra::QueryParams* params);

  // .common.NameOrId alias = 4;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 4;
  private:
  const ::common::NameOrId& _internal_alias() const;
  public:
  const ::common::NameOrId& alias() const;
  ::common::NameOrId* release_alias();
  ::common::NameOrId* mutable_alias();
  void set_allocated_alias(::common::NameOrId* alias);

  // .algebra.MetaData meta_data = 6;
  bool has_meta_data() const;
  void clear_meta_data();
  static const int kMetaDataFieldNumber = 6;
  private:
  const ::algebra::MetaData& _internal_meta_data() const;
  public:
  const ::algebra::MetaData& meta_data() const;
  ::algebra::MetaData* release_meta_data();
  ::algebra::MetaData* mutable_meta_data();
  void set_allocated_meta_data(::algebra::MetaData* meta_data);

  // .algebra.EdgeExpand.Direction direction = 2;
  void clear_direction();
  static const int kDirectionFieldNumber = 2;
  ::algebra::EdgeExpand_Direction direction() const;
  void set_direction(::algebra::EdgeExpand_Direction value);

  // .algebra.EdgeExpand.ExpandOpt expand_opt = 5;
  void clear_expand_opt();
  static const int kExpandOptFieldNumber = 5;
  ::algebra::EdgeExpand_ExpandOpt expand_opt() const;
  void set_expand_opt(::algebra::EdgeExpand_ExpandOpt value);

  // @@protoc_insertion_point(class_scope:algebra.EdgeExpand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::NameOrId* v_tag_;
  ::algebra::QueryParams* params_;
  ::common::NameOrId* alias_;
  ::algebra::MetaData* meta_data_;
  int direction_;
  int expand_opt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PathExpand_ExpandBase : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.PathExpand.ExpandBase) */ {
 public:
  PathExpand_ExpandBase();
  virtual ~PathExpand_ExpandBase();

  PathExpand_ExpandBase(const PathExpand_ExpandBase& from);

  inline PathExpand_ExpandBase& operator=(const PathExpand_ExpandBase& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PathExpand_ExpandBase(PathExpand_ExpandBase&& from) noexcept
    : PathExpand_ExpandBase() {
    *this = ::std::move(from);
  }

  inline PathExpand_ExpandBase& operator=(PathExpand_ExpandBase&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PathExpand_ExpandBase& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PathExpand_ExpandBase* internal_default_instance() {
    return reinterpret_cast<const PathExpand_ExpandBase*>(
               &_PathExpand_ExpandBase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(PathExpand_ExpandBase* other);
  friend void swap(PathExpand_ExpandBase& a, PathExpand_ExpandBase& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PathExpand_ExpandBase* New() const final {
    return CreateMaybeMessage<PathExpand_ExpandBase>(NULL);
  }

  PathExpand_ExpandBase* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PathExpand_ExpandBase>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PathExpand_ExpandBase& from);
  void MergeFrom(const PathExpand_ExpandBase& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathExpand_ExpandBase* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .algebra.EdgeExpand edge_expand = 1;
  bool has_edge_expand() const;
  void clear_edge_expand();
  static const int kEdgeExpandFieldNumber = 1;
  private:
  const ::algebra::EdgeExpand& _internal_edge_expand() const;
  public:
  const ::algebra::EdgeExpand& edge_expand() const;
  ::algebra::EdgeExpand* release_edge_expand();
  ::algebra::EdgeExpand* mutable_edge_expand();
  void set_allocated_edge_expand(::algebra::EdgeExpand* edge_expand);

  // .algebra.GetV get_V = 2;
  bool has_get_v() const;
  void clear_get_v();
  static const int kGetVFieldNumber = 2;
  private:
  const ::algebra::GetV& _internal_get_v() const;
  public:
  const ::algebra::GetV& get_v() const;
  ::algebra::GetV* release_get_v();
  ::algebra::GetV* mutable_get_v();
  void set_allocated_get_v(::algebra::GetV* get_v);

  // @@protoc_insertion_point(class_scope:algebra.PathExpand.ExpandBase)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::algebra::EdgeExpand* edge_expand_;
  ::algebra::GetV* get_v_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PathExpand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.PathExpand) */ {
 public:
  PathExpand();
  virtual ~PathExpand();

  PathExpand(const PathExpand& from);

  inline PathExpand& operator=(const PathExpand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PathExpand(PathExpand&& from) noexcept
    : PathExpand() {
    *this = ::std::move(from);
  }

  inline PathExpand& operator=(PathExpand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PathExpand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PathExpand* internal_default_instance() {
    return reinterpret_cast<const PathExpand*>(
               &_PathExpand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(PathExpand* other);
  friend void swap(PathExpand& a, PathExpand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PathExpand* New() const final {
    return CreateMaybeMessage<PathExpand>(NULL);
  }

  PathExpand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PathExpand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PathExpand& from);
  void MergeFrom(const PathExpand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathExpand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PathExpand_ExpandBase ExpandBase;

  typedef PathExpand_PathOpt PathOpt;
  static const PathOpt ARBITRARY =
    PathExpand_PathOpt_ARBITRARY;
  static const PathOpt SIMPLE =
    PathExpand_PathOpt_SIMPLE;
  static inline bool PathOpt_IsValid(int value) {
    return PathExpand_PathOpt_IsValid(value);
  }
  static const PathOpt PathOpt_MIN =
    PathExpand_PathOpt_PathOpt_MIN;
  static const PathOpt PathOpt_MAX =
    PathExpand_PathOpt_PathOpt_MAX;
  static const int PathOpt_ARRAYSIZE =
    PathExpand_PathOpt_PathOpt_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PathOpt_descriptor() {
    return PathExpand_PathOpt_descriptor();
  }
  static inline const ::std::string& PathOpt_Name(PathOpt value) {
    return PathExpand_PathOpt_Name(value);
  }
  static inline bool PathOpt_Parse(const ::std::string& name,
      PathOpt* value) {
    return PathExpand_PathOpt_Parse(name, value);
  }

  typedef PathExpand_ResultOpt ResultOpt;
  static const ResultOpt END_V =
    PathExpand_ResultOpt_END_V;
  static const ResultOpt ALL_V =
    PathExpand_ResultOpt_ALL_V;
  static const ResultOpt ALL_V_E =
    PathExpand_ResultOpt_ALL_V_E;
  static inline bool ResultOpt_IsValid(int value) {
    return PathExpand_ResultOpt_IsValid(value);
  }
  static const ResultOpt ResultOpt_MIN =
    PathExpand_ResultOpt_ResultOpt_MIN;
  static const ResultOpt ResultOpt_MAX =
    PathExpand_ResultOpt_ResultOpt_MAX;
  static const int ResultOpt_ARRAYSIZE =
    PathExpand_ResultOpt_ResultOpt_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResultOpt_descriptor() {
    return PathExpand_ResultOpt_descriptor();
  }
  static inline const ::std::string& ResultOpt_Name(ResultOpt value) {
    return PathExpand_ResultOpt_Name(value);
  }
  static inline bool ResultOpt_Parse(const ::std::string& name,
      ResultOpt* value) {
    return PathExpand_ResultOpt_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .algebra.PathExpand.ExpandBase base = 1;
  bool has_base() const;
  void clear_base();
  static const int kBaseFieldNumber = 1;
  private:
  const ::algebra::PathExpand_ExpandBase& _internal_base() const;
  public:
  const ::algebra::PathExpand_ExpandBase& base() const;
  ::algebra::PathExpand_ExpandBase* release_base();
  ::algebra::PathExpand_ExpandBase* mutable_base();
  void set_allocated_base(::algebra::PathExpand_ExpandBase* base);

  // .common.NameOrId start_tag = 2;
  bool has_start_tag() const;
  void clear_start_tag();
  static const int kStartTagFieldNumber = 2;
  private:
  const ::common::NameOrId& _internal_start_tag() const;
  public:
  const ::common::NameOrId& start_tag() const;
  ::common::NameOrId* release_start_tag();
  ::common::NameOrId* mutable_start_tag();
  void set_allocated_start_tag(::common::NameOrId* start_tag);

  // .common.NameOrId alias = 3;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 3;
  private:
  const ::common::NameOrId& _internal_alias() const;
  public:
  const ::common::NameOrId& alias() const;
  ::common::NameOrId* release_alias();
  ::common::NameOrId* mutable_alias();
  void set_allocated_alias(::common::NameOrId* alias);

  // .algebra.Range hop_range = 4;
  bool has_hop_range() const;
  void clear_hop_range();
  static const int kHopRangeFieldNumber = 4;
  private:
  const ::algebra::Range& _internal_hop_range() const;
  public:
  const ::algebra::Range& hop_range() const;
  ::algebra::Range* release_hop_range();
  ::algebra::Range* mutable_hop_range();
  void set_allocated_hop_range(::algebra::Range* hop_range);

  // .common.Expression condition = 7;
  bool has_condition() const;
  void clear_condition();
  static const int kConditionFieldNumber = 7;
  private:
  const ::common::Expression& _internal_condition() const;
  public:
  const ::common::Expression& condition() const;
  ::common::Expression* release_condition();
  ::common::Expression* mutable_condition();
  void set_allocated_condition(::common::Expression* condition);

  // .algebra.PathExpand.PathOpt path_opt = 5;
  void clear_path_opt();
  static const int kPathOptFieldNumber = 5;
  ::algebra::PathExpand_PathOpt path_opt() const;
  void set_path_opt(::algebra::PathExpand_PathOpt value);

  // .algebra.PathExpand.ResultOpt result_opt = 6;
  void clear_result_opt();
  static const int kResultOptFieldNumber = 6;
  ::algebra::PathExpand_ResultOpt result_opt() const;
  void set_result_opt(::algebra::PathExpand_ResultOpt value);

  // @@protoc_insertion_point(class_scope:algebra.PathExpand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::algebra::PathExpand_ExpandBase* base_;
  ::common::NameOrId* start_tag_;
  ::common::NameOrId* alias_;
  ::algebra::Range* hop_range_;
  ::common::Expression* condition_;
  int path_opt_;
  int result_opt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Apply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.Apply) */ {
 public:
  Apply();
  virtual ~Apply();

  Apply(const Apply& from);

  inline Apply& operator=(const Apply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Apply(Apply&& from) noexcept
    : Apply() {
    *this = ::std::move(from);
  }

  inline Apply& operator=(Apply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Apply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Apply* internal_default_instance() {
    return reinterpret_cast<const Apply*>(
               &_Apply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(Apply* other);
  friend void swap(Apply& a, Apply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Apply* New() const final {
    return CreateMaybeMessage<Apply>(NULL);
  }

  Apply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Apply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Apply& from);
  void MergeFrom(const Apply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Apply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .common.NameOrId tags = 2;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 2;
  ::common::NameOrId* mutable_tags(int index);
  ::google::protobuf::RepeatedPtrField< ::common::NameOrId >*
      mutable_tags();
  const ::common::NameOrId& tags(int index) const;
  ::common::NameOrId* add_tags();
  const ::google::protobuf::RepeatedPtrField< ::common::NameOrId >&
      tags() const;

  // .common.NameOrId alias = 4;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 4;
  private:
  const ::common::NameOrId& _internal_alias() const;
  public:
  const ::common::NameOrId& alias() const;
  ::common::NameOrId* release_alias();
  ::common::NameOrId* mutable_alias();
  void set_allocated_alias(::common::NameOrId* alias);

  // .algebra.Join.JoinKind join_kind = 1;
  void clear_join_kind();
  static const int kJoinKindFieldNumber = 1;
  ::algebra::Join_JoinKind join_kind() const;
  void set_join_kind(::algebra::Join_JoinKind value);

  // int32 subtask = 3;
  void clear_subtask();
  static const int kSubtaskFieldNumber = 3;
  ::google::protobuf::int32 subtask() const;
  void set_subtask(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:algebra.Apply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::common::NameOrId > tags_;
  ::common::NameOrId* alias_;
  int join_kind_;
  ::google::protobuf::int32 subtask_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SegmentApply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.SegmentApply) */ {
 public:
  SegmentApply();
  virtual ~SegmentApply();

  SegmentApply(const SegmentApply& from);

  inline SegmentApply& operator=(const SegmentApply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SegmentApply(SegmentApply&& from) noexcept
    : SegmentApply() {
    *this = ::std::move(from);
  }

  inline SegmentApply& operator=(SegmentApply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SegmentApply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SegmentApply* internal_default_instance() {
    return reinterpret_cast<const SegmentApply*>(
               &_SegmentApply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(SegmentApply* other);
  friend void swap(SegmentApply& a, SegmentApply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SegmentApply* New() const final {
    return CreateMaybeMessage<SegmentApply>(NULL);
  }

  SegmentApply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SegmentApply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SegmentApply& from);
  void MergeFrom(const SegmentApply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SegmentApply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .common.NameOrId keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  ::common::NameOrId* mutable_keys(int index);
  ::google::protobuf::RepeatedPtrField< ::common::NameOrId >*
      mutable_keys();
  const ::common::NameOrId& keys(int index) const;
  ::common::NameOrId* add_keys();
  const ::google::protobuf::RepeatedPtrField< ::common::NameOrId >&
      keys() const;

  // .algebra.Apply apply_subtask = 2;
  bool has_apply_subtask() const;
  void clear_apply_subtask();
  static const int kApplySubtaskFieldNumber = 2;
  private:
  const ::algebra::Apply& _internal_apply_subtask() const;
  public:
  const ::algebra::Apply& apply_subtask() const;
  ::algebra::Apply* release_apply_subtask();
  ::algebra::Apply* mutable_apply_subtask();
  void set_allocated_apply_subtask(::algebra::Apply* apply_subtask);

  // @@protoc_insertion_point(class_scope:algebra.SegmentApply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::common::NameOrId > keys_;
  ::algebra::Apply* apply_subtask_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pattern_Binder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.Pattern.Binder) */ {
 public:
  Pattern_Binder();
  virtual ~Pattern_Binder();

  Pattern_Binder(const Pattern_Binder& from);

  inline Pattern_Binder& operator=(const Pattern_Binder& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pattern_Binder(Pattern_Binder&& from) noexcept
    : Pattern_Binder() {
    *this = ::std::move(from);
  }

  inline Pattern_Binder& operator=(Pattern_Binder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pattern_Binder& default_instance();

  enum ItemCase {
    kEdge = 1,
    kPath = 2,
    kVertex = 3,
    kSelect = 4,
    ITEM_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pattern_Binder* internal_default_instance() {
    return reinterpret_cast<const Pattern_Binder*>(
               &_Pattern_Binder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(Pattern_Binder* other);
  friend void swap(Pattern_Binder& a, Pattern_Binder& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pattern_Binder* New() const final {
    return CreateMaybeMessage<Pattern_Binder>(NULL);
  }

  Pattern_Binder* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Pattern_Binder>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Pattern_Binder& from);
  void MergeFrom(const Pattern_Binder& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pattern_Binder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .algebra.EdgeExpand edge = 1;
  bool has_edge() const;
  void clear_edge();
  static const int kEdgeFieldNumber = 1;
  private:
  const ::algebra::EdgeExpand& _internal_edge() const;
  public:
  const ::algebra::EdgeExpand& edge() const;
  ::algebra::EdgeExpand* release_edge();
  ::algebra::EdgeExpand* mutable_edge();
  void set_allocated_edge(::algebra::EdgeExpand* edge);

  // .algebra.PathExpand path = 2;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 2;
  private:
  const ::algebra::PathExpand& _internal_path() const;
  public:
  const ::algebra::PathExpand& path() const;
  ::algebra::PathExpand* release_path();
  ::algebra::PathExpand* mutable_path();
  void set_allocated_path(::algebra::PathExpand* path);

  // .algebra.GetV vertex = 3;
  bool has_vertex() const;
  void clear_vertex();
  static const int kVertexFieldNumber = 3;
  private:
  const ::algebra::GetV& _internal_vertex() const;
  public:
  const ::algebra::GetV& vertex() const;
  ::algebra::GetV* release_vertex();
  ::algebra::GetV* mutable_vertex();
  void set_allocated_vertex(::algebra::GetV* vertex);

  // .algebra.Select select = 4;
  bool has_select() const;
  void clear_select();
  static const int kSelectFieldNumber = 4;
  private:
  const ::algebra::Select& _internal_select() const;
  public:
  const ::algebra::Select& select() const;
  ::algebra::Select* release_select();
  ::algebra::Select* mutable_select();
  void set_allocated_select(::algebra::Select* select);

  void clear_item();
  ItemCase item_case() const;
  // @@protoc_insertion_point(class_scope:algebra.Pattern.Binder)
 private:
  void set_has_edge();
  void set_has_path();
  void set_has_vertex();
  void set_has_select();

  inline bool has_item() const;
  inline void clear_has_item();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ItemUnion {
    ItemUnion() {}
    ::algebra::EdgeExpand* edge_;
    ::algebra::PathExpand* path_;
    ::algebra::GetV* vertex_;
    ::algebra::Select* select_;
  } item_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pattern_Sentence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.Pattern.Sentence) */ {
 public:
  Pattern_Sentence();
  virtual ~Pattern_Sentence();

  Pattern_Sentence(const Pattern_Sentence& from);

  inline Pattern_Sentence& operator=(const Pattern_Sentence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pattern_Sentence(Pattern_Sentence&& from) noexcept
    : Pattern_Sentence() {
    *this = ::std::move(from);
  }

  inline Pattern_Sentence& operator=(Pattern_Sentence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pattern_Sentence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pattern_Sentence* internal_default_instance() {
    return reinterpret_cast<const Pattern_Sentence*>(
               &_Pattern_Sentence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(Pattern_Sentence* other);
  friend void swap(Pattern_Sentence& a, Pattern_Sentence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pattern_Sentence* New() const final {
    return CreateMaybeMessage<Pattern_Sentence>(NULL);
  }

  Pattern_Sentence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Pattern_Sentence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Pattern_Sentence& from);
  void MergeFrom(const Pattern_Sentence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pattern_Sentence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .algebra.Pattern.Binder binders = 2;
  int binders_size() const;
  void clear_binders();
  static const int kBindersFieldNumber = 2;
  ::algebra::Pattern_Binder* mutable_binders(int index);
  ::google::protobuf::RepeatedPtrField< ::algebra::Pattern_Binder >*
      mutable_binders();
  const ::algebra::Pattern_Binder& binders(int index) const;
  ::algebra::Pattern_Binder* add_binders();
  const ::google::protobuf::RepeatedPtrField< ::algebra::Pattern_Binder >&
      binders() const;

  // .common.NameOrId start = 1;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 1;
  private:
  const ::common::NameOrId& _internal_start() const;
  public:
  const ::common::NameOrId& start() const;
  ::common::NameOrId* release_start();
  ::common::NameOrId* mutable_start();
  void set_allocated_start(::common::NameOrId* start);

  // .common.NameOrId end = 3;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 3;
  private:
  const ::common::NameOrId& _internal_end() const;
  public:
  const ::common::NameOrId& end() const;
  ::common::NameOrId* release_end();
  ::common::NameOrId* mutable_end();
  void set_allocated_end(::common::NameOrId* end);

  // .algebra.Join.JoinKind join_kind = 4;
  void clear_join_kind();
  static const int kJoinKindFieldNumber = 4;
  ::algebra::Join_JoinKind join_kind() const;
  void set_join_kind(::algebra::Join_JoinKind value);

  // @@protoc_insertion_point(class_scope:algebra.Pattern.Sentence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::algebra::Pattern_Binder > binders_;
  ::common::NameOrId* start_;
  ::common::NameOrId* end_;
  int join_kind_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pattern : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.Pattern) */ {
 public:
  Pattern();
  virtual ~Pattern();

  Pattern(const Pattern& from);

  inline Pattern& operator=(const Pattern& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pattern(Pattern&& from) noexcept
    : Pattern() {
    *this = ::std::move(from);
  }

  inline Pattern& operator=(Pattern&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pattern& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pattern* internal_default_instance() {
    return reinterpret_cast<const Pattern*>(
               &_Pattern_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(Pattern* other);
  friend void swap(Pattern& a, Pattern& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pattern* New() const final {
    return CreateMaybeMessage<Pattern>(NULL);
  }

  Pattern* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Pattern>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Pattern& from);
  void MergeFrom(const Pattern& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pattern* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Pattern_Binder Binder;
  typedef Pattern_Sentence Sentence;

  // accessors -------------------------------------------------------

  // repeated .algebra.Pattern.Sentence sentences = 1;
  int sentences_size() const;
  void clear_sentences();
  static const int kSentencesFieldNumber = 1;
  ::algebra::Pattern_Sentence* mutable_sentences(int index);
  ::google::protobuf::RepeatedPtrField< ::algebra::Pattern_Sentence >*
      mutable_sentences();
  const ::algebra::Pattern_Sentence& sentences(int index) const;
  ::algebra::Pattern_Sentence* add_sentences();
  const ::google::protobuf::RepeatedPtrField< ::algebra::Pattern_Sentence >&
      sentences() const;

  // repeated .algebra.MetaData meta_data = 2;
  int meta_data_size() const;
  void clear_meta_data();
  static const int kMetaDataFieldNumber = 2;
  ::algebra::MetaData* mutable_meta_data(int index);
  ::google::protobuf::RepeatedPtrField< ::algebra::MetaData >*
      mutable_meta_data();
  const ::algebra::MetaData& meta_data(int index) const;
  ::algebra::MetaData* add_meta_data();
  const ::google::protobuf::RepeatedPtrField< ::algebra::MetaData >&
      meta_data() const;

  // @@protoc_insertion_point(class_scope:algebra.Pattern)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::algebra::Pattern_Sentence > sentences_;
  ::google::protobuf::RepeatedPtrField< ::algebra::MetaData > meta_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sample_SampleByRatio : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.Sample.SampleByRatio) */ {
 public:
  Sample_SampleByRatio();
  virtual ~Sample_SampleByRatio();

  Sample_SampleByRatio(const Sample_SampleByRatio& from);

  inline Sample_SampleByRatio& operator=(const Sample_SampleByRatio& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sample_SampleByRatio(Sample_SampleByRatio&& from) noexcept
    : Sample_SampleByRatio() {
    *this = ::std::move(from);
  }

  inline Sample_SampleByRatio& operator=(Sample_SampleByRatio&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sample_SampleByRatio& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sample_SampleByRatio* internal_default_instance() {
    return reinterpret_cast<const Sample_SampleByRatio*>(
               &_Sample_SampleByRatio_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(Sample_SampleByRatio* other);
  friend void swap(Sample_SampleByRatio& a, Sample_SampleByRatio& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sample_SampleByRatio* New() const final {
    return CreateMaybeMessage<Sample_SampleByRatio>(NULL);
  }

  Sample_SampleByRatio* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Sample_SampleByRatio>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Sample_SampleByRatio& from);
  void MergeFrom(const Sample_SampleByRatio& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sample_SampleByRatio* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double ratio = 1;
  void clear_ratio();
  static const int kRatioFieldNumber = 1;
  double ratio() const;
  void set_ratio(double value);

  // @@protoc_insertion_point(class_scope:algebra.Sample.SampleByRatio)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double ratio_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sample_SampleByNum : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.Sample.SampleByNum) */ {
 public:
  Sample_SampleByNum();
  virtual ~Sample_SampleByNum();

  Sample_SampleByNum(const Sample_SampleByNum& from);

  inline Sample_SampleByNum& operator=(const Sample_SampleByNum& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sample_SampleByNum(Sample_SampleByNum&& from) noexcept
    : Sample_SampleByNum() {
    *this = ::std::move(from);
  }

  inline Sample_SampleByNum& operator=(Sample_SampleByNum&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sample_SampleByNum& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sample_SampleByNum* internal_default_instance() {
    return reinterpret_cast<const Sample_SampleByNum*>(
               &_Sample_SampleByNum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(Sample_SampleByNum* other);
  friend void swap(Sample_SampleByNum& a, Sample_SampleByNum& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sample_SampleByNum* New() const final {
    return CreateMaybeMessage<Sample_SampleByNum>(NULL);
  }

  Sample_SampleByNum* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Sample_SampleByNum>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Sample_SampleByNum& from);
  void MergeFrom(const Sample_SampleByNum& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sample_SampleByNum* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 num = 1;
  void clear_num();
  static const int kNumFieldNumber = 1;
  ::google::protobuf::int32 num() const;
  void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:algebra.Sample.SampleByNum)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 num_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sample_SampleType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.Sample.SampleType) */ {
 public:
  Sample_SampleType();
  virtual ~Sample_SampleType();

  Sample_SampleType(const Sample_SampleType& from);

  inline Sample_SampleType& operator=(const Sample_SampleType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sample_SampleType(Sample_SampleType&& from) noexcept
    : Sample_SampleType() {
    *this = ::std::move(from);
  }

  inline Sample_SampleType& operator=(Sample_SampleType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sample_SampleType& default_instance();

  enum InnerCase {
    kSampleByRatio = 1,
    kSampleByNum = 2,
    INNER_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sample_SampleType* internal_default_instance() {
    return reinterpret_cast<const Sample_SampleType*>(
               &_Sample_SampleType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(Sample_SampleType* other);
  friend void swap(Sample_SampleType& a, Sample_SampleType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sample_SampleType* New() const final {
    return CreateMaybeMessage<Sample_SampleType>(NULL);
  }

  Sample_SampleType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Sample_SampleType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Sample_SampleType& from);
  void MergeFrom(const Sample_SampleType& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sample_SampleType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .algebra.Sample.SampleByRatio sample_by_ratio = 1;
  bool has_sample_by_ratio() const;
  void clear_sample_by_ratio();
  static const int kSampleByRatioFieldNumber = 1;
  private:
  const ::algebra::Sample_SampleByRatio& _internal_sample_by_ratio() const;
  public:
  const ::algebra::Sample_SampleByRatio& sample_by_ratio() const;
  ::algebra::Sample_SampleByRatio* release_sample_by_ratio();
  ::algebra::Sample_SampleByRatio* mutable_sample_by_ratio();
  void set_allocated_sample_by_ratio(::algebra::Sample_SampleByRatio* sample_by_ratio);

  // .algebra.Sample.SampleByNum sample_by_num = 2;
  bool has_sample_by_num() const;
  void clear_sample_by_num();
  static const int kSampleByNumFieldNumber = 2;
  private:
  const ::algebra::Sample_SampleByNum& _internal_sample_by_num() const;
  public:
  const ::algebra::Sample_SampleByNum& sample_by_num() const;
  ::algebra::Sample_SampleByNum* release_sample_by_num();
  ::algebra::Sample_SampleByNum* mutable_sample_by_num();
  void set_allocated_sample_by_num(::algebra::Sample_SampleByNum* sample_by_num);

  void clear_inner();
  InnerCase inner_case() const;
  // @@protoc_insertion_point(class_scope:algebra.Sample.SampleType)
 private:
  void set_has_sample_by_ratio();
  void set_has_sample_by_num();

  inline bool has_inner() const;
  inline void clear_has_inner();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union InnerUnion {
    InnerUnion() {}
    ::algebra::Sample_SampleByRatio* sample_by_ratio_;
    ::algebra::Sample_SampleByNum* sample_by_num_;
  } inner_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sample : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.Sample) */ {
 public:
  Sample();
  virtual ~Sample();

  Sample(const Sample& from);

  inline Sample& operator=(const Sample& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sample(Sample&& from) noexcept
    : Sample() {
    *this = ::std::move(from);
  }

  inline Sample& operator=(Sample&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sample& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sample* internal_default_instance() {
    return reinterpret_cast<const Sample*>(
               &_Sample_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(Sample* other);
  friend void swap(Sample& a, Sample& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sample* New() const final {
    return CreateMaybeMessage<Sample>(NULL);
  }

  Sample* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Sample>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Sample& from);
  void MergeFrom(const Sample& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sample* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Sample_SampleByRatio SampleByRatio;
  typedef Sample_SampleByNum SampleByNum;
  typedef Sample_SampleType SampleType;

  // accessors -------------------------------------------------------

  // .algebra.Sample.SampleType sample_type = 1;
  bool has_sample_type() const;
  void clear_sample_type();
  static const int kSampleTypeFieldNumber = 1;
  private:
  const ::algebra::Sample_SampleType& _internal_sample_type() const;
  public:
  const ::algebra::Sample_SampleType& sample_type() const;
  ::algebra::Sample_SampleType* release_sample_type();
  ::algebra::Sample_SampleType* mutable_sample_type();
  void set_allocated_sample_type(::algebra::Sample_SampleType* sample_type);

  // .google.protobuf.Int32Value seed = 2;
  bool has_seed() const;
  void clear_seed();
  static const int kSeedFieldNumber = 2;
  private:
  const ::google::protobuf::Int32Value& _internal_seed() const;
  public:
  const ::google::protobuf::Int32Value& seed() const;
  ::google::protobuf::Int32Value* release_seed();
  ::google::protobuf::Int32Value* mutable_seed();
  void set_allocated_seed(::google::protobuf::Int32Value* seed);

  // .common.Variable sample_weight = 3;
  bool has_sample_weight() const;
  void clear_sample_weight();
  static const int kSampleWeightFieldNumber = 3;
  private:
  const ::common::Variable& _internal_sample_weight() const;
  public:
  const ::common::Variable& sample_weight() const;
  ::common::Variable* release_sample_weight();
  ::common::Variable* mutable_sample_weight();
  void set_allocated_sample_weight(::common::Variable* sample_weight);

  // @@protoc_insertion_point(class_scope:algebra.Sample)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::algebra::Sample_SampleType* sample_type_;
  ::google::protobuf::Int32Value* seed_;
  ::common::Variable* sample_weight_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sink_SinkTarget : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.Sink.SinkTarget) */ {
 public:
  Sink_SinkTarget();
  virtual ~Sink_SinkTarget();

  Sink_SinkTarget(const Sink_SinkTarget& from);

  inline Sink_SinkTarget& operator=(const Sink_SinkTarget& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sink_SinkTarget(Sink_SinkTarget&& from) noexcept
    : Sink_SinkTarget() {
    *this = ::std::move(from);
  }

  inline Sink_SinkTarget& operator=(Sink_SinkTarget&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sink_SinkTarget& default_instance();

  enum InnerCase {
    kSinkDefault = 1,
    kSinkVineyard = 2,
    INNER_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sink_SinkTarget* internal_default_instance() {
    return reinterpret_cast<const Sink_SinkTarget*>(
               &_Sink_SinkTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(Sink_SinkTarget* other);
  friend void swap(Sink_SinkTarget& a, Sink_SinkTarget& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sink_SinkTarget* New() const final {
    return CreateMaybeMessage<Sink_SinkTarget>(NULL);
  }

  Sink_SinkTarget* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Sink_SinkTarget>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Sink_SinkTarget& from);
  void MergeFrom(const Sink_SinkTarget& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sink_SinkTarget* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .algebra.SinkDefault sink_default = 1;
  bool has_sink_default() const;
  void clear_sink_default();
  static const int kSinkDefaultFieldNumber = 1;
  private:
  const ::algebra::SinkDefault& _internal_sink_default() const;
  public:
  const ::algebra::SinkDefault& sink_default() const;
  ::algebra::SinkDefault* release_sink_default();
  ::algebra::SinkDefault* mutable_sink_default();
  void set_allocated_sink_default(::algebra::SinkDefault* sink_default);

  // .algebra.SinkVineyard sink_vineyard = 2;
  bool has_sink_vineyard() const;
  void clear_sink_vineyard();
  static const int kSinkVineyardFieldNumber = 2;
  private:
  const ::algebra::SinkVineyard& _internal_sink_vineyard() const;
  public:
  const ::algebra::SinkVineyard& sink_vineyard() const;
  ::algebra::SinkVineyard* release_sink_vineyard();
  ::algebra::SinkVineyard* mutable_sink_vineyard();
  void set_allocated_sink_vineyard(::algebra::SinkVineyard* sink_vineyard);

  void clear_inner();
  InnerCase inner_case() const;
  // @@protoc_insertion_point(class_scope:algebra.Sink.SinkTarget)
 private:
  void set_has_sink_default();
  void set_has_sink_vineyard();

  inline bool has_inner() const;
  inline void clear_has_inner();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union InnerUnion {
    InnerUnion() {}
    ::algebra::SinkDefault* sink_default_;
    ::algebra::SinkVineyard* sink_vineyard_;
  } inner_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sink : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.Sink) */ {
 public:
  Sink();
  virtual ~Sink();

  Sink(const Sink& from);

  inline Sink& operator=(const Sink& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sink(Sink&& from) noexcept
    : Sink() {
    *this = ::std::move(from);
  }

  inline Sink& operator=(Sink&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sink& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sink* internal_default_instance() {
    return reinterpret_cast<const Sink*>(
               &_Sink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(Sink* other);
  friend void swap(Sink& a, Sink& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sink* New() const final {
    return CreateMaybeMessage<Sink>(NULL);
  }

  Sink* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Sink>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Sink& from);
  void MergeFrom(const Sink& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sink* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Sink_SinkTarget SinkTarget;

  // accessors -------------------------------------------------------

  // repeated .common.NameOrIdKey tags = 1;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 1;
  ::common::NameOrIdKey* mutable_tags(int index);
  ::google::protobuf::RepeatedPtrField< ::common::NameOrIdKey >*
      mutable_tags();
  const ::common::NameOrIdKey& tags(int index) const;
  ::common::NameOrIdKey* add_tags();
  const ::google::protobuf::RepeatedPtrField< ::common::NameOrIdKey >&
      tags() const;

  // .algebra.Sink.SinkTarget sink_target = 2;
  bool has_sink_target() const;
  void clear_sink_target();
  static const int kSinkTargetFieldNumber = 2;
  private:
  const ::algebra::Sink_SinkTarget& _internal_sink_target() const;
  public:
  const ::algebra::Sink_SinkTarget& sink_target() const;
  ::algebra::Sink_SinkTarget* release_sink_target();
  ::algebra::Sink_SinkTarget* mutable_sink_target();
  void set_allocated_sink_target(::algebra::Sink_SinkTarget* sink_target);

  // @@protoc_insertion_point(class_scope:algebra.Sink)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::common::NameOrIdKey > tags_;
  ::algebra::Sink_SinkTarget* sink_target_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SinkDefault_IdNameMapping : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.SinkDefault.IdNameMapping) */ {
 public:
  SinkDefault_IdNameMapping();
  virtual ~SinkDefault_IdNameMapping();

  SinkDefault_IdNameMapping(const SinkDefault_IdNameMapping& from);

  inline SinkDefault_IdNameMapping& operator=(const SinkDefault_IdNameMapping& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SinkDefault_IdNameMapping(SinkDefault_IdNameMapping&& from) noexcept
    : SinkDefault_IdNameMapping() {
    *this = ::std::move(from);
  }

  inline SinkDefault_IdNameMapping& operator=(SinkDefault_IdNameMapping&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SinkDefault_IdNameMapping& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SinkDefault_IdNameMapping* internal_default_instance() {
    return reinterpret_cast<const SinkDefault_IdNameMapping*>(
               &_SinkDefault_IdNameMapping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(SinkDefault_IdNameMapping* other);
  friend void swap(SinkDefault_IdNameMapping& a, SinkDefault_IdNameMapping& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SinkDefault_IdNameMapping* New() const final {
    return CreateMaybeMessage<SinkDefault_IdNameMapping>(NULL);
  }

  SinkDefault_IdNameMapping* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SinkDefault_IdNameMapping>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SinkDefault_IdNameMapping& from);
  void MergeFrom(const SinkDefault_IdNameMapping& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SinkDefault_IdNameMapping* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // .algebra.SinkDefault.MetaType meta_type = 3;
  void clear_meta_type();
  static const int kMetaTypeFieldNumber = 3;
  ::algebra::SinkDefault_MetaType meta_type() const;
  void set_meta_type(::algebra::SinkDefault_MetaType value);

  // @@protoc_insertion_point(class_scope:algebra.SinkDefault.IdNameMapping)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 id_;
  int meta_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SinkDefault : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.SinkDefault) */ {
 public:
  SinkDefault();
  virtual ~SinkDefault();

  SinkDefault(const SinkDefault& from);

  inline SinkDefault& operator=(const SinkDefault& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SinkDefault(SinkDefault&& from) noexcept
    : SinkDefault() {
    *this = ::std::move(from);
  }

  inline SinkDefault& operator=(SinkDefault&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SinkDefault& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SinkDefault* internal_default_instance() {
    return reinterpret_cast<const SinkDefault*>(
               &_SinkDefault_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(SinkDefault* other);
  friend void swap(SinkDefault& a, SinkDefault& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SinkDefault* New() const final {
    return CreateMaybeMessage<SinkDefault>(NULL);
  }

  SinkDefault* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SinkDefault>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SinkDefault& from);
  void MergeFrom(const SinkDefault& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SinkDefault* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SinkDefault_IdNameMapping IdNameMapping;

  typedef SinkDefault_MetaType MetaType;
  static const MetaType ENTITY =
    SinkDefault_MetaType_ENTITY;
  static const MetaType RELATION =
    SinkDefault_MetaType_RELATION;
  static const MetaType COLUMN =
    SinkDefault_MetaType_COLUMN;
  static const MetaType TAG =
    SinkDefault_MetaType_TAG;
  static inline bool MetaType_IsValid(int value) {
    return SinkDefault_MetaType_IsValid(value);
  }
  static const MetaType MetaType_MIN =
    SinkDefault_MetaType_MetaType_MIN;
  static const MetaType MetaType_MAX =
    SinkDefault_MetaType_MetaType_MAX;
  static const int MetaType_ARRAYSIZE =
    SinkDefault_MetaType_MetaType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MetaType_descriptor() {
    return SinkDefault_MetaType_descriptor();
  }
  static inline const ::std::string& MetaType_Name(MetaType value) {
    return SinkDefault_MetaType_Name(value);
  }
  static inline bool MetaType_Parse(const ::std::string& name,
      MetaType* value) {
    return SinkDefault_MetaType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .algebra.SinkDefault.IdNameMapping id_name_mappings = 1;
  int id_name_mappings_size() const;
  void clear_id_name_mappings();
  static const int kIdNameMappingsFieldNumber = 1;
  ::algebra::SinkDefault_IdNameMapping* mutable_id_name_mappings(int index);
  ::google::protobuf::RepeatedPtrField< ::algebra::SinkDefault_IdNameMapping >*
      mutable_id_name_mappings();
  const ::algebra::SinkDefault_IdNameMapping& id_name_mappings(int index) const;
  ::algebra::SinkDefault_IdNameMapping* add_id_name_mappings();
  const ::google::protobuf::RepeatedPtrField< ::algebra::SinkDefault_IdNameMapping >&
      id_name_mappings() const;

  // @@protoc_insertion_point(class_scope:algebra.SinkDefault)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::algebra::SinkDefault_IdNameMapping > id_name_mappings_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SinkVineyard : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.SinkVineyard) */ {
 public:
  SinkVineyard();
  virtual ~SinkVineyard();

  SinkVineyard(const SinkVineyard& from);

  inline SinkVineyard& operator=(const SinkVineyard& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SinkVineyard(SinkVineyard&& from) noexcept
    : SinkVineyard() {
    *this = ::std::move(from);
  }

  inline SinkVineyard& operator=(SinkVineyard&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SinkVineyard& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SinkVineyard* internal_default_instance() {
    return reinterpret_cast<const SinkVineyard*>(
               &_SinkVineyard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(SinkVineyard* other);
  friend void swap(SinkVineyard& a, SinkVineyard& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SinkVineyard* New() const final {
    return CreateMaybeMessage<SinkVineyard>(NULL);
  }

  SinkVineyard* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SinkVineyard>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SinkVineyard& from);
  void MergeFrom(const SinkVineyard& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SinkVineyard* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string graph_name = 1;
  void clear_graph_name();
  static const int kGraphNameFieldNumber = 1;
  const ::std::string& graph_name() const;
  void set_graph_name(const ::std::string& value);
  #if LANG_CXX11
  void set_graph_name(::std::string&& value);
  #endif
  void set_graph_name(const char* value);
  void set_graph_name(const char* value, size_t size);
  ::std::string* mutable_graph_name();
  ::std::string* release_graph_name();
  void set_allocated_graph_name(::std::string* graph_name);

  // .schema.Schema graph_schema = 2;
  bool has_graph_schema() const;
  void clear_graph_schema();
  static const int kGraphSchemaFieldNumber = 2;
  private:
  const ::schema::Schema& _internal_graph_schema() const;
  public:
  const ::schema::Schema& graph_schema() const;
  ::schema::Schema* release_graph_schema();
  ::schema::Schema* mutable_graph_schema();
  void set_allocated_graph_schema(::schema::Schema* graph_schema);

  // @@protoc_insertion_point(class_scope:algebra.SinkVineyard)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr graph_name_;
  ::schema::Schema* graph_schema_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Root : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.Root) */ {
 public:
  Root();
  virtual ~Root();

  Root(const Root& from);

  inline Root& operator=(const Root& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Root(Root&& from) noexcept
    : Root() {
    *this = ::std::move(from);
  }

  inline Root& operator=(Root&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Root& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Root* internal_default_instance() {
    return reinterpret_cast<const Root*>(
               &_Root_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(Root* other);
  friend void swap(Root& a, Root& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Root* New() const final {
    return CreateMaybeMessage<Root>(NULL);
  }

  Root* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Root>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Root& from);
  void MergeFrom(const Root& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Root* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:algebra.Root)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Branch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.Branch) */ {
 public:
  Branch();
  virtual ~Branch();

  Branch(const Branch& from);

  inline Branch& operator=(const Branch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Branch(Branch&& from) noexcept
    : Branch() {
    *this = ::std::move(from);
  }

  inline Branch& operator=(Branch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Branch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Branch* internal_default_instance() {
    return reinterpret_cast<const Branch*>(
               &_Branch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(Branch* other);
  friend void swap(Branch& a, Branch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Branch* New() const final {
    return CreateMaybeMessage<Branch>(NULL);
  }

  Branch* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Branch>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Branch& from);
  void MergeFrom(const Branch& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Branch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:algebra.Branch)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogicalPlan_Operator : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.LogicalPlan.Operator) */ {
 public:
  LogicalPlan_Operator();
  virtual ~LogicalPlan_Operator();

  LogicalPlan_Operator(const LogicalPlan_Operator& from);

  inline LogicalPlan_Operator& operator=(const LogicalPlan_Operator& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogicalPlan_Operator(LogicalPlan_Operator&& from) noexcept
    : LogicalPlan_Operator() {
    *this = ::std::move(from);
  }

  inline LogicalPlan_Operator& operator=(LogicalPlan_Operator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicalPlan_Operator& default_instance();

  enum OprCase {
    kProject = 1,
    kSelect = 2,
    kJoin = 3,
    kUnion = 4,
    kGroupBy = 5,
    kOrderBy = 6,
    kDedup = 7,
    kUnfold = 8,
    kApply = 9,
    kSegApply = 10,
    kScan = 11,
    kLimit = 12,
    kAs = 14,
    kIntersect = 15,
    kSink = 16,
    kRoot = 17,
    kSample = 18,
    kBranch = 19,
    kVertex = 30,
    kEdge = 31,
    kPath = 32,
    kPattern = 35,
    OPR_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogicalPlan_Operator* internal_default_instance() {
    return reinterpret_cast<const LogicalPlan_Operator*>(
               &_LogicalPlan_Operator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(LogicalPlan_Operator* other);
  friend void swap(LogicalPlan_Operator& a, LogicalPlan_Operator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogicalPlan_Operator* New() const final {
    return CreateMaybeMessage<LogicalPlan_Operator>(NULL);
  }

  LogicalPlan_Operator* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogicalPlan_Operator>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogicalPlan_Operator& from);
  void MergeFrom(const LogicalPlan_Operator& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogicalPlan_Operator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .algebra.Project project = 1;
  bool has_project() const;
  void clear_project();
  static const int kProjectFieldNumber = 1;
  private:
  const ::algebra::Project& _internal_project() const;
  public:
  const ::algebra::Project& project() const;
  ::algebra::Project* release_project();
  ::algebra::Project* mutable_project();
  void set_allocated_project(::algebra::Project* project);

  // .algebra.Select select = 2;
  bool has_select() const;
  void clear_select();
  static const int kSelectFieldNumber = 2;
  private:
  const ::algebra::Select& _internal_select() const;
  public:
  const ::algebra::Select& select() const;
  ::algebra::Select* release_select();
  ::algebra::Select* mutable_select();
  void set_allocated_select(::algebra::Select* select);

  // .algebra.Join join = 3;
  bool has_join() const;
  void clear_join();
  static const int kJoinFieldNumber = 3;
  private:
  const ::algebra::Join& _internal_join() const;
  public:
  const ::algebra::Join& join() const;
  ::algebra::Join* release_join();
  ::algebra::Join* mutable_join();
  void set_allocated_join(::algebra::Join* join);

  // .algebra.Union union = 4;
  bool has_union_() const;
  void clear_union_();
  static const int kUnionFieldNumber = 4;
  private:
  const ::algebra::Union& _internal_union_() const;
  public:
  const ::algebra::Union& union_() const;
  ::algebra::Union* release_union_();
  ::algebra::Union* mutable_union_();
  void set_allocated_union_(::algebra::Union* union_);

  // .algebra.GroupBy group_by = 5;
  bool has_group_by() const;
  void clear_group_by();
  static const int kGroupByFieldNumber = 5;
  private:
  const ::algebra::GroupBy& _internal_group_by() const;
  public:
  const ::algebra::GroupBy& group_by() const;
  ::algebra::GroupBy* release_group_by();
  ::algebra::GroupBy* mutable_group_by();
  void set_allocated_group_by(::algebra::GroupBy* group_by);

  // .algebra.OrderBy order_by = 6;
  bool has_order_by() const;
  void clear_order_by();
  static const int kOrderByFieldNumber = 6;
  private:
  const ::algebra::OrderBy& _internal_order_by() const;
  public:
  const ::algebra::OrderBy& order_by() const;
  ::algebra::OrderBy* release_order_by();
  ::algebra::OrderBy* mutable_order_by();
  void set_allocated_order_by(::algebra::OrderBy* order_by);

  // .algebra.Dedup dedup = 7;
  bool has_dedup() const;
  void clear_dedup();
  static const int kDedupFieldNumber = 7;
  private:
  const ::algebra::Dedup& _internal_dedup() const;
  public:
  const ::algebra::Dedup& dedup() const;
  ::algebra::Dedup* release_dedup();
  ::algebra::Dedup* mutable_dedup();
  void set_allocated_dedup(::algebra::Dedup* dedup);

  // .algebra.Unfold unfold = 8;
  bool has_unfold() const;
  void clear_unfold();
  static const int kUnfoldFieldNumber = 8;
  private:
  const ::algebra::Unfold& _internal_unfold() const;
  public:
  const ::algebra::Unfold& unfold() const;
  ::algebra::Unfold* release_unfold();
  ::algebra::Unfold* mutable_unfold();
  void set_allocated_unfold(::algebra::Unfold* unfold);

  // .algebra.Apply apply = 9;
  bool has_apply() const;
  void clear_apply();
  static const int kApplyFieldNumber = 9;
  private:
  const ::algebra::Apply& _internal_apply() const;
  public:
  const ::algebra::Apply& apply() const;
  ::algebra::Apply* release_apply();
  ::algebra::Apply* mutable_apply();
  void set_allocated_apply(::algebra::Apply* apply);

  // .algebra.SegmentApply seg_apply = 10;
  bool has_seg_apply() const;
  void clear_seg_apply();
  static const int kSegApplyFieldNumber = 10;
  private:
  const ::algebra::SegmentApply& _internal_seg_apply() const;
  public:
  const ::algebra::SegmentApply& seg_apply() const;
  ::algebra::SegmentApply* release_seg_apply();
  ::algebra::SegmentApply* mutable_seg_apply();
  void set_allocated_seg_apply(::algebra::SegmentApply* seg_apply);

  // .algebra.Scan scan = 11;
  bool has_scan() const;
  void clear_scan();
  static const int kScanFieldNumber = 11;
  private:
  const ::algebra::Scan& _internal_scan() const;
  public:
  const ::algebra::Scan& scan() const;
  ::algebra::Scan* release_scan();
  ::algebra::Scan* mutable_scan();
  void set_allocated_scan(::algebra::Scan* scan);

  // .algebra.Limit limit = 12;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 12;
  private:
  const ::algebra::Limit& _internal_limit() const;
  public:
  const ::algebra::Limit& limit() const;
  ::algebra::Limit* release_limit();
  ::algebra::Limit* mutable_limit();
  void set_allocated_limit(::algebra::Limit* limit);

  // .algebra.As as = 14;
  bool has_as() const;
  void clear_as();
  static const int kAsFieldNumber = 14;
  private:
  const ::algebra::As& _internal_as() const;
  public:
  const ::algebra::As& as() const;
  ::algebra::As* release_as();
  ::algebra::As* mutable_as();
  void set_allocated_as(::algebra::As* as);

  // .algebra.Intersect intersect = 15;
  bool has_intersect() const;
  void clear_intersect();
  static const int kIntersectFieldNumber = 15;
  private:
  const ::algebra::Intersect& _internal_intersect() const;
  public:
  const ::algebra::Intersect& intersect() const;
  ::algebra::Intersect* release_intersect();
  ::algebra::Intersect* mutable_intersect();
  void set_allocated_intersect(::algebra::Intersect* intersect);

  // .algebra.Sink sink = 16;
  bool has_sink() const;
  void clear_sink();
  static const int kSinkFieldNumber = 16;
  private:
  const ::algebra::Sink& _internal_sink() const;
  public:
  const ::algebra::Sink& sink() const;
  ::algebra::Sink* release_sink();
  ::algebra::Sink* mutable_sink();
  void set_allocated_sink(::algebra::Sink* sink);

  // .algebra.Root root = 17;
  bool has_root() const;
  void clear_root();
  static const int kRootFieldNumber = 17;
  private:
  const ::algebra::Root& _internal_root() const;
  public:
  const ::algebra::Root& root() const;
  ::algebra::Root* release_root();
  ::algebra::Root* mutable_root();
  void set_allocated_root(::algebra::Root* root);

  // .algebra.Sample sample = 18;
  bool has_sample() const;
  void clear_sample();
  static const int kSampleFieldNumber = 18;
  private:
  const ::algebra::Sample& _internal_sample() const;
  public:
  const ::algebra::Sample& sample() const;
  ::algebra::Sample* release_sample();
  ::algebra::Sample* mutable_sample();
  void set_allocated_sample(::algebra::Sample* sample);

  // .algebra.Branch branch = 19;
  bool has_branch() const;
  void clear_branch();
  static const int kBranchFieldNumber = 19;
  private:
  const ::algebra::Branch& _internal_branch() const;
  public:
  const ::algebra::Branch& branch() const;
  ::algebra::Branch* release_branch();
  ::algebra::Branch* mutable_branch();
  void set_allocated_branch(::algebra::Branch* branch);

  // .algebra.GetV vertex = 30;
  bool has_vertex() const;
  void clear_vertex();
  static const int kVertexFieldNumber = 30;
  private:
  const ::algebra::GetV& _internal_vertex() const;
  public:
  const ::algebra::GetV& vertex() const;
  ::algebra::GetV* release_vertex();
  ::algebra::GetV* mutable_vertex();
  void set_allocated_vertex(::algebra::GetV* vertex);

  // .algebra.EdgeExpand edge = 31;
  bool has_edge() const;
  void clear_edge();
  static const int kEdgeFieldNumber = 31;
  private:
  const ::algebra::EdgeExpand& _internal_edge() const;
  public:
  const ::algebra::EdgeExpand& edge() const;
  ::algebra::EdgeExpand* release_edge();
  ::algebra::EdgeExpand* mutable_edge();
  void set_allocated_edge(::algebra::EdgeExpand* edge);

  // .algebra.PathExpand path = 32;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 32;
  private:
  const ::algebra::PathExpand& _internal_path() const;
  public:
  const ::algebra::PathExpand& path() const;
  ::algebra::PathExpand* release_path();
  ::algebra::PathExpand* mutable_path();
  void set_allocated_path(::algebra::PathExpand* path);

  // .algebra.Pattern pattern = 35;
  bool has_pattern() const;
  void clear_pattern();
  static const int kPatternFieldNumber = 35;
  private:
  const ::algebra::Pattern& _internal_pattern() const;
  public:
  const ::algebra::Pattern& pattern() const;
  ::algebra::Pattern* release_pattern();
  ::algebra::Pattern* mutable_pattern();
  void set_allocated_pattern(::algebra::Pattern* pattern);

  void clear_opr();
  OprCase opr_case() const;
  // @@protoc_insertion_point(class_scope:algebra.LogicalPlan.Operator)
 private:
  void set_has_project();
  void set_has_select();
  void set_has_join();
  void set_has_union_();
  void set_has_group_by();
  void set_has_order_by();
  void set_has_dedup();
  void set_has_unfold();
  void set_has_apply();
  void set_has_seg_apply();
  void set_has_scan();
  void set_has_limit();
  void set_has_as();
  void set_has_intersect();
  void set_has_sink();
  void set_has_root();
  void set_has_sample();
  void set_has_branch();
  void set_has_vertex();
  void set_has_edge();
  void set_has_path();
  void set_has_pattern();

  inline bool has_opr() const;
  inline void clear_has_opr();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union OprUnion {
    OprUnion() {}
    ::algebra::Project* project_;
    ::algebra::Select* select_;
    ::algebra::Join* join_;
    ::algebra::Union* union__;
    ::algebra::GroupBy* group_by_;
    ::algebra::OrderBy* order_by_;
    ::algebra::Dedup* dedup_;
    ::algebra::Unfold* unfold_;
    ::algebra::Apply* apply_;
    ::algebra::SegmentApply* seg_apply_;
    ::algebra::Scan* scan_;
    ::algebra::Limit* limit_;
    ::algebra::As* as_;
    ::algebra::Intersect* intersect_;
    ::algebra::Sink* sink_;
    ::algebra::Root* root_;
    ::algebra::Sample* sample_;
    ::algebra::Branch* branch_;
    ::algebra::GetV* vertex_;
    ::algebra::EdgeExpand* edge_;
    ::algebra::PathExpand* path_;
    ::algebra::Pattern* pattern_;
  } opr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogicalPlan_Node : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.LogicalPlan.Node) */ {
 public:
  LogicalPlan_Node();
  virtual ~LogicalPlan_Node();

  LogicalPlan_Node(const LogicalPlan_Node& from);

  inline LogicalPlan_Node& operator=(const LogicalPlan_Node& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogicalPlan_Node(LogicalPlan_Node&& from) noexcept
    : LogicalPlan_Node() {
    *this = ::std::move(from);
  }

  inline LogicalPlan_Node& operator=(LogicalPlan_Node&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicalPlan_Node& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogicalPlan_Node* internal_default_instance() {
    return reinterpret_cast<const LogicalPlan_Node*>(
               &_LogicalPlan_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(LogicalPlan_Node* other);
  friend void swap(LogicalPlan_Node& a, LogicalPlan_Node& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogicalPlan_Node* New() const final {
    return CreateMaybeMessage<LogicalPlan_Node>(NULL);
  }

  LogicalPlan_Node* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogicalPlan_Node>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogicalPlan_Node& from);
  void MergeFrom(const LogicalPlan_Node& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogicalPlan_Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 children = 2;
  int children_size() const;
  void clear_children();
  static const int kChildrenFieldNumber = 2;
  ::google::protobuf::int32 children(int index) const;
  void set_children(int index, ::google::protobuf::int32 value);
  void add_children(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      children() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_children();

  // .algebra.LogicalPlan.Operator opr = 1;
  bool has_opr() const;
  void clear_opr();
  static const int kOprFieldNumber = 1;
  private:
  const ::algebra::LogicalPlan_Operator& _internal_opr() const;
  public:
  const ::algebra::LogicalPlan_Operator& opr() const;
  ::algebra::LogicalPlan_Operator* release_opr();
  ::algebra::LogicalPlan_Operator* mutable_opr();
  void set_allocated_opr(::algebra::LogicalPlan_Operator* opr);

  // @@protoc_insertion_point(class_scope:algebra.LogicalPlan.Node)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > children_;
  mutable int _children_cached_byte_size_;
  ::algebra::LogicalPlan_Operator* opr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogicalPlan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:algebra.LogicalPlan) */ {
 public:
  LogicalPlan();
  virtual ~LogicalPlan();

  LogicalPlan(const LogicalPlan& from);

  inline LogicalPlan& operator=(const LogicalPlan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogicalPlan(LogicalPlan&& from) noexcept
    : LogicalPlan() {
    *this = ::std::move(from);
  }

  inline LogicalPlan& operator=(LogicalPlan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicalPlan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogicalPlan* internal_default_instance() {
    return reinterpret_cast<const LogicalPlan*>(
               &_LogicalPlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(LogicalPlan* other);
  friend void swap(LogicalPlan& a, LogicalPlan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogicalPlan* New() const final {
    return CreateMaybeMessage<LogicalPlan>(NULL);
  }

  LogicalPlan* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogicalPlan>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogicalPlan& from);
  void MergeFrom(const LogicalPlan& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogicalPlan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LogicalPlan_Operator Operator;
  typedef LogicalPlan_Node Node;

  // accessors -------------------------------------------------------

  // repeated .algebra.LogicalPlan.Node nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  ::algebra::LogicalPlan_Node* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::algebra::LogicalPlan_Node >*
      mutable_nodes();
  const ::algebra::LogicalPlan_Node& nodes(int index) const;
  ::algebra::LogicalPlan_Node* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::algebra::LogicalPlan_Node >&
      nodes() const;

  // repeated int32 roots = 2;
  int roots_size() const;
  void clear_roots();
  static const int kRootsFieldNumber = 2;
  ::google::protobuf::int32 roots(int index) const;
  void set_roots(int index, ::google::protobuf::int32 value);
  void add_roots(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      roots() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_roots();

  // @@protoc_insertion_point(class_scope:algebra.LogicalPlan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::algebra::LogicalPlan_Node > nodes_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > roots_;
  mutable int _roots_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_algebra_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MetaData

// .common.IrDataType type = 1;
inline bool MetaData::has_type() const {
  return this != internal_default_instance() && type_ != NULL;
}
inline const ::common::IrDataType& MetaData::_internal_type() const {
  return *type_;
}
inline const ::common::IrDataType& MetaData::type() const {
  const ::common::IrDataType* p = type_;
  // @@protoc_insertion_point(field_get:algebra.MetaData.type)
  return p != NULL ? *p : *reinterpret_cast<const ::common::IrDataType*>(
      &::common::_IrDataType_default_instance_);
}
inline ::common::IrDataType* MetaData::release_type() {
  // @@protoc_insertion_point(field_release:algebra.MetaData.type)
  
  ::common::IrDataType* temp = type_;
  type_ = NULL;
  return temp;
}
inline ::common::IrDataType* MetaData::mutable_type() {
  
  if (type_ == NULL) {
    auto* p = CreateMaybeMessage<::common::IrDataType>(GetArenaNoVirtual());
    type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.MetaData.type)
  return type_;
}
inline void MetaData::set_allocated_type(::common::IrDataType* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(type_);
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:algebra.MetaData.type)
}

// int32 alias = 2;
inline void MetaData::clear_alias() {
  alias_ = 0;
}
inline ::google::protobuf::int32 MetaData::alias() const {
  // @@protoc_insertion_point(field_get:algebra.MetaData.alias)
  return alias_;
}
inline void MetaData::set_alias(::google::protobuf::int32 value) {
  
  alias_ = value;
  // @@protoc_insertion_point(field_set:algebra.MetaData.alias)
}

// -------------------------------------------------------------------

// Project_ExprAlias

// .common.Expression expr = 1;
inline bool Project_ExprAlias::has_expr() const {
  return this != internal_default_instance() && expr_ != NULL;
}
inline const ::common::Expression& Project_ExprAlias::_internal_expr() const {
  return *expr_;
}
inline const ::common::Expression& Project_ExprAlias::expr() const {
  const ::common::Expression* p = expr_;
  // @@protoc_insertion_point(field_get:algebra.Project.ExprAlias.expr)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Expression*>(
      &::common::_Expression_default_instance_);
}
inline ::common::Expression* Project_ExprAlias::release_expr() {
  // @@protoc_insertion_point(field_release:algebra.Project.ExprAlias.expr)
  
  ::common::Expression* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline ::common::Expression* Project_ExprAlias::mutable_expr() {
  
  if (expr_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Expression>(GetArenaNoVirtual());
    expr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.Project.ExprAlias.expr)
  return expr_;
}
inline void Project_ExprAlias::set_allocated_expr(::common::Expression* expr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(expr_);
  }
  if (expr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      expr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, expr, submessage_arena);
    }
    
  } else {
    
  }
  expr_ = expr;
  // @@protoc_insertion_point(field_set_allocated:algebra.Project.ExprAlias.expr)
}

// .common.NameOrId alias = 2;
inline bool Project_ExprAlias::has_alias() const {
  return this != internal_default_instance() && alias_ != NULL;
}
inline const ::common::NameOrId& Project_ExprAlias::_internal_alias() const {
  return *alias_;
}
inline const ::common::NameOrId& Project_ExprAlias::alias() const {
  const ::common::NameOrId* p = alias_;
  // @@protoc_insertion_point(field_get:algebra.Project.ExprAlias.alias)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* Project_ExprAlias::release_alias() {
  // @@protoc_insertion_point(field_release:algebra.Project.ExprAlias.alias)
  
  ::common::NameOrId* temp = alias_;
  alias_ = NULL;
  return temp;
}
inline ::common::NameOrId* Project_ExprAlias::mutable_alias() {
  
  if (alias_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    alias_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.Project.ExprAlias.alias)
  return alias_;
}
inline void Project_ExprAlias::set_allocated_alias(::common::NameOrId* alias) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(alias_);
  }
  if (alias) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      alias = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, alias, submessage_arena);
    }
    
  } else {
    
  }
  alias_ = alias;
  // @@protoc_insertion_point(field_set_allocated:algebra.Project.ExprAlias.alias)
}

// -------------------------------------------------------------------

// Project

// repeated .algebra.Project.ExprAlias mappings = 1;
inline int Project::mappings_size() const {
  return mappings_.size();
}
inline void Project::clear_mappings() {
  mappings_.Clear();
}
inline ::algebra::Project_ExprAlias* Project::mutable_mappings(int index) {
  // @@protoc_insertion_point(field_mutable:algebra.Project.mappings)
  return mappings_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::algebra::Project_ExprAlias >*
Project::mutable_mappings() {
  // @@protoc_insertion_point(field_mutable_list:algebra.Project.mappings)
  return &mappings_;
}
inline const ::algebra::Project_ExprAlias& Project::mappings(int index) const {
  // @@protoc_insertion_point(field_get:algebra.Project.mappings)
  return mappings_.Get(index);
}
inline ::algebra::Project_ExprAlias* Project::add_mappings() {
  // @@protoc_insertion_point(field_add:algebra.Project.mappings)
  return mappings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::algebra::Project_ExprAlias >&
Project::mappings() const {
  // @@protoc_insertion_point(field_list:algebra.Project.mappings)
  return mappings_;
}

// bool is_append = 2;
inline void Project::clear_is_append() {
  is_append_ = false;
}
inline bool Project::is_append() const {
  // @@protoc_insertion_point(field_get:algebra.Project.is_append)
  return is_append_;
}
inline void Project::set_is_append(bool value) {
  
  is_append_ = value;
  // @@protoc_insertion_point(field_set:algebra.Project.is_append)
}

// repeated .algebra.MetaData meta_data = 3;
inline int Project::meta_data_size() const {
  return meta_data_.size();
}
inline void Project::clear_meta_data() {
  meta_data_.Clear();
}
inline ::algebra::MetaData* Project::mutable_meta_data(int index) {
  // @@protoc_insertion_point(field_mutable:algebra.Project.meta_data)
  return meta_data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::algebra::MetaData >*
Project::mutable_meta_data() {
  // @@protoc_insertion_point(field_mutable_list:algebra.Project.meta_data)
  return &meta_data_;
}
inline const ::algebra::MetaData& Project::meta_data(int index) const {
  // @@protoc_insertion_point(field_get:algebra.Project.meta_data)
  return meta_data_.Get(index);
}
inline ::algebra::MetaData* Project::add_meta_data() {
  // @@protoc_insertion_point(field_add:algebra.Project.meta_data)
  return meta_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::algebra::MetaData >&
Project::meta_data() const {
  // @@protoc_insertion_point(field_list:algebra.Project.meta_data)
  return meta_data_;
}

// -------------------------------------------------------------------

// Select

// .common.Expression predicate = 1;
inline bool Select::has_predicate() const {
  return this != internal_default_instance() && predicate_ != NULL;
}
inline const ::common::Expression& Select::_internal_predicate() const {
  return *predicate_;
}
inline const ::common::Expression& Select::predicate() const {
  const ::common::Expression* p = predicate_;
  // @@protoc_insertion_point(field_get:algebra.Select.predicate)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Expression*>(
      &::common::_Expression_default_instance_);
}
inline ::common::Expression* Select::release_predicate() {
  // @@protoc_insertion_point(field_release:algebra.Select.predicate)
  
  ::common::Expression* temp = predicate_;
  predicate_ = NULL;
  return temp;
}
inline ::common::Expression* Select::mutable_predicate() {
  
  if (predicate_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Expression>(GetArenaNoVirtual());
    predicate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.Select.predicate)
  return predicate_;
}
inline void Select::set_allocated_predicate(::common::Expression* predicate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(predicate_);
  }
  if (predicate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      predicate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, predicate, submessage_arena);
    }
    
  } else {
    
  }
  predicate_ = predicate;
  // @@protoc_insertion_point(field_set_allocated:algebra.Select.predicate)
}

// -------------------------------------------------------------------

// Join

// repeated .common.Variable left_keys = 1;
inline int Join::left_keys_size() const {
  return left_keys_.size();
}
inline ::common::Variable* Join::mutable_left_keys(int index) {
  // @@protoc_insertion_point(field_mutable:algebra.Join.left_keys)
  return left_keys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::common::Variable >*
Join::mutable_left_keys() {
  // @@protoc_insertion_point(field_mutable_list:algebra.Join.left_keys)
  return &left_keys_;
}
inline const ::common::Variable& Join::left_keys(int index) const {
  // @@protoc_insertion_point(field_get:algebra.Join.left_keys)
  return left_keys_.Get(index);
}
inline ::common::Variable* Join::add_left_keys() {
  // @@protoc_insertion_point(field_add:algebra.Join.left_keys)
  return left_keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::Variable >&
Join::left_keys() const {
  // @@protoc_insertion_point(field_list:algebra.Join.left_keys)
  return left_keys_;
}

// repeated .common.Variable right_keys = 2;
inline int Join::right_keys_size() const {
  return right_keys_.size();
}
inline ::common::Variable* Join::mutable_right_keys(int index) {
  // @@protoc_insertion_point(field_mutable:algebra.Join.right_keys)
  return right_keys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::common::Variable >*
Join::mutable_right_keys() {
  // @@protoc_insertion_point(field_mutable_list:algebra.Join.right_keys)
  return &right_keys_;
}
inline const ::common::Variable& Join::right_keys(int index) const {
  // @@protoc_insertion_point(field_get:algebra.Join.right_keys)
  return right_keys_.Get(index);
}
inline ::common::Variable* Join::add_right_keys() {
  // @@protoc_insertion_point(field_add:algebra.Join.right_keys)
  return right_keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::Variable >&
Join::right_keys() const {
  // @@protoc_insertion_point(field_list:algebra.Join.right_keys)
  return right_keys_;
}

// .algebra.Join.JoinKind kind = 3;
inline void Join::clear_kind() {
  kind_ = 0;
}
inline ::algebra::Join_JoinKind Join::kind() const {
  // @@protoc_insertion_point(field_get:algebra.Join.kind)
  return static_cast< ::algebra::Join_JoinKind >(kind_);
}
inline void Join::set_kind(::algebra::Join_JoinKind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:algebra.Join.kind)
}

// -------------------------------------------------------------------

// Union

// repeated int32 parents = 1;
inline int Union::parents_size() const {
  return parents_.size();
}
inline void Union::clear_parents() {
  parents_.Clear();
}
inline ::google::protobuf::int32 Union::parents(int index) const {
  // @@protoc_insertion_point(field_get:algebra.Union.parents)
  return parents_.Get(index);
}
inline void Union::set_parents(int index, ::google::protobuf::int32 value) {
  parents_.Set(index, value);
  // @@protoc_insertion_point(field_set:algebra.Union.parents)
}
inline void Union::add_parents(::google::protobuf::int32 value) {
  parents_.Add(value);
  // @@protoc_insertion_point(field_add:algebra.Union.parents)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Union::parents() const {
  // @@protoc_insertion_point(field_list:algebra.Union.parents)
  return parents_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Union::mutable_parents() {
  // @@protoc_insertion_point(field_mutable_list:algebra.Union.parents)
  return &parents_;
}

// -------------------------------------------------------------------

// Intersect

// repeated int32 parents = 1;
inline int Intersect::parents_size() const {
  return parents_.size();
}
inline void Intersect::clear_parents() {
  parents_.Clear();
}
inline ::google::protobuf::int32 Intersect::parents(int index) const {
  // @@protoc_insertion_point(field_get:algebra.Intersect.parents)
  return parents_.Get(index);
}
inline void Intersect::set_parents(int index, ::google::protobuf::int32 value) {
  parents_.Set(index, value);
  // @@protoc_insertion_point(field_set:algebra.Intersect.parents)
}
inline void Intersect::add_parents(::google::protobuf::int32 value) {
  parents_.Add(value);
  // @@protoc_insertion_point(field_add:algebra.Intersect.parents)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Intersect::parents() const {
  // @@protoc_insertion_point(field_list:algebra.Intersect.parents)
  return parents_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Intersect::mutable_parents() {
  // @@protoc_insertion_point(field_mutable_list:algebra.Intersect.parents)
  return &parents_;
}

// .common.NameOrId key = 2;
inline bool Intersect::has_key() const {
  return this != internal_default_instance() && key_ != NULL;
}
inline const ::common::NameOrId& Intersect::_internal_key() const {
  return *key_;
}
inline const ::common::NameOrId& Intersect::key() const {
  const ::common::NameOrId* p = key_;
  // @@protoc_insertion_point(field_get:algebra.Intersect.key)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* Intersect::release_key() {
  // @@protoc_insertion_point(field_release:algebra.Intersect.key)
  
  ::common::NameOrId* temp = key_;
  key_ = NULL;
  return temp;
}
inline ::common::NameOrId* Intersect::mutable_key() {
  
  if (key_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.Intersect.key)
  return key_;
}
inline void Intersect::set_allocated_key(::common::NameOrId* key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(key_);
  }
  if (key) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:algebra.Intersect.key)
}

// -------------------------------------------------------------------

// GroupBy_AggFunc

// repeated .common.Variable vars = 1;
inline int GroupBy_AggFunc::vars_size() const {
  return vars_.size();
}
inline ::common::Variable* GroupBy_AggFunc::mutable_vars(int index) {
  // @@protoc_insertion_point(field_mutable:algebra.GroupBy.AggFunc.vars)
  return vars_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::common::Variable >*
GroupBy_AggFunc::mutable_vars() {
  // @@protoc_insertion_point(field_mutable_list:algebra.GroupBy.AggFunc.vars)
  return &vars_;
}
inline const ::common::Variable& GroupBy_AggFunc::vars(int index) const {
  // @@protoc_insertion_point(field_get:algebra.GroupBy.AggFunc.vars)
  return vars_.Get(index);
}
inline ::common::Variable* GroupBy_AggFunc::add_vars() {
  // @@protoc_insertion_point(field_add:algebra.GroupBy.AggFunc.vars)
  return vars_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::Variable >&
GroupBy_AggFunc::vars() const {
  // @@protoc_insertion_point(field_list:algebra.GroupBy.AggFunc.vars)
  return vars_;
}

// .algebra.GroupBy.AggFunc.Aggregate aggregate = 2;
inline void GroupBy_AggFunc::clear_aggregate() {
  aggregate_ = 0;
}
inline ::algebra::GroupBy_AggFunc_Aggregate GroupBy_AggFunc::aggregate() const {
  // @@protoc_insertion_point(field_get:algebra.GroupBy.AggFunc.aggregate)
  return static_cast< ::algebra::GroupBy_AggFunc_Aggregate >(aggregate_);
}
inline void GroupBy_AggFunc::set_aggregate(::algebra::GroupBy_AggFunc_Aggregate value) {
  
  aggregate_ = value;
  // @@protoc_insertion_point(field_set:algebra.GroupBy.AggFunc.aggregate)
}

// .common.NameOrId alias = 3;
inline bool GroupBy_AggFunc::has_alias() const {
  return this != internal_default_instance() && alias_ != NULL;
}
inline const ::common::NameOrId& GroupBy_AggFunc::_internal_alias() const {
  return *alias_;
}
inline const ::common::NameOrId& GroupBy_AggFunc::alias() const {
  const ::common::NameOrId* p = alias_;
  // @@protoc_insertion_point(field_get:algebra.GroupBy.AggFunc.alias)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* GroupBy_AggFunc::release_alias() {
  // @@protoc_insertion_point(field_release:algebra.GroupBy.AggFunc.alias)
  
  ::common::NameOrId* temp = alias_;
  alias_ = NULL;
  return temp;
}
inline ::common::NameOrId* GroupBy_AggFunc::mutable_alias() {
  
  if (alias_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    alias_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.GroupBy.AggFunc.alias)
  return alias_;
}
inline void GroupBy_AggFunc::set_allocated_alias(::common::NameOrId* alias) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(alias_);
  }
  if (alias) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      alias = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, alias, submessage_arena);
    }
    
  } else {
    
  }
  alias_ = alias;
  // @@protoc_insertion_point(field_set_allocated:algebra.GroupBy.AggFunc.alias)
}

// -------------------------------------------------------------------

// GroupBy_KeyAlias

// .common.Variable key = 1;
inline bool GroupBy_KeyAlias::has_key() const {
  return this != internal_default_instance() && key_ != NULL;
}
inline const ::common::Variable& GroupBy_KeyAlias::_internal_key() const {
  return *key_;
}
inline const ::common::Variable& GroupBy_KeyAlias::key() const {
  const ::common::Variable* p = key_;
  // @@protoc_insertion_point(field_get:algebra.GroupBy.KeyAlias.key)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Variable*>(
      &::common::_Variable_default_instance_);
}
inline ::common::Variable* GroupBy_KeyAlias::release_key() {
  // @@protoc_insertion_point(field_release:algebra.GroupBy.KeyAlias.key)
  
  ::common::Variable* temp = key_;
  key_ = NULL;
  return temp;
}
inline ::common::Variable* GroupBy_KeyAlias::mutable_key() {
  
  if (key_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Variable>(GetArenaNoVirtual());
    key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.GroupBy.KeyAlias.key)
  return key_;
}
inline void GroupBy_KeyAlias::set_allocated_key(::common::Variable* key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(key_);
  }
  if (key) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:algebra.GroupBy.KeyAlias.key)
}

// .common.NameOrId alias = 2;
inline bool GroupBy_KeyAlias::has_alias() const {
  return this != internal_default_instance() && alias_ != NULL;
}
inline const ::common::NameOrId& GroupBy_KeyAlias::_internal_alias() const {
  return *alias_;
}
inline const ::common::NameOrId& GroupBy_KeyAlias::alias() const {
  const ::common::NameOrId* p = alias_;
  // @@protoc_insertion_point(field_get:algebra.GroupBy.KeyAlias.alias)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* GroupBy_KeyAlias::release_alias() {
  // @@protoc_insertion_point(field_release:algebra.GroupBy.KeyAlias.alias)
  
  ::common::NameOrId* temp = alias_;
  alias_ = NULL;
  return temp;
}
inline ::common::NameOrId* GroupBy_KeyAlias::mutable_alias() {
  
  if (alias_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    alias_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.GroupBy.KeyAlias.alias)
  return alias_;
}
inline void GroupBy_KeyAlias::set_allocated_alias(::common::NameOrId* alias) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(alias_);
  }
  if (alias) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      alias = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, alias, submessage_arena);
    }
    
  } else {
    
  }
  alias_ = alias;
  // @@protoc_insertion_point(field_set_allocated:algebra.GroupBy.KeyAlias.alias)
}

// -------------------------------------------------------------------

// GroupBy

// repeated .algebra.GroupBy.KeyAlias mappings = 1;
inline int GroupBy::mappings_size() const {
  return mappings_.size();
}
inline void GroupBy::clear_mappings() {
  mappings_.Clear();
}
inline ::algebra::GroupBy_KeyAlias* GroupBy::mutable_mappings(int index) {
  // @@protoc_insertion_point(field_mutable:algebra.GroupBy.mappings)
  return mappings_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::algebra::GroupBy_KeyAlias >*
GroupBy::mutable_mappings() {
  // @@protoc_insertion_point(field_mutable_list:algebra.GroupBy.mappings)
  return &mappings_;
}
inline const ::algebra::GroupBy_KeyAlias& GroupBy::mappings(int index) const {
  // @@protoc_insertion_point(field_get:algebra.GroupBy.mappings)
  return mappings_.Get(index);
}
inline ::algebra::GroupBy_KeyAlias* GroupBy::add_mappings() {
  // @@protoc_insertion_point(field_add:algebra.GroupBy.mappings)
  return mappings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::algebra::GroupBy_KeyAlias >&
GroupBy::mappings() const {
  // @@protoc_insertion_point(field_list:algebra.GroupBy.mappings)
  return mappings_;
}

// repeated .algebra.GroupBy.AggFunc functions = 2;
inline int GroupBy::functions_size() const {
  return functions_.size();
}
inline void GroupBy::clear_functions() {
  functions_.Clear();
}
inline ::algebra::GroupBy_AggFunc* GroupBy::mutable_functions(int index) {
  // @@protoc_insertion_point(field_mutable:algebra.GroupBy.functions)
  return functions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::algebra::GroupBy_AggFunc >*
GroupBy::mutable_functions() {
  // @@protoc_insertion_point(field_mutable_list:algebra.GroupBy.functions)
  return &functions_;
}
inline const ::algebra::GroupBy_AggFunc& GroupBy::functions(int index) const {
  // @@protoc_insertion_point(field_get:algebra.GroupBy.functions)
  return functions_.Get(index);
}
inline ::algebra::GroupBy_AggFunc* GroupBy::add_functions() {
  // @@protoc_insertion_point(field_add:algebra.GroupBy.functions)
  return functions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::algebra::GroupBy_AggFunc >&
GroupBy::functions() const {
  // @@protoc_insertion_point(field_list:algebra.GroupBy.functions)
  return functions_;
}

// repeated .algebra.MetaData meta_data = 3;
inline int GroupBy::meta_data_size() const {
  return meta_data_.size();
}
inline void GroupBy::clear_meta_data() {
  meta_data_.Clear();
}
inline ::algebra::MetaData* GroupBy::mutable_meta_data(int index) {
  // @@protoc_insertion_point(field_mutable:algebra.GroupBy.meta_data)
  return meta_data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::algebra::MetaData >*
GroupBy::mutable_meta_data() {
  // @@protoc_insertion_point(field_mutable_list:algebra.GroupBy.meta_data)
  return &meta_data_;
}
inline const ::algebra::MetaData& GroupBy::meta_data(int index) const {
  // @@protoc_insertion_point(field_get:algebra.GroupBy.meta_data)
  return meta_data_.Get(index);
}
inline ::algebra::MetaData* GroupBy::add_meta_data() {
  // @@protoc_insertion_point(field_add:algebra.GroupBy.meta_data)
  return meta_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::algebra::MetaData >&
GroupBy::meta_data() const {
  // @@protoc_insertion_point(field_list:algebra.GroupBy.meta_data)
  return meta_data_;
}

// -------------------------------------------------------------------

// OrderBy_OrderingPair

// .common.Variable key = 1;
inline bool OrderBy_OrderingPair::has_key() const {
  return this != internal_default_instance() && key_ != NULL;
}
inline const ::common::Variable& OrderBy_OrderingPair::_internal_key() const {
  return *key_;
}
inline const ::common::Variable& OrderBy_OrderingPair::key() const {
  const ::common::Variable* p = key_;
  // @@protoc_insertion_point(field_get:algebra.OrderBy.OrderingPair.key)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Variable*>(
      &::common::_Variable_default_instance_);
}
inline ::common::Variable* OrderBy_OrderingPair::release_key() {
  // @@protoc_insertion_point(field_release:algebra.OrderBy.OrderingPair.key)
  
  ::common::Variable* temp = key_;
  key_ = NULL;
  return temp;
}
inline ::common::Variable* OrderBy_OrderingPair::mutable_key() {
  
  if (key_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Variable>(GetArenaNoVirtual());
    key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.OrderBy.OrderingPair.key)
  return key_;
}
inline void OrderBy_OrderingPair::set_allocated_key(::common::Variable* key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(key_);
  }
  if (key) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:algebra.OrderBy.OrderingPair.key)
}

// .algebra.OrderBy.OrderingPair.Order order = 2;
inline void OrderBy_OrderingPair::clear_order() {
  order_ = 0;
}
inline ::algebra::OrderBy_OrderingPair_Order OrderBy_OrderingPair::order() const {
  // @@protoc_insertion_point(field_get:algebra.OrderBy.OrderingPair.order)
  return static_cast< ::algebra::OrderBy_OrderingPair_Order >(order_);
}
inline void OrderBy_OrderingPair::set_order(::algebra::OrderBy_OrderingPair_Order value) {
  
  order_ = value;
  // @@protoc_insertion_point(field_set:algebra.OrderBy.OrderingPair.order)
}

// -------------------------------------------------------------------

// OrderBy

// repeated .algebra.OrderBy.OrderingPair pairs = 2;
inline int OrderBy::pairs_size() const {
  return pairs_.size();
}
inline void OrderBy::clear_pairs() {
  pairs_.Clear();
}
inline ::algebra::OrderBy_OrderingPair* OrderBy::mutable_pairs(int index) {
  // @@protoc_insertion_point(field_mutable:algebra.OrderBy.pairs)
  return pairs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::algebra::OrderBy_OrderingPair >*
OrderBy::mutable_pairs() {
  // @@protoc_insertion_point(field_mutable_list:algebra.OrderBy.pairs)
  return &pairs_;
}
inline const ::algebra::OrderBy_OrderingPair& OrderBy::pairs(int index) const {
  // @@protoc_insertion_point(field_get:algebra.OrderBy.pairs)
  return pairs_.Get(index);
}
inline ::algebra::OrderBy_OrderingPair* OrderBy::add_pairs() {
  // @@protoc_insertion_point(field_add:algebra.OrderBy.pairs)
  return pairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::algebra::OrderBy_OrderingPair >&
OrderBy::pairs() const {
  // @@protoc_insertion_point(field_list:algebra.OrderBy.pairs)
  return pairs_;
}

// .algebra.Range limit = 3;
inline bool OrderBy::has_limit() const {
  return this != internal_default_instance() && limit_ != NULL;
}
inline void OrderBy::clear_limit() {
  if (GetArenaNoVirtual() == NULL && limit_ != NULL) {
    delete limit_;
  }
  limit_ = NULL;
}
inline const ::algebra::Range& OrderBy::_internal_limit() const {
  return *limit_;
}
inline const ::algebra::Range& OrderBy::limit() const {
  const ::algebra::Range* p = limit_;
  // @@protoc_insertion_point(field_get:algebra.OrderBy.limit)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::Range*>(
      &::algebra::_Range_default_instance_);
}
inline ::algebra::Range* OrderBy::release_limit() {
  // @@protoc_insertion_point(field_release:algebra.OrderBy.limit)
  
  ::algebra::Range* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline ::algebra::Range* OrderBy::mutable_limit() {
  
  if (limit_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::Range>(GetArenaNoVirtual());
    limit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.OrderBy.limit)
  return limit_;
}
inline void OrderBy::set_allocated_limit(::algebra::Range* limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete limit_;
  }
  if (limit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limit, submessage_arena);
    }
    
  } else {
    
  }
  limit_ = limit;
  // @@protoc_insertion_point(field_set_allocated:algebra.OrderBy.limit)
}

// -------------------------------------------------------------------

// Dedup

// repeated .common.Variable keys = 1;
inline int Dedup::keys_size() const {
  return keys_.size();
}
inline ::common::Variable* Dedup::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:algebra.Dedup.keys)
  return keys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::common::Variable >*
Dedup::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:algebra.Dedup.keys)
  return &keys_;
}
inline const ::common::Variable& Dedup::keys(int index) const {
  // @@protoc_insertion_point(field_get:algebra.Dedup.keys)
  return keys_.Get(index);
}
inline ::common::Variable* Dedup::add_keys() {
  // @@protoc_insertion_point(field_add:algebra.Dedup.keys)
  return keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::Variable >&
Dedup::keys() const {
  // @@protoc_insertion_point(field_list:algebra.Dedup.keys)
  return keys_;
}

// -------------------------------------------------------------------

// Unfold

// .common.NameOrId tag = 1;
inline bool Unfold::has_tag() const {
  return this != internal_default_instance() && tag_ != NULL;
}
inline const ::common::NameOrId& Unfold::_internal_tag() const {
  return *tag_;
}
inline const ::common::NameOrId& Unfold::tag() const {
  const ::common::NameOrId* p = tag_;
  // @@protoc_insertion_point(field_get:algebra.Unfold.tag)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* Unfold::release_tag() {
  // @@protoc_insertion_point(field_release:algebra.Unfold.tag)
  
  ::common::NameOrId* temp = tag_;
  tag_ = NULL;
  return temp;
}
inline ::common::NameOrId* Unfold::mutable_tag() {
  
  if (tag_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    tag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.Unfold.tag)
  return tag_;
}
inline void Unfold::set_allocated_tag(::common::NameOrId* tag) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tag_);
  }
  if (tag) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tag = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tag, submessage_arena);
    }
    
  } else {
    
  }
  tag_ = tag;
  // @@protoc_insertion_point(field_set_allocated:algebra.Unfold.tag)
}

// .common.NameOrId alias = 2;
inline bool Unfold::has_alias() const {
  return this != internal_default_instance() && alias_ != NULL;
}
inline const ::common::NameOrId& Unfold::_internal_alias() const {
  return *alias_;
}
inline const ::common::NameOrId& Unfold::alias() const {
  const ::common::NameOrId* p = alias_;
  // @@protoc_insertion_point(field_get:algebra.Unfold.alias)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* Unfold::release_alias() {
  // @@protoc_insertion_point(field_release:algebra.Unfold.alias)
  
  ::common::NameOrId* temp = alias_;
  alias_ = NULL;
  return temp;
}
inline ::common::NameOrId* Unfold::mutable_alias() {
  
  if (alias_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    alias_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.Unfold.alias)
  return alias_;
}
inline void Unfold::set_allocated_alias(::common::NameOrId* alias) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(alias_);
  }
  if (alias) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      alias = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, alias, submessage_arena);
    }
    
  } else {
    
  }
  alias_ = alias;
  // @@protoc_insertion_point(field_set_allocated:algebra.Unfold.alias)
}

// .algebra.MetaData meta_data = 3;
inline bool Unfold::has_meta_data() const {
  return this != internal_default_instance() && meta_data_ != NULL;
}
inline void Unfold::clear_meta_data() {
  if (GetArenaNoVirtual() == NULL && meta_data_ != NULL) {
    delete meta_data_;
  }
  meta_data_ = NULL;
}
inline const ::algebra::MetaData& Unfold::_internal_meta_data() const {
  return *meta_data_;
}
inline const ::algebra::MetaData& Unfold::meta_data() const {
  const ::algebra::MetaData* p = meta_data_;
  // @@protoc_insertion_point(field_get:algebra.Unfold.meta_data)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::MetaData*>(
      &::algebra::_MetaData_default_instance_);
}
inline ::algebra::MetaData* Unfold::release_meta_data() {
  // @@protoc_insertion_point(field_release:algebra.Unfold.meta_data)
  
  ::algebra::MetaData* temp = meta_data_;
  meta_data_ = NULL;
  return temp;
}
inline ::algebra::MetaData* Unfold::mutable_meta_data() {
  
  if (meta_data_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::MetaData>(GetArenaNoVirtual());
    meta_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.Unfold.meta_data)
  return meta_data_;
}
inline void Unfold::set_allocated_meta_data(::algebra::MetaData* meta_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete meta_data_;
  }
  if (meta_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      meta_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, meta_data, submessage_arena);
    }
    
  } else {
    
  }
  meta_data_ = meta_data;
  // @@protoc_insertion_point(field_set_allocated:algebra.Unfold.meta_data)
}

// -------------------------------------------------------------------

// Range

// int32 lower = 1;
inline void Range::clear_lower() {
  lower_ = 0;
}
inline ::google::protobuf::int32 Range::lower() const {
  // @@protoc_insertion_point(field_get:algebra.Range.lower)
  return lower_;
}
inline void Range::set_lower(::google::protobuf::int32 value) {
  
  lower_ = value;
  // @@protoc_insertion_point(field_set:algebra.Range.lower)
}

// int32 upper = 2;
inline void Range::clear_upper() {
  upper_ = 0;
}
inline ::google::protobuf::int32 Range::upper() const {
  // @@protoc_insertion_point(field_get:algebra.Range.upper)
  return upper_;
}
inline void Range::set_upper(::google::protobuf::int32 value) {
  
  upper_ = value;
  // @@protoc_insertion_point(field_set:algebra.Range.upper)
}

// -------------------------------------------------------------------

// Limit

// .algebra.Range range = 1;
inline bool Limit::has_range() const {
  return this != internal_default_instance() && range_ != NULL;
}
inline void Limit::clear_range() {
  if (GetArenaNoVirtual() == NULL && range_ != NULL) {
    delete range_;
  }
  range_ = NULL;
}
inline const ::algebra::Range& Limit::_internal_range() const {
  return *range_;
}
inline const ::algebra::Range& Limit::range() const {
  const ::algebra::Range* p = range_;
  // @@protoc_insertion_point(field_get:algebra.Limit.range)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::Range*>(
      &::algebra::_Range_default_instance_);
}
inline ::algebra::Range* Limit::release_range() {
  // @@protoc_insertion_point(field_release:algebra.Limit.range)
  
  ::algebra::Range* temp = range_;
  range_ = NULL;
  return temp;
}
inline ::algebra::Range* Limit::mutable_range() {
  
  if (range_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::Range>(GetArenaNoVirtual());
    range_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.Limit.range)
  return range_;
}
inline void Limit::set_allocated_range(::algebra::Range* range) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete range_;
  }
  if (range) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      range = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, range, submessage_arena);
    }
    
  } else {
    
  }
  range_ = range;
  // @@protoc_insertion_point(field_set_allocated:algebra.Limit.range)
}

// -------------------------------------------------------------------

// IndexPredicate_Triplet

// .common.Property key = 1;
inline bool IndexPredicate_Triplet::has_key() const {
  return this != internal_default_instance() && key_ != NULL;
}
inline const ::common::Property& IndexPredicate_Triplet::_internal_key() const {
  return *key_;
}
inline const ::common::Property& IndexPredicate_Triplet::key() const {
  const ::common::Property* p = key_;
  // @@protoc_insertion_point(field_get:algebra.IndexPredicate.Triplet.key)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Property*>(
      &::common::_Property_default_instance_);
}
inline ::common::Property* IndexPredicate_Triplet::release_key() {
  // @@protoc_insertion_point(field_release:algebra.IndexPredicate.Triplet.key)
  
  ::common::Property* temp = key_;
  key_ = NULL;
  return temp;
}
inline ::common::Property* IndexPredicate_Triplet::mutable_key() {
  
  if (key_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Property>(GetArenaNoVirtual());
    key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.IndexPredicate.Triplet.key)
  return key_;
}
inline void IndexPredicate_Triplet::set_allocated_key(::common::Property* key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(key_);
  }
  if (key) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:algebra.IndexPredicate.Triplet.key)
}

// .common.Value value = 2;
inline bool IndexPredicate_Triplet::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline const ::common::Value& IndexPredicate_Triplet::_internal_value() const {
  return *value_;
}
inline const ::common::Value& IndexPredicate_Triplet::value() const {
  const ::common::Value* p = value_;
  // @@protoc_insertion_point(field_get:algebra.IndexPredicate.Triplet.value)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Value*>(
      &::common::_Value_default_instance_);
}
inline ::common::Value* IndexPredicate_Triplet::release_value() {
  // @@protoc_insertion_point(field_release:algebra.IndexPredicate.Triplet.value)
  
  ::common::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::common::Value* IndexPredicate_Triplet::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Value>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.IndexPredicate.Triplet.value)
  return value_;
}
inline void IndexPredicate_Triplet::set_allocated_value(::common::Value* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:algebra.IndexPredicate.Triplet.value)
}

// .common.None cmp = 3;
inline bool IndexPredicate_Triplet::has_cmp() const {
  return this != internal_default_instance() && cmp_ != NULL;
}
inline const ::common::None& IndexPredicate_Triplet::_internal_cmp() const {
  return *cmp_;
}
inline const ::common::None& IndexPredicate_Triplet::cmp() const {
  const ::common::None* p = cmp_;
  // @@protoc_insertion_point(field_get:algebra.IndexPredicate.Triplet.cmp)
  return p != NULL ? *p : *reinterpret_cast<const ::common::None*>(
      &::common::_None_default_instance_);
}
inline ::common::None* IndexPredicate_Triplet::release_cmp() {
  // @@protoc_insertion_point(field_release:algebra.IndexPredicate.Triplet.cmp)
  
  ::common::None* temp = cmp_;
  cmp_ = NULL;
  return temp;
}
inline ::common::None* IndexPredicate_Triplet::mutable_cmp() {
  
  if (cmp_ == NULL) {
    auto* p = CreateMaybeMessage<::common::None>(GetArenaNoVirtual());
    cmp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.IndexPredicate.Triplet.cmp)
  return cmp_;
}
inline void IndexPredicate_Triplet::set_allocated_cmp(::common::None* cmp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(cmp_);
  }
  if (cmp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cmp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cmp, submessage_arena);
    }
    
  } else {
    
  }
  cmp_ = cmp;
  // @@protoc_insertion_point(field_set_allocated:algebra.IndexPredicate.Triplet.cmp)
}

// -------------------------------------------------------------------

// IndexPredicate_AndPredicate

// repeated .algebra.IndexPredicate.Triplet predicates = 1;
inline int IndexPredicate_AndPredicate::predicates_size() const {
  return predicates_.size();
}
inline void IndexPredicate_AndPredicate::clear_predicates() {
  predicates_.Clear();
}
inline ::algebra::IndexPredicate_Triplet* IndexPredicate_AndPredicate::mutable_predicates(int index) {
  // @@protoc_insertion_point(field_mutable:algebra.IndexPredicate.AndPredicate.predicates)
  return predicates_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::algebra::IndexPredicate_Triplet >*
IndexPredicate_AndPredicate::mutable_predicates() {
  // @@protoc_insertion_point(field_mutable_list:algebra.IndexPredicate.AndPredicate.predicates)
  return &predicates_;
}
inline const ::algebra::IndexPredicate_Triplet& IndexPredicate_AndPredicate::predicates(int index) const {
  // @@protoc_insertion_point(field_get:algebra.IndexPredicate.AndPredicate.predicates)
  return predicates_.Get(index);
}
inline ::algebra::IndexPredicate_Triplet* IndexPredicate_AndPredicate::add_predicates() {
  // @@protoc_insertion_point(field_add:algebra.IndexPredicate.AndPredicate.predicates)
  return predicates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::algebra::IndexPredicate_Triplet >&
IndexPredicate_AndPredicate::predicates() const {
  // @@protoc_insertion_point(field_list:algebra.IndexPredicate.AndPredicate.predicates)
  return predicates_;
}

// -------------------------------------------------------------------

// IndexPredicate

// repeated .algebra.IndexPredicate.AndPredicate or_predicates = 1;
inline int IndexPredicate::or_predicates_size() const {
  return or_predicates_.size();
}
inline void IndexPredicate::clear_or_predicates() {
  or_predicates_.Clear();
}
inline ::algebra::IndexPredicate_AndPredicate* IndexPredicate::mutable_or_predicates(int index) {
  // @@protoc_insertion_point(field_mutable:algebra.IndexPredicate.or_predicates)
  return or_predicates_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::algebra::IndexPredicate_AndPredicate >*
IndexPredicate::mutable_or_predicates() {
  // @@protoc_insertion_point(field_mutable_list:algebra.IndexPredicate.or_predicates)
  return &or_predicates_;
}
inline const ::algebra::IndexPredicate_AndPredicate& IndexPredicate::or_predicates(int index) const {
  // @@protoc_insertion_point(field_get:algebra.IndexPredicate.or_predicates)
  return or_predicates_.Get(index);
}
inline ::algebra::IndexPredicate_AndPredicate* IndexPredicate::add_or_predicates() {
  // @@protoc_insertion_point(field_add:algebra.IndexPredicate.or_predicates)
  return or_predicates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::algebra::IndexPredicate_AndPredicate >&
IndexPredicate::or_predicates() const {
  // @@protoc_insertion_point(field_list:algebra.IndexPredicate.or_predicates)
  return or_predicates_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// QueryParams

// repeated .common.NameOrId tables = 1;
inline int QueryParams::tables_size() const {
  return tables_.size();
}
inline ::common::NameOrId* QueryParams::mutable_tables(int index) {
  // @@protoc_insertion_point(field_mutable:algebra.QueryParams.tables)
  return tables_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::common::NameOrId >*
QueryParams::mutable_tables() {
  // @@protoc_insertion_point(field_mutable_list:algebra.QueryParams.tables)
  return &tables_;
}
inline const ::common::NameOrId& QueryParams::tables(int index) const {
  // @@protoc_insertion_point(field_get:algebra.QueryParams.tables)
  return tables_.Get(index);
}
inline ::common::NameOrId* QueryParams::add_tables() {
  // @@protoc_insertion_point(field_add:algebra.QueryParams.tables)
  return tables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::NameOrId >&
QueryParams::tables() const {
  // @@protoc_insertion_point(field_list:algebra.QueryParams.tables)
  return tables_;
}

// repeated .common.NameOrId columns = 2;
inline int QueryParams::columns_size() const {
  return columns_.size();
}
inline ::common::NameOrId* QueryParams::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:algebra.QueryParams.columns)
  return columns_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::common::NameOrId >*
QueryParams::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:algebra.QueryParams.columns)
  return &columns_;
}
inline const ::common::NameOrId& QueryParams::columns(int index) const {
  // @@protoc_insertion_point(field_get:algebra.QueryParams.columns)
  return columns_.Get(index);
}
inline ::common::NameOrId* QueryParams::add_columns() {
  // @@protoc_insertion_point(field_add:algebra.QueryParams.columns)
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::NameOrId >&
QueryParams::columns() const {
  // @@protoc_insertion_point(field_list:algebra.QueryParams.columns)
  return columns_;
}

// bool is_all_columns = 3;
inline void QueryParams::clear_is_all_columns() {
  is_all_columns_ = false;
}
inline bool QueryParams::is_all_columns() const {
  // @@protoc_insertion_point(field_get:algebra.QueryParams.is_all_columns)
  return is_all_columns_;
}
inline void QueryParams::set_is_all_columns(bool value) {
  
  is_all_columns_ = value;
  // @@protoc_insertion_point(field_set:algebra.QueryParams.is_all_columns)
}

// .algebra.Range limit = 4;
inline bool QueryParams::has_limit() const {
  return this != internal_default_instance() && limit_ != NULL;
}
inline void QueryParams::clear_limit() {
  if (GetArenaNoVirtual() == NULL && limit_ != NULL) {
    delete limit_;
  }
  limit_ = NULL;
}
inline const ::algebra::Range& QueryParams::_internal_limit() const {
  return *limit_;
}
inline const ::algebra::Range& QueryParams::limit() const {
  const ::algebra::Range* p = limit_;
  // @@protoc_insertion_point(field_get:algebra.QueryParams.limit)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::Range*>(
      &::algebra::_Range_default_instance_);
}
inline ::algebra::Range* QueryParams::release_limit() {
  // @@protoc_insertion_point(field_release:algebra.QueryParams.limit)
  
  ::algebra::Range* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline ::algebra::Range* QueryParams::mutable_limit() {
  
  if (limit_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::Range>(GetArenaNoVirtual());
    limit_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.QueryParams.limit)
  return limit_;
}
inline void QueryParams::set_allocated_limit(::algebra::Range* limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete limit_;
  }
  if (limit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limit, submessage_arena);
    }
    
  } else {
    
  }
  limit_ = limit;
  // @@protoc_insertion_point(field_set_allocated:algebra.QueryParams.limit)
}

// .common.Expression predicate = 5;
inline bool QueryParams::has_predicate() const {
  return this != internal_default_instance() && predicate_ != NULL;
}
inline const ::common::Expression& QueryParams::_internal_predicate() const {
  return *predicate_;
}
inline const ::common::Expression& QueryParams::predicate() const {
  const ::common::Expression* p = predicate_;
  // @@protoc_insertion_point(field_get:algebra.QueryParams.predicate)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Expression*>(
      &::common::_Expression_default_instance_);
}
inline ::common::Expression* QueryParams::release_predicate() {
  // @@protoc_insertion_point(field_release:algebra.QueryParams.predicate)
  
  ::common::Expression* temp = predicate_;
  predicate_ = NULL;
  return temp;
}
inline ::common::Expression* QueryParams::mutable_predicate() {
  
  if (predicate_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Expression>(GetArenaNoVirtual());
    predicate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.QueryParams.predicate)
  return predicate_;
}
inline void QueryParams::set_allocated_predicate(::common::Expression* predicate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(predicate_);
  }
  if (predicate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      predicate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, predicate, submessage_arena);
    }
    
  } else {
    
  }
  predicate_ = predicate;
  // @@protoc_insertion_point(field_set_allocated:algebra.QueryParams.predicate)
}

// double sample_ratio = 6;
inline void QueryParams::clear_sample_ratio() {
  sample_ratio_ = 0;
}
inline double QueryParams::sample_ratio() const {
  // @@protoc_insertion_point(field_get:algebra.QueryParams.sample_ratio)
  return sample_ratio_;
}
inline void QueryParams::set_sample_ratio(double value) {
  
  sample_ratio_ = value;
  // @@protoc_insertion_point(field_set:algebra.QueryParams.sample_ratio)
}

// map<string, string> extra = 7;
inline int QueryParams::extra_size() const {
  return extra_.size();
}
inline void QueryParams::clear_extra() {
  extra_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
QueryParams::extra() const {
  // @@protoc_insertion_point(field_map:algebra.QueryParams.extra)
  return extra_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
QueryParams::mutable_extra() {
  // @@protoc_insertion_point(field_mutable_map:algebra.QueryParams.extra)
  return extra_.MutableMap();
}

// -------------------------------------------------------------------

// Scan

// .algebra.Scan.ScanOpt scan_opt = 1;
inline void Scan::clear_scan_opt() {
  scan_opt_ = 0;
}
inline ::algebra::Scan_ScanOpt Scan::scan_opt() const {
  // @@protoc_insertion_point(field_get:algebra.Scan.scan_opt)
  return static_cast< ::algebra::Scan_ScanOpt >(scan_opt_);
}
inline void Scan::set_scan_opt(::algebra::Scan_ScanOpt value) {
  
  scan_opt_ = value;
  // @@protoc_insertion_point(field_set:algebra.Scan.scan_opt)
}

// .common.NameOrId alias = 2;
inline bool Scan::has_alias() const {
  return this != internal_default_instance() && alias_ != NULL;
}
inline const ::common::NameOrId& Scan::_internal_alias() const {
  return *alias_;
}
inline const ::common::NameOrId& Scan::alias() const {
  const ::common::NameOrId* p = alias_;
  // @@protoc_insertion_point(field_get:algebra.Scan.alias)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* Scan::release_alias() {
  // @@protoc_insertion_point(field_release:algebra.Scan.alias)
  
  ::common::NameOrId* temp = alias_;
  alias_ = NULL;
  return temp;
}
inline ::common::NameOrId* Scan::mutable_alias() {
  
  if (alias_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    alias_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.Scan.alias)
  return alias_;
}
inline void Scan::set_allocated_alias(::common::NameOrId* alias) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(alias_);
  }
  if (alias) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      alias = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, alias, submessage_arena);
    }
    
  } else {
    
  }
  alias_ = alias;
  // @@protoc_insertion_point(field_set_allocated:algebra.Scan.alias)
}

// .algebra.QueryParams params = 3;
inline bool Scan::has_params() const {
  return this != internal_default_instance() && params_ != NULL;
}
inline void Scan::clear_params() {
  if (GetArenaNoVirtual() == NULL && params_ != NULL) {
    delete params_;
  }
  params_ = NULL;
}
inline const ::algebra::QueryParams& Scan::_internal_params() const {
  return *params_;
}
inline const ::algebra::QueryParams& Scan::params() const {
  const ::algebra::QueryParams* p = params_;
  // @@protoc_insertion_point(field_get:algebra.Scan.params)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::QueryParams*>(
      &::algebra::_QueryParams_default_instance_);
}
inline ::algebra::QueryParams* Scan::release_params() {
  // @@protoc_insertion_point(field_release:algebra.Scan.params)
  
  ::algebra::QueryParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline ::algebra::QueryParams* Scan::mutable_params() {
  
  if (params_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::QueryParams>(GetArenaNoVirtual());
    params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.Scan.params)
  return params_;
}
inline void Scan::set_allocated_params(::algebra::QueryParams* params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete params_;
  }
  if (params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:algebra.Scan.params)
}

// .algebra.IndexPredicate idx_predicate = 4;
inline bool Scan::has_idx_predicate() const {
  return this != internal_default_instance() && idx_predicate_ != NULL;
}
inline void Scan::clear_idx_predicate() {
  if (GetArenaNoVirtual() == NULL && idx_predicate_ != NULL) {
    delete idx_predicate_;
  }
  idx_predicate_ = NULL;
}
inline const ::algebra::IndexPredicate& Scan::_internal_idx_predicate() const {
  return *idx_predicate_;
}
inline const ::algebra::IndexPredicate& Scan::idx_predicate() const {
  const ::algebra::IndexPredicate* p = idx_predicate_;
  // @@protoc_insertion_point(field_get:algebra.Scan.idx_predicate)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::IndexPredicate*>(
      &::algebra::_IndexPredicate_default_instance_);
}
inline ::algebra::IndexPredicate* Scan::release_idx_predicate() {
  // @@protoc_insertion_point(field_release:algebra.Scan.idx_predicate)
  
  ::algebra::IndexPredicate* temp = idx_predicate_;
  idx_predicate_ = NULL;
  return temp;
}
inline ::algebra::IndexPredicate* Scan::mutable_idx_predicate() {
  
  if (idx_predicate_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::IndexPredicate>(GetArenaNoVirtual());
    idx_predicate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.Scan.idx_predicate)
  return idx_predicate_;
}
inline void Scan::set_allocated_idx_predicate(::algebra::IndexPredicate* idx_predicate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete idx_predicate_;
  }
  if (idx_predicate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      idx_predicate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, idx_predicate, submessage_arena);
    }
    
  } else {
    
  }
  idx_predicate_ = idx_predicate;
  // @@protoc_insertion_point(field_set_allocated:algebra.Scan.idx_predicate)
}

// .algebra.MetaData meta_data = 5;
inline bool Scan::has_meta_data() const {
  return this != internal_default_instance() && meta_data_ != NULL;
}
inline void Scan::clear_meta_data() {
  if (GetArenaNoVirtual() == NULL && meta_data_ != NULL) {
    delete meta_data_;
  }
  meta_data_ = NULL;
}
inline const ::algebra::MetaData& Scan::_internal_meta_data() const {
  return *meta_data_;
}
inline const ::algebra::MetaData& Scan::meta_data() const {
  const ::algebra::MetaData* p = meta_data_;
  // @@protoc_insertion_point(field_get:algebra.Scan.meta_data)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::MetaData*>(
      &::algebra::_MetaData_default_instance_);
}
inline ::algebra::MetaData* Scan::release_meta_data() {
  // @@protoc_insertion_point(field_release:algebra.Scan.meta_data)
  
  ::algebra::MetaData* temp = meta_data_;
  meta_data_ = NULL;
  return temp;
}
inline ::algebra::MetaData* Scan::mutable_meta_data() {
  
  if (meta_data_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::MetaData>(GetArenaNoVirtual());
    meta_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.Scan.meta_data)
  return meta_data_;
}
inline void Scan::set_allocated_meta_data(::algebra::MetaData* meta_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete meta_data_;
  }
  if (meta_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      meta_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, meta_data, submessage_arena);
    }
    
  } else {
    
  }
  meta_data_ = meta_data;
  // @@protoc_insertion_point(field_set_allocated:algebra.Scan.meta_data)
}

// -------------------------------------------------------------------

// GetV

// .common.NameOrId tag = 1;
inline bool GetV::has_tag() const {
  return this != internal_default_instance() && tag_ != NULL;
}
inline const ::common::NameOrId& GetV::_internal_tag() const {
  return *tag_;
}
inline const ::common::NameOrId& GetV::tag() const {
  const ::common::NameOrId* p = tag_;
  // @@protoc_insertion_point(field_get:algebra.GetV.tag)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* GetV::release_tag() {
  // @@protoc_insertion_point(field_release:algebra.GetV.tag)
  
  ::common::NameOrId* temp = tag_;
  tag_ = NULL;
  return temp;
}
inline ::common::NameOrId* GetV::mutable_tag() {
  
  if (tag_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    tag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.GetV.tag)
  return tag_;
}
inline void GetV::set_allocated_tag(::common::NameOrId* tag) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tag_);
  }
  if (tag) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tag = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tag, submessage_arena);
    }
    
  } else {
    
  }
  tag_ = tag;
  // @@protoc_insertion_point(field_set_allocated:algebra.GetV.tag)
}

// .algebra.GetV.VOpt opt = 2;
inline void GetV::clear_opt() {
  opt_ = 0;
}
inline ::algebra::GetV_VOpt GetV::opt() const {
  // @@protoc_insertion_point(field_get:algebra.GetV.opt)
  return static_cast< ::algebra::GetV_VOpt >(opt_);
}
inline void GetV::set_opt(::algebra::GetV_VOpt value) {
  
  opt_ = value;
  // @@protoc_insertion_point(field_set:algebra.GetV.opt)
}

// .algebra.QueryParams params = 3;
inline bool GetV::has_params() const {
  return this != internal_default_instance() && params_ != NULL;
}
inline void GetV::clear_params() {
  if (GetArenaNoVirtual() == NULL && params_ != NULL) {
    delete params_;
  }
  params_ = NULL;
}
inline const ::algebra::QueryParams& GetV::_internal_params() const {
  return *params_;
}
inline const ::algebra::QueryParams& GetV::params() const {
  const ::algebra::QueryParams* p = params_;
  // @@protoc_insertion_point(field_get:algebra.GetV.params)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::QueryParams*>(
      &::algebra::_QueryParams_default_instance_);
}
inline ::algebra::QueryParams* GetV::release_params() {
  // @@protoc_insertion_point(field_release:algebra.GetV.params)
  
  ::algebra::QueryParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline ::algebra::QueryParams* GetV::mutable_params() {
  
  if (params_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::QueryParams>(GetArenaNoVirtual());
    params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.GetV.params)
  return params_;
}
inline void GetV::set_allocated_params(::algebra::QueryParams* params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete params_;
  }
  if (params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:algebra.GetV.params)
}

// .common.NameOrId alias = 4;
inline bool GetV::has_alias() const {
  return this != internal_default_instance() && alias_ != NULL;
}
inline const ::common::NameOrId& GetV::_internal_alias() const {
  return *alias_;
}
inline const ::common::NameOrId& GetV::alias() const {
  const ::common::NameOrId* p = alias_;
  // @@protoc_insertion_point(field_get:algebra.GetV.alias)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* GetV::release_alias() {
  // @@protoc_insertion_point(field_release:algebra.GetV.alias)
  
  ::common::NameOrId* temp = alias_;
  alias_ = NULL;
  return temp;
}
inline ::common::NameOrId* GetV::mutable_alias() {
  
  if (alias_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    alias_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.GetV.alias)
  return alias_;
}
inline void GetV::set_allocated_alias(::common::NameOrId* alias) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(alias_);
  }
  if (alias) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      alias = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, alias, submessage_arena);
    }
    
  } else {
    
  }
  alias_ = alias;
  // @@protoc_insertion_point(field_set_allocated:algebra.GetV.alias)
}

// .algebra.MetaData meta_data = 5;
inline bool GetV::has_meta_data() const {
  return this != internal_default_instance() && meta_data_ != NULL;
}
inline void GetV::clear_meta_data() {
  if (GetArenaNoVirtual() == NULL && meta_data_ != NULL) {
    delete meta_data_;
  }
  meta_data_ = NULL;
}
inline const ::algebra::MetaData& GetV::_internal_meta_data() const {
  return *meta_data_;
}
inline const ::algebra::MetaData& GetV::meta_data() const {
  const ::algebra::MetaData* p = meta_data_;
  // @@protoc_insertion_point(field_get:algebra.GetV.meta_data)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::MetaData*>(
      &::algebra::_MetaData_default_instance_);
}
inline ::algebra::MetaData* GetV::release_meta_data() {
  // @@protoc_insertion_point(field_release:algebra.GetV.meta_data)
  
  ::algebra::MetaData* temp = meta_data_;
  meta_data_ = NULL;
  return temp;
}
inline ::algebra::MetaData* GetV::mutable_meta_data() {
  
  if (meta_data_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::MetaData>(GetArenaNoVirtual());
    meta_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.GetV.meta_data)
  return meta_data_;
}
inline void GetV::set_allocated_meta_data(::algebra::MetaData* meta_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete meta_data_;
  }
  if (meta_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      meta_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, meta_data, submessage_arena);
    }
    
  } else {
    
  }
  meta_data_ = meta_data;
  // @@protoc_insertion_point(field_set_allocated:algebra.GetV.meta_data)
}

// -------------------------------------------------------------------

// As

// .common.NameOrId alias = 1;
inline bool As::has_alias() const {
  return this != internal_default_instance() && alias_ != NULL;
}
inline const ::common::NameOrId& As::_internal_alias() const {
  return *alias_;
}
inline const ::common::NameOrId& As::alias() const {
  const ::common::NameOrId* p = alias_;
  // @@protoc_insertion_point(field_get:algebra.As.alias)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* As::release_alias() {
  // @@protoc_insertion_point(field_release:algebra.As.alias)
  
  ::common::NameOrId* temp = alias_;
  alias_ = NULL;
  return temp;
}
inline ::common::NameOrId* As::mutable_alias() {
  
  if (alias_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    alias_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.As.alias)
  return alias_;
}
inline void As::set_allocated_alias(::common::NameOrId* alias) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(alias_);
  }
  if (alias) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      alias = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, alias, submessage_arena);
    }
    
  } else {
    
  }
  alias_ = alias;
  // @@protoc_insertion_point(field_set_allocated:algebra.As.alias)
}

// -------------------------------------------------------------------

// EdgeExpand

// .common.NameOrId v_tag = 1;
inline bool EdgeExpand::has_v_tag() const {
  return this != internal_default_instance() && v_tag_ != NULL;
}
inline const ::common::NameOrId& EdgeExpand::_internal_v_tag() const {
  return *v_tag_;
}
inline const ::common::NameOrId& EdgeExpand::v_tag() const {
  const ::common::NameOrId* p = v_tag_;
  // @@protoc_insertion_point(field_get:algebra.EdgeExpand.v_tag)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* EdgeExpand::release_v_tag() {
  // @@protoc_insertion_point(field_release:algebra.EdgeExpand.v_tag)
  
  ::common::NameOrId* temp = v_tag_;
  v_tag_ = NULL;
  return temp;
}
inline ::common::NameOrId* EdgeExpand::mutable_v_tag() {
  
  if (v_tag_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    v_tag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.EdgeExpand.v_tag)
  return v_tag_;
}
inline void EdgeExpand::set_allocated_v_tag(::common::NameOrId* v_tag) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(v_tag_);
  }
  if (v_tag) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      v_tag = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, v_tag, submessage_arena);
    }
    
  } else {
    
  }
  v_tag_ = v_tag;
  // @@protoc_insertion_point(field_set_allocated:algebra.EdgeExpand.v_tag)
}

// .algebra.EdgeExpand.Direction direction = 2;
inline void EdgeExpand::clear_direction() {
  direction_ = 0;
}
inline ::algebra::EdgeExpand_Direction EdgeExpand::direction() const {
  // @@protoc_insertion_point(field_get:algebra.EdgeExpand.direction)
  return static_cast< ::algebra::EdgeExpand_Direction >(direction_);
}
inline void EdgeExpand::set_direction(::algebra::EdgeExpand_Direction value) {
  
  direction_ = value;
  // @@protoc_insertion_point(field_set:algebra.EdgeExpand.direction)
}

// .algebra.QueryParams params = 3;
inline bool EdgeExpand::has_params() const {
  return this != internal_default_instance() && params_ != NULL;
}
inline void EdgeExpand::clear_params() {
  if (GetArenaNoVirtual() == NULL && params_ != NULL) {
    delete params_;
  }
  params_ = NULL;
}
inline const ::algebra::QueryParams& EdgeExpand::_internal_params() const {
  return *params_;
}
inline const ::algebra::QueryParams& EdgeExpand::params() const {
  const ::algebra::QueryParams* p = params_;
  // @@protoc_insertion_point(field_get:algebra.EdgeExpand.params)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::QueryParams*>(
      &::algebra::_QueryParams_default_instance_);
}
inline ::algebra::QueryParams* EdgeExpand::release_params() {
  // @@protoc_insertion_point(field_release:algebra.EdgeExpand.params)
  
  ::algebra::QueryParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline ::algebra::QueryParams* EdgeExpand::mutable_params() {
  
  if (params_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::QueryParams>(GetArenaNoVirtual());
    params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.EdgeExpand.params)
  return params_;
}
inline void EdgeExpand::set_allocated_params(::algebra::QueryParams* params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete params_;
  }
  if (params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:algebra.EdgeExpand.params)
}

// .common.NameOrId alias = 4;
inline bool EdgeExpand::has_alias() const {
  return this != internal_default_instance() && alias_ != NULL;
}
inline const ::common::NameOrId& EdgeExpand::_internal_alias() const {
  return *alias_;
}
inline const ::common::NameOrId& EdgeExpand::alias() const {
  const ::common::NameOrId* p = alias_;
  // @@protoc_insertion_point(field_get:algebra.EdgeExpand.alias)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* EdgeExpand::release_alias() {
  // @@protoc_insertion_point(field_release:algebra.EdgeExpand.alias)
  
  ::common::NameOrId* temp = alias_;
  alias_ = NULL;
  return temp;
}
inline ::common::NameOrId* EdgeExpand::mutable_alias() {
  
  if (alias_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    alias_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.EdgeExpand.alias)
  return alias_;
}
inline void EdgeExpand::set_allocated_alias(::common::NameOrId* alias) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(alias_);
  }
  if (alias) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      alias = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, alias, submessage_arena);
    }
    
  } else {
    
  }
  alias_ = alias;
  // @@protoc_insertion_point(field_set_allocated:algebra.EdgeExpand.alias)
}

// .algebra.EdgeExpand.ExpandOpt expand_opt = 5;
inline void EdgeExpand::clear_expand_opt() {
  expand_opt_ = 0;
}
inline ::algebra::EdgeExpand_ExpandOpt EdgeExpand::expand_opt() const {
  // @@protoc_insertion_point(field_get:algebra.EdgeExpand.expand_opt)
  return static_cast< ::algebra::EdgeExpand_ExpandOpt >(expand_opt_);
}
inline void EdgeExpand::set_expand_opt(::algebra::EdgeExpand_ExpandOpt value) {
  
  expand_opt_ = value;
  // @@protoc_insertion_point(field_set:algebra.EdgeExpand.expand_opt)
}

// .algebra.MetaData meta_data = 6;
inline bool EdgeExpand::has_meta_data() const {
  return this != internal_default_instance() && meta_data_ != NULL;
}
inline void EdgeExpand::clear_meta_data() {
  if (GetArenaNoVirtual() == NULL && meta_data_ != NULL) {
    delete meta_data_;
  }
  meta_data_ = NULL;
}
inline const ::algebra::MetaData& EdgeExpand::_internal_meta_data() const {
  return *meta_data_;
}
inline const ::algebra::MetaData& EdgeExpand::meta_data() const {
  const ::algebra::MetaData* p = meta_data_;
  // @@protoc_insertion_point(field_get:algebra.EdgeExpand.meta_data)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::MetaData*>(
      &::algebra::_MetaData_default_instance_);
}
inline ::algebra::MetaData* EdgeExpand::release_meta_data() {
  // @@protoc_insertion_point(field_release:algebra.EdgeExpand.meta_data)
  
  ::algebra::MetaData* temp = meta_data_;
  meta_data_ = NULL;
  return temp;
}
inline ::algebra::MetaData* EdgeExpand::mutable_meta_data() {
  
  if (meta_data_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::MetaData>(GetArenaNoVirtual());
    meta_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.EdgeExpand.meta_data)
  return meta_data_;
}
inline void EdgeExpand::set_allocated_meta_data(::algebra::MetaData* meta_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete meta_data_;
  }
  if (meta_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      meta_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, meta_data, submessage_arena);
    }
    
  } else {
    
  }
  meta_data_ = meta_data;
  // @@protoc_insertion_point(field_set_allocated:algebra.EdgeExpand.meta_data)
}

// -------------------------------------------------------------------

// PathExpand_ExpandBase

// .algebra.EdgeExpand edge_expand = 1;
inline bool PathExpand_ExpandBase::has_edge_expand() const {
  return this != internal_default_instance() && edge_expand_ != NULL;
}
inline void PathExpand_ExpandBase::clear_edge_expand() {
  if (GetArenaNoVirtual() == NULL && edge_expand_ != NULL) {
    delete edge_expand_;
  }
  edge_expand_ = NULL;
}
inline const ::algebra::EdgeExpand& PathExpand_ExpandBase::_internal_edge_expand() const {
  return *edge_expand_;
}
inline const ::algebra::EdgeExpand& PathExpand_ExpandBase::edge_expand() const {
  const ::algebra::EdgeExpand* p = edge_expand_;
  // @@protoc_insertion_point(field_get:algebra.PathExpand.ExpandBase.edge_expand)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::EdgeExpand*>(
      &::algebra::_EdgeExpand_default_instance_);
}
inline ::algebra::EdgeExpand* PathExpand_ExpandBase::release_edge_expand() {
  // @@protoc_insertion_point(field_release:algebra.PathExpand.ExpandBase.edge_expand)
  
  ::algebra::EdgeExpand* temp = edge_expand_;
  edge_expand_ = NULL;
  return temp;
}
inline ::algebra::EdgeExpand* PathExpand_ExpandBase::mutable_edge_expand() {
  
  if (edge_expand_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::EdgeExpand>(GetArenaNoVirtual());
    edge_expand_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.PathExpand.ExpandBase.edge_expand)
  return edge_expand_;
}
inline void PathExpand_ExpandBase::set_allocated_edge_expand(::algebra::EdgeExpand* edge_expand) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete edge_expand_;
  }
  if (edge_expand) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      edge_expand = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, edge_expand, submessage_arena);
    }
    
  } else {
    
  }
  edge_expand_ = edge_expand;
  // @@protoc_insertion_point(field_set_allocated:algebra.PathExpand.ExpandBase.edge_expand)
}

// .algebra.GetV get_V = 2;
inline bool PathExpand_ExpandBase::has_get_v() const {
  return this != internal_default_instance() && get_v_ != NULL;
}
inline void PathExpand_ExpandBase::clear_get_v() {
  if (GetArenaNoVirtual() == NULL && get_v_ != NULL) {
    delete get_v_;
  }
  get_v_ = NULL;
}
inline const ::algebra::GetV& PathExpand_ExpandBase::_internal_get_v() const {
  return *get_v_;
}
inline const ::algebra::GetV& PathExpand_ExpandBase::get_v() const {
  const ::algebra::GetV* p = get_v_;
  // @@protoc_insertion_point(field_get:algebra.PathExpand.ExpandBase.get_V)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::GetV*>(
      &::algebra::_GetV_default_instance_);
}
inline ::algebra::GetV* PathExpand_ExpandBase::release_get_v() {
  // @@protoc_insertion_point(field_release:algebra.PathExpand.ExpandBase.get_V)
  
  ::algebra::GetV* temp = get_v_;
  get_v_ = NULL;
  return temp;
}
inline ::algebra::GetV* PathExpand_ExpandBase::mutable_get_v() {
  
  if (get_v_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::GetV>(GetArenaNoVirtual());
    get_v_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.PathExpand.ExpandBase.get_V)
  return get_v_;
}
inline void PathExpand_ExpandBase::set_allocated_get_v(::algebra::GetV* get_v) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete get_v_;
  }
  if (get_v) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      get_v = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, get_v, submessage_arena);
    }
    
  } else {
    
  }
  get_v_ = get_v;
  // @@protoc_insertion_point(field_set_allocated:algebra.PathExpand.ExpandBase.get_V)
}

// -------------------------------------------------------------------

// PathExpand

// .algebra.PathExpand.ExpandBase base = 1;
inline bool PathExpand::has_base() const {
  return this != internal_default_instance() && base_ != NULL;
}
inline void PathExpand::clear_base() {
  if (GetArenaNoVirtual() == NULL && base_ != NULL) {
    delete base_;
  }
  base_ = NULL;
}
inline const ::algebra::PathExpand_ExpandBase& PathExpand::_internal_base() const {
  return *base_;
}
inline const ::algebra::PathExpand_ExpandBase& PathExpand::base() const {
  const ::algebra::PathExpand_ExpandBase* p = base_;
  // @@protoc_insertion_point(field_get:algebra.PathExpand.base)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::PathExpand_ExpandBase*>(
      &::algebra::_PathExpand_ExpandBase_default_instance_);
}
inline ::algebra::PathExpand_ExpandBase* PathExpand::release_base() {
  // @@protoc_insertion_point(field_release:algebra.PathExpand.base)
  
  ::algebra::PathExpand_ExpandBase* temp = base_;
  base_ = NULL;
  return temp;
}
inline ::algebra::PathExpand_ExpandBase* PathExpand::mutable_base() {
  
  if (base_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::PathExpand_ExpandBase>(GetArenaNoVirtual());
    base_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.PathExpand.base)
  return base_;
}
inline void PathExpand::set_allocated_base(::algebra::PathExpand_ExpandBase* base) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete base_;
  }
  if (base) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      base = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  base_ = base;
  // @@protoc_insertion_point(field_set_allocated:algebra.PathExpand.base)
}

// .common.NameOrId start_tag = 2;
inline bool PathExpand::has_start_tag() const {
  return this != internal_default_instance() && start_tag_ != NULL;
}
inline const ::common::NameOrId& PathExpand::_internal_start_tag() const {
  return *start_tag_;
}
inline const ::common::NameOrId& PathExpand::start_tag() const {
  const ::common::NameOrId* p = start_tag_;
  // @@protoc_insertion_point(field_get:algebra.PathExpand.start_tag)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* PathExpand::release_start_tag() {
  // @@protoc_insertion_point(field_release:algebra.PathExpand.start_tag)
  
  ::common::NameOrId* temp = start_tag_;
  start_tag_ = NULL;
  return temp;
}
inline ::common::NameOrId* PathExpand::mutable_start_tag() {
  
  if (start_tag_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    start_tag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.PathExpand.start_tag)
  return start_tag_;
}
inline void PathExpand::set_allocated_start_tag(::common::NameOrId* start_tag) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_tag_);
  }
  if (start_tag) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start_tag = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_tag, submessage_arena);
    }
    
  } else {
    
  }
  start_tag_ = start_tag;
  // @@protoc_insertion_point(field_set_allocated:algebra.PathExpand.start_tag)
}

// .common.NameOrId alias = 3;
inline bool PathExpand::has_alias() const {
  return this != internal_default_instance() && alias_ != NULL;
}
inline const ::common::NameOrId& PathExpand::_internal_alias() const {
  return *alias_;
}
inline const ::common::NameOrId& PathExpand::alias() const {
  const ::common::NameOrId* p = alias_;
  // @@protoc_insertion_point(field_get:algebra.PathExpand.alias)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* PathExpand::release_alias() {
  // @@protoc_insertion_point(field_release:algebra.PathExpand.alias)
  
  ::common::NameOrId* temp = alias_;
  alias_ = NULL;
  return temp;
}
inline ::common::NameOrId* PathExpand::mutable_alias() {
  
  if (alias_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    alias_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.PathExpand.alias)
  return alias_;
}
inline void PathExpand::set_allocated_alias(::common::NameOrId* alias) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(alias_);
  }
  if (alias) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      alias = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, alias, submessage_arena);
    }
    
  } else {
    
  }
  alias_ = alias;
  // @@protoc_insertion_point(field_set_allocated:algebra.PathExpand.alias)
}

// .algebra.Range hop_range = 4;
inline bool PathExpand::has_hop_range() const {
  return this != internal_default_instance() && hop_range_ != NULL;
}
inline void PathExpand::clear_hop_range() {
  if (GetArenaNoVirtual() == NULL && hop_range_ != NULL) {
    delete hop_range_;
  }
  hop_range_ = NULL;
}
inline const ::algebra::Range& PathExpand::_internal_hop_range() const {
  return *hop_range_;
}
inline const ::algebra::Range& PathExpand::hop_range() const {
  const ::algebra::Range* p = hop_range_;
  // @@protoc_insertion_point(field_get:algebra.PathExpand.hop_range)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::Range*>(
      &::algebra::_Range_default_instance_);
}
inline ::algebra::Range* PathExpand::release_hop_range() {
  // @@protoc_insertion_point(field_release:algebra.PathExpand.hop_range)
  
  ::algebra::Range* temp = hop_range_;
  hop_range_ = NULL;
  return temp;
}
inline ::algebra::Range* PathExpand::mutable_hop_range() {
  
  if (hop_range_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::Range>(GetArenaNoVirtual());
    hop_range_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.PathExpand.hop_range)
  return hop_range_;
}
inline void PathExpand::set_allocated_hop_range(::algebra::Range* hop_range) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete hop_range_;
  }
  if (hop_range) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      hop_range = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hop_range, submessage_arena);
    }
    
  } else {
    
  }
  hop_range_ = hop_range;
  // @@protoc_insertion_point(field_set_allocated:algebra.PathExpand.hop_range)
}

// .algebra.PathExpand.PathOpt path_opt = 5;
inline void PathExpand::clear_path_opt() {
  path_opt_ = 0;
}
inline ::algebra::PathExpand_PathOpt PathExpand::path_opt() const {
  // @@protoc_insertion_point(field_get:algebra.PathExpand.path_opt)
  return static_cast< ::algebra::PathExpand_PathOpt >(path_opt_);
}
inline void PathExpand::set_path_opt(::algebra::PathExpand_PathOpt value) {
  
  path_opt_ = value;
  // @@protoc_insertion_point(field_set:algebra.PathExpand.path_opt)
}

// .algebra.PathExpand.ResultOpt result_opt = 6;
inline void PathExpand::clear_result_opt() {
  result_opt_ = 0;
}
inline ::algebra::PathExpand_ResultOpt PathExpand::result_opt() const {
  // @@protoc_insertion_point(field_get:algebra.PathExpand.result_opt)
  return static_cast< ::algebra::PathExpand_ResultOpt >(result_opt_);
}
inline void PathExpand::set_result_opt(::algebra::PathExpand_ResultOpt value) {
  
  result_opt_ = value;
  // @@protoc_insertion_point(field_set:algebra.PathExpand.result_opt)
}

// .common.Expression condition = 7;
inline bool PathExpand::has_condition() const {
  return this != internal_default_instance() && condition_ != NULL;
}
inline const ::common::Expression& PathExpand::_internal_condition() const {
  return *condition_;
}
inline const ::common::Expression& PathExpand::condition() const {
  const ::common::Expression* p = condition_;
  // @@protoc_insertion_point(field_get:algebra.PathExpand.condition)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Expression*>(
      &::common::_Expression_default_instance_);
}
inline ::common::Expression* PathExpand::release_condition() {
  // @@protoc_insertion_point(field_release:algebra.PathExpand.condition)
  
  ::common::Expression* temp = condition_;
  condition_ = NULL;
  return temp;
}
inline ::common::Expression* PathExpand::mutable_condition() {
  
  if (condition_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Expression>(GetArenaNoVirtual());
    condition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.PathExpand.condition)
  return condition_;
}
inline void PathExpand::set_allocated_condition(::common::Expression* condition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(condition_);
  }
  if (condition) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      condition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, condition, submessage_arena);
    }
    
  } else {
    
  }
  condition_ = condition;
  // @@protoc_insertion_point(field_set_allocated:algebra.PathExpand.condition)
}

// -------------------------------------------------------------------

// Apply

// .algebra.Join.JoinKind join_kind = 1;
inline void Apply::clear_join_kind() {
  join_kind_ = 0;
}
inline ::algebra::Join_JoinKind Apply::join_kind() const {
  // @@protoc_insertion_point(field_get:algebra.Apply.join_kind)
  return static_cast< ::algebra::Join_JoinKind >(join_kind_);
}
inline void Apply::set_join_kind(::algebra::Join_JoinKind value) {
  
  join_kind_ = value;
  // @@protoc_insertion_point(field_set:algebra.Apply.join_kind)
}

// repeated .common.NameOrId tags = 2;
inline int Apply::tags_size() const {
  return tags_.size();
}
inline ::common::NameOrId* Apply::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:algebra.Apply.tags)
  return tags_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::common::NameOrId >*
Apply::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:algebra.Apply.tags)
  return &tags_;
}
inline const ::common::NameOrId& Apply::tags(int index) const {
  // @@protoc_insertion_point(field_get:algebra.Apply.tags)
  return tags_.Get(index);
}
inline ::common::NameOrId* Apply::add_tags() {
  // @@protoc_insertion_point(field_add:algebra.Apply.tags)
  return tags_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::NameOrId >&
Apply::tags() const {
  // @@protoc_insertion_point(field_list:algebra.Apply.tags)
  return tags_;
}

// int32 subtask = 3;
inline void Apply::clear_subtask() {
  subtask_ = 0;
}
inline ::google::protobuf::int32 Apply::subtask() const {
  // @@protoc_insertion_point(field_get:algebra.Apply.subtask)
  return subtask_;
}
inline void Apply::set_subtask(::google::protobuf::int32 value) {
  
  subtask_ = value;
  // @@protoc_insertion_point(field_set:algebra.Apply.subtask)
}

// .common.NameOrId alias = 4;
inline bool Apply::has_alias() const {
  return this != internal_default_instance() && alias_ != NULL;
}
inline const ::common::NameOrId& Apply::_internal_alias() const {
  return *alias_;
}
inline const ::common::NameOrId& Apply::alias() const {
  const ::common::NameOrId* p = alias_;
  // @@protoc_insertion_point(field_get:algebra.Apply.alias)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* Apply::release_alias() {
  // @@protoc_insertion_point(field_release:algebra.Apply.alias)
  
  ::common::NameOrId* temp = alias_;
  alias_ = NULL;
  return temp;
}
inline ::common::NameOrId* Apply::mutable_alias() {
  
  if (alias_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    alias_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.Apply.alias)
  return alias_;
}
inline void Apply::set_allocated_alias(::common::NameOrId* alias) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(alias_);
  }
  if (alias) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      alias = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, alias, submessage_arena);
    }
    
  } else {
    
  }
  alias_ = alias;
  // @@protoc_insertion_point(field_set_allocated:algebra.Apply.alias)
}

// -------------------------------------------------------------------

// SegmentApply

// repeated .common.NameOrId keys = 1;
inline int SegmentApply::keys_size() const {
  return keys_.size();
}
inline ::common::NameOrId* SegmentApply::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:algebra.SegmentApply.keys)
  return keys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::common::NameOrId >*
SegmentApply::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:algebra.SegmentApply.keys)
  return &keys_;
}
inline const ::common::NameOrId& SegmentApply::keys(int index) const {
  // @@protoc_insertion_point(field_get:algebra.SegmentApply.keys)
  return keys_.Get(index);
}
inline ::common::NameOrId* SegmentApply::add_keys() {
  // @@protoc_insertion_point(field_add:algebra.SegmentApply.keys)
  return keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::NameOrId >&
SegmentApply::keys() const {
  // @@protoc_insertion_point(field_list:algebra.SegmentApply.keys)
  return keys_;
}

// .algebra.Apply apply_subtask = 2;
inline bool SegmentApply::has_apply_subtask() const {
  return this != internal_default_instance() && apply_subtask_ != NULL;
}
inline void SegmentApply::clear_apply_subtask() {
  if (GetArenaNoVirtual() == NULL && apply_subtask_ != NULL) {
    delete apply_subtask_;
  }
  apply_subtask_ = NULL;
}
inline const ::algebra::Apply& SegmentApply::_internal_apply_subtask() const {
  return *apply_subtask_;
}
inline const ::algebra::Apply& SegmentApply::apply_subtask() const {
  const ::algebra::Apply* p = apply_subtask_;
  // @@protoc_insertion_point(field_get:algebra.SegmentApply.apply_subtask)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::Apply*>(
      &::algebra::_Apply_default_instance_);
}
inline ::algebra::Apply* SegmentApply::release_apply_subtask() {
  // @@protoc_insertion_point(field_release:algebra.SegmentApply.apply_subtask)
  
  ::algebra::Apply* temp = apply_subtask_;
  apply_subtask_ = NULL;
  return temp;
}
inline ::algebra::Apply* SegmentApply::mutable_apply_subtask() {
  
  if (apply_subtask_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::Apply>(GetArenaNoVirtual());
    apply_subtask_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.SegmentApply.apply_subtask)
  return apply_subtask_;
}
inline void SegmentApply::set_allocated_apply_subtask(::algebra::Apply* apply_subtask) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete apply_subtask_;
  }
  if (apply_subtask) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      apply_subtask = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, apply_subtask, submessage_arena);
    }
    
  } else {
    
  }
  apply_subtask_ = apply_subtask;
  // @@protoc_insertion_point(field_set_allocated:algebra.SegmentApply.apply_subtask)
}

// -------------------------------------------------------------------

// Pattern_Binder

// .algebra.EdgeExpand edge = 1;
inline bool Pattern_Binder::has_edge() const {
  return item_case() == kEdge;
}
inline void Pattern_Binder::set_has_edge() {
  _oneof_case_[0] = kEdge;
}
inline void Pattern_Binder::clear_edge() {
  if (has_edge()) {
    delete item_.edge_;
    clear_has_item();
  }
}
inline const ::algebra::EdgeExpand& Pattern_Binder::_internal_edge() const {
  return *item_.edge_;
}
inline ::algebra::EdgeExpand* Pattern_Binder::release_edge() {
  // @@protoc_insertion_point(field_release:algebra.Pattern.Binder.edge)
  if (has_edge()) {
    clear_has_item();
      ::algebra::EdgeExpand* temp = item_.edge_;
    item_.edge_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::EdgeExpand& Pattern_Binder::edge() const {
  // @@protoc_insertion_point(field_get:algebra.Pattern.Binder.edge)
  return has_edge()
      ? *item_.edge_
      : *reinterpret_cast< ::algebra::EdgeExpand*>(&::algebra::_EdgeExpand_default_instance_);
}
inline ::algebra::EdgeExpand* Pattern_Binder::mutable_edge() {
  if (!has_edge()) {
    clear_item();
    set_has_edge();
    item_.edge_ = CreateMaybeMessage< ::algebra::EdgeExpand >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.Pattern.Binder.edge)
  return item_.edge_;
}

// .algebra.PathExpand path = 2;
inline bool Pattern_Binder::has_path() const {
  return item_case() == kPath;
}
inline void Pattern_Binder::set_has_path() {
  _oneof_case_[0] = kPath;
}
inline void Pattern_Binder::clear_path() {
  if (has_path()) {
    delete item_.path_;
    clear_has_item();
  }
}
inline const ::algebra::PathExpand& Pattern_Binder::_internal_path() const {
  return *item_.path_;
}
inline ::algebra::PathExpand* Pattern_Binder::release_path() {
  // @@protoc_insertion_point(field_release:algebra.Pattern.Binder.path)
  if (has_path()) {
    clear_has_item();
      ::algebra::PathExpand* temp = item_.path_;
    item_.path_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::PathExpand& Pattern_Binder::path() const {
  // @@protoc_insertion_point(field_get:algebra.Pattern.Binder.path)
  return has_path()
      ? *item_.path_
      : *reinterpret_cast< ::algebra::PathExpand*>(&::algebra::_PathExpand_default_instance_);
}
inline ::algebra::PathExpand* Pattern_Binder::mutable_path() {
  if (!has_path()) {
    clear_item();
    set_has_path();
    item_.path_ = CreateMaybeMessage< ::algebra::PathExpand >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.Pattern.Binder.path)
  return item_.path_;
}

// .algebra.GetV vertex = 3;
inline bool Pattern_Binder::has_vertex() const {
  return item_case() == kVertex;
}
inline void Pattern_Binder::set_has_vertex() {
  _oneof_case_[0] = kVertex;
}
inline void Pattern_Binder::clear_vertex() {
  if (has_vertex()) {
    delete item_.vertex_;
    clear_has_item();
  }
}
inline const ::algebra::GetV& Pattern_Binder::_internal_vertex() const {
  return *item_.vertex_;
}
inline ::algebra::GetV* Pattern_Binder::release_vertex() {
  // @@protoc_insertion_point(field_release:algebra.Pattern.Binder.vertex)
  if (has_vertex()) {
    clear_has_item();
      ::algebra::GetV* temp = item_.vertex_;
    item_.vertex_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::GetV& Pattern_Binder::vertex() const {
  // @@protoc_insertion_point(field_get:algebra.Pattern.Binder.vertex)
  return has_vertex()
      ? *item_.vertex_
      : *reinterpret_cast< ::algebra::GetV*>(&::algebra::_GetV_default_instance_);
}
inline ::algebra::GetV* Pattern_Binder::mutable_vertex() {
  if (!has_vertex()) {
    clear_item();
    set_has_vertex();
    item_.vertex_ = CreateMaybeMessage< ::algebra::GetV >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.Pattern.Binder.vertex)
  return item_.vertex_;
}

// .algebra.Select select = 4;
inline bool Pattern_Binder::has_select() const {
  return item_case() == kSelect;
}
inline void Pattern_Binder::set_has_select() {
  _oneof_case_[0] = kSelect;
}
inline void Pattern_Binder::clear_select() {
  if (has_select()) {
    delete item_.select_;
    clear_has_item();
  }
}
inline const ::algebra::Select& Pattern_Binder::_internal_select() const {
  return *item_.select_;
}
inline ::algebra::Select* Pattern_Binder::release_select() {
  // @@protoc_insertion_point(field_release:algebra.Pattern.Binder.select)
  if (has_select()) {
    clear_has_item();
      ::algebra::Select* temp = item_.select_;
    item_.select_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::Select& Pattern_Binder::select() const {
  // @@protoc_insertion_point(field_get:algebra.Pattern.Binder.select)
  return has_select()
      ? *item_.select_
      : *reinterpret_cast< ::algebra::Select*>(&::algebra::_Select_default_instance_);
}
inline ::algebra::Select* Pattern_Binder::mutable_select() {
  if (!has_select()) {
    clear_item();
    set_has_select();
    item_.select_ = CreateMaybeMessage< ::algebra::Select >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.Pattern.Binder.select)
  return item_.select_;
}

inline bool Pattern_Binder::has_item() const {
  return item_case() != ITEM_NOT_SET;
}
inline void Pattern_Binder::clear_has_item() {
  _oneof_case_[0] = ITEM_NOT_SET;
}
inline Pattern_Binder::ItemCase Pattern_Binder::item_case() const {
  return Pattern_Binder::ItemCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Pattern_Sentence

// .common.NameOrId start = 1;
inline bool Pattern_Sentence::has_start() const {
  return this != internal_default_instance() && start_ != NULL;
}
inline const ::common::NameOrId& Pattern_Sentence::_internal_start() const {
  return *start_;
}
inline const ::common::NameOrId& Pattern_Sentence::start() const {
  const ::common::NameOrId* p = start_;
  // @@protoc_insertion_point(field_get:algebra.Pattern.Sentence.start)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* Pattern_Sentence::release_start() {
  // @@protoc_insertion_point(field_release:algebra.Pattern.Sentence.start)
  
  ::common::NameOrId* temp = start_;
  start_ = NULL;
  return temp;
}
inline ::common::NameOrId* Pattern_Sentence::mutable_start() {
  
  if (start_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    start_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.Pattern.Sentence.start)
  return start_;
}
inline void Pattern_Sentence::set_allocated_start(::common::NameOrId* start) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_);
  }
  if (start) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:algebra.Pattern.Sentence.start)
}

// repeated .algebra.Pattern.Binder binders = 2;
inline int Pattern_Sentence::binders_size() const {
  return binders_.size();
}
inline void Pattern_Sentence::clear_binders() {
  binders_.Clear();
}
inline ::algebra::Pattern_Binder* Pattern_Sentence::mutable_binders(int index) {
  // @@protoc_insertion_point(field_mutable:algebra.Pattern.Sentence.binders)
  return binders_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::algebra::Pattern_Binder >*
Pattern_Sentence::mutable_binders() {
  // @@protoc_insertion_point(field_mutable_list:algebra.Pattern.Sentence.binders)
  return &binders_;
}
inline const ::algebra::Pattern_Binder& Pattern_Sentence::binders(int index) const {
  // @@protoc_insertion_point(field_get:algebra.Pattern.Sentence.binders)
  return binders_.Get(index);
}
inline ::algebra::Pattern_Binder* Pattern_Sentence::add_binders() {
  // @@protoc_insertion_point(field_add:algebra.Pattern.Sentence.binders)
  return binders_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::algebra::Pattern_Binder >&
Pattern_Sentence::binders() const {
  // @@protoc_insertion_point(field_list:algebra.Pattern.Sentence.binders)
  return binders_;
}

// .common.NameOrId end = 3;
inline bool Pattern_Sentence::has_end() const {
  return this != internal_default_instance() && end_ != NULL;
}
inline const ::common::NameOrId& Pattern_Sentence::_internal_end() const {
  return *end_;
}
inline const ::common::NameOrId& Pattern_Sentence::end() const {
  const ::common::NameOrId* p = end_;
  // @@protoc_insertion_point(field_get:algebra.Pattern.Sentence.end)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* Pattern_Sentence::release_end() {
  // @@protoc_insertion_point(field_release:algebra.Pattern.Sentence.end)
  
  ::common::NameOrId* temp = end_;
  end_ = NULL;
  return temp;
}
inline ::common::NameOrId* Pattern_Sentence::mutable_end() {
  
  if (end_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    end_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.Pattern.Sentence.end)
  return end_;
}
inline void Pattern_Sentence::set_allocated_end(::common::NameOrId* end) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(end_);
  }
  if (end) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      end = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:algebra.Pattern.Sentence.end)
}

// .algebra.Join.JoinKind join_kind = 4;
inline void Pattern_Sentence::clear_join_kind() {
  join_kind_ = 0;
}
inline ::algebra::Join_JoinKind Pattern_Sentence::join_kind() const {
  // @@protoc_insertion_point(field_get:algebra.Pattern.Sentence.join_kind)
  return static_cast< ::algebra::Join_JoinKind >(join_kind_);
}
inline void Pattern_Sentence::set_join_kind(::algebra::Join_JoinKind value) {
  
  join_kind_ = value;
  // @@protoc_insertion_point(field_set:algebra.Pattern.Sentence.join_kind)
}

// -------------------------------------------------------------------

// Pattern

// repeated .algebra.Pattern.Sentence sentences = 1;
inline int Pattern::sentences_size() const {
  return sentences_.size();
}
inline void Pattern::clear_sentences() {
  sentences_.Clear();
}
inline ::algebra::Pattern_Sentence* Pattern::mutable_sentences(int index) {
  // @@protoc_insertion_point(field_mutable:algebra.Pattern.sentences)
  return sentences_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::algebra::Pattern_Sentence >*
Pattern::mutable_sentences() {
  // @@protoc_insertion_point(field_mutable_list:algebra.Pattern.sentences)
  return &sentences_;
}
inline const ::algebra::Pattern_Sentence& Pattern::sentences(int index) const {
  // @@protoc_insertion_point(field_get:algebra.Pattern.sentences)
  return sentences_.Get(index);
}
inline ::algebra::Pattern_Sentence* Pattern::add_sentences() {
  // @@protoc_insertion_point(field_add:algebra.Pattern.sentences)
  return sentences_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::algebra::Pattern_Sentence >&
Pattern::sentences() const {
  // @@protoc_insertion_point(field_list:algebra.Pattern.sentences)
  return sentences_;
}

// repeated .algebra.MetaData meta_data = 2;
inline int Pattern::meta_data_size() const {
  return meta_data_.size();
}
inline void Pattern::clear_meta_data() {
  meta_data_.Clear();
}
inline ::algebra::MetaData* Pattern::mutable_meta_data(int index) {
  // @@protoc_insertion_point(field_mutable:algebra.Pattern.meta_data)
  return meta_data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::algebra::MetaData >*
Pattern::mutable_meta_data() {
  // @@protoc_insertion_point(field_mutable_list:algebra.Pattern.meta_data)
  return &meta_data_;
}
inline const ::algebra::MetaData& Pattern::meta_data(int index) const {
  // @@protoc_insertion_point(field_get:algebra.Pattern.meta_data)
  return meta_data_.Get(index);
}
inline ::algebra::MetaData* Pattern::add_meta_data() {
  // @@protoc_insertion_point(field_add:algebra.Pattern.meta_data)
  return meta_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::algebra::MetaData >&
Pattern::meta_data() const {
  // @@protoc_insertion_point(field_list:algebra.Pattern.meta_data)
  return meta_data_;
}

// -------------------------------------------------------------------

// Sample_SampleByRatio

// double ratio = 1;
inline void Sample_SampleByRatio::clear_ratio() {
  ratio_ = 0;
}
inline double Sample_SampleByRatio::ratio() const {
  // @@protoc_insertion_point(field_get:algebra.Sample.SampleByRatio.ratio)
  return ratio_;
}
inline void Sample_SampleByRatio::set_ratio(double value) {
  
  ratio_ = value;
  // @@protoc_insertion_point(field_set:algebra.Sample.SampleByRatio.ratio)
}

// -------------------------------------------------------------------

// Sample_SampleByNum

// int32 num = 1;
inline void Sample_SampleByNum::clear_num() {
  num_ = 0;
}
inline ::google::protobuf::int32 Sample_SampleByNum::num() const {
  // @@protoc_insertion_point(field_get:algebra.Sample.SampleByNum.num)
  return num_;
}
inline void Sample_SampleByNum::set_num(::google::protobuf::int32 value) {
  
  num_ = value;
  // @@protoc_insertion_point(field_set:algebra.Sample.SampleByNum.num)
}

// -------------------------------------------------------------------

// Sample_SampleType

// .algebra.Sample.SampleByRatio sample_by_ratio = 1;
inline bool Sample_SampleType::has_sample_by_ratio() const {
  return inner_case() == kSampleByRatio;
}
inline void Sample_SampleType::set_has_sample_by_ratio() {
  _oneof_case_[0] = kSampleByRatio;
}
inline void Sample_SampleType::clear_sample_by_ratio() {
  if (has_sample_by_ratio()) {
    delete inner_.sample_by_ratio_;
    clear_has_inner();
  }
}
inline const ::algebra::Sample_SampleByRatio& Sample_SampleType::_internal_sample_by_ratio() const {
  return *inner_.sample_by_ratio_;
}
inline ::algebra::Sample_SampleByRatio* Sample_SampleType::release_sample_by_ratio() {
  // @@protoc_insertion_point(field_release:algebra.Sample.SampleType.sample_by_ratio)
  if (has_sample_by_ratio()) {
    clear_has_inner();
      ::algebra::Sample_SampleByRatio* temp = inner_.sample_by_ratio_;
    inner_.sample_by_ratio_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::Sample_SampleByRatio& Sample_SampleType::sample_by_ratio() const {
  // @@protoc_insertion_point(field_get:algebra.Sample.SampleType.sample_by_ratio)
  return has_sample_by_ratio()
      ? *inner_.sample_by_ratio_
      : *reinterpret_cast< ::algebra::Sample_SampleByRatio*>(&::algebra::_Sample_SampleByRatio_default_instance_);
}
inline ::algebra::Sample_SampleByRatio* Sample_SampleType::mutable_sample_by_ratio() {
  if (!has_sample_by_ratio()) {
    clear_inner();
    set_has_sample_by_ratio();
    inner_.sample_by_ratio_ = CreateMaybeMessage< ::algebra::Sample_SampleByRatio >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.Sample.SampleType.sample_by_ratio)
  return inner_.sample_by_ratio_;
}

// .algebra.Sample.SampleByNum sample_by_num = 2;
inline bool Sample_SampleType::has_sample_by_num() const {
  return inner_case() == kSampleByNum;
}
inline void Sample_SampleType::set_has_sample_by_num() {
  _oneof_case_[0] = kSampleByNum;
}
inline void Sample_SampleType::clear_sample_by_num() {
  if (has_sample_by_num()) {
    delete inner_.sample_by_num_;
    clear_has_inner();
  }
}
inline const ::algebra::Sample_SampleByNum& Sample_SampleType::_internal_sample_by_num() const {
  return *inner_.sample_by_num_;
}
inline ::algebra::Sample_SampleByNum* Sample_SampleType::release_sample_by_num() {
  // @@protoc_insertion_point(field_release:algebra.Sample.SampleType.sample_by_num)
  if (has_sample_by_num()) {
    clear_has_inner();
      ::algebra::Sample_SampleByNum* temp = inner_.sample_by_num_;
    inner_.sample_by_num_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::Sample_SampleByNum& Sample_SampleType::sample_by_num() const {
  // @@protoc_insertion_point(field_get:algebra.Sample.SampleType.sample_by_num)
  return has_sample_by_num()
      ? *inner_.sample_by_num_
      : *reinterpret_cast< ::algebra::Sample_SampleByNum*>(&::algebra::_Sample_SampleByNum_default_instance_);
}
inline ::algebra::Sample_SampleByNum* Sample_SampleType::mutable_sample_by_num() {
  if (!has_sample_by_num()) {
    clear_inner();
    set_has_sample_by_num();
    inner_.sample_by_num_ = CreateMaybeMessage< ::algebra::Sample_SampleByNum >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.Sample.SampleType.sample_by_num)
  return inner_.sample_by_num_;
}

inline bool Sample_SampleType::has_inner() const {
  return inner_case() != INNER_NOT_SET;
}
inline void Sample_SampleType::clear_has_inner() {
  _oneof_case_[0] = INNER_NOT_SET;
}
inline Sample_SampleType::InnerCase Sample_SampleType::inner_case() const {
  return Sample_SampleType::InnerCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Sample

// .algebra.Sample.SampleType sample_type = 1;
inline bool Sample::has_sample_type() const {
  return this != internal_default_instance() && sample_type_ != NULL;
}
inline void Sample::clear_sample_type() {
  if (GetArenaNoVirtual() == NULL && sample_type_ != NULL) {
    delete sample_type_;
  }
  sample_type_ = NULL;
}
inline const ::algebra::Sample_SampleType& Sample::_internal_sample_type() const {
  return *sample_type_;
}
inline const ::algebra::Sample_SampleType& Sample::sample_type() const {
  const ::algebra::Sample_SampleType* p = sample_type_;
  // @@protoc_insertion_point(field_get:algebra.Sample.sample_type)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::Sample_SampleType*>(
      &::algebra::_Sample_SampleType_default_instance_);
}
inline ::algebra::Sample_SampleType* Sample::release_sample_type() {
  // @@protoc_insertion_point(field_release:algebra.Sample.sample_type)
  
  ::algebra::Sample_SampleType* temp = sample_type_;
  sample_type_ = NULL;
  return temp;
}
inline ::algebra::Sample_SampleType* Sample::mutable_sample_type() {
  
  if (sample_type_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::Sample_SampleType>(GetArenaNoVirtual());
    sample_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.Sample.sample_type)
  return sample_type_;
}
inline void Sample::set_allocated_sample_type(::algebra::Sample_SampleType* sample_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sample_type_;
  }
  if (sample_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sample_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sample_type, submessage_arena);
    }
    
  } else {
    
  }
  sample_type_ = sample_type;
  // @@protoc_insertion_point(field_set_allocated:algebra.Sample.sample_type)
}

// .google.protobuf.Int32Value seed = 2;
inline bool Sample::has_seed() const {
  return this != internal_default_instance() && seed_ != NULL;
}
inline const ::google::protobuf::Int32Value& Sample::_internal_seed() const {
  return *seed_;
}
inline const ::google::protobuf::Int32Value& Sample::seed() const {
  const ::google::protobuf::Int32Value* p = seed_;
  // @@protoc_insertion_point(field_get:algebra.Sample.seed)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* Sample::release_seed() {
  // @@protoc_insertion_point(field_release:algebra.Sample.seed)
  
  ::google::protobuf::Int32Value* temp = seed_;
  seed_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* Sample::mutable_seed() {
  
  if (seed_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int32Value>(GetArenaNoVirtual());
    seed_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.Sample.seed)
  return seed_;
}
inline void Sample::set_allocated_seed(::google::protobuf::Int32Value* seed) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(seed_);
  }
  if (seed) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(seed)->GetArena();
    if (message_arena != submessage_arena) {
      seed = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, seed, submessage_arena);
    }
    
  } else {
    
  }
  seed_ = seed;
  // @@protoc_insertion_point(field_set_allocated:algebra.Sample.seed)
}

// .common.Variable sample_weight = 3;
inline bool Sample::has_sample_weight() const {
  return this != internal_default_instance() && sample_weight_ != NULL;
}
inline const ::common::Variable& Sample::_internal_sample_weight() const {
  return *sample_weight_;
}
inline const ::common::Variable& Sample::sample_weight() const {
  const ::common::Variable* p = sample_weight_;
  // @@protoc_insertion_point(field_get:algebra.Sample.sample_weight)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Variable*>(
      &::common::_Variable_default_instance_);
}
inline ::common::Variable* Sample::release_sample_weight() {
  // @@protoc_insertion_point(field_release:algebra.Sample.sample_weight)
  
  ::common::Variable* temp = sample_weight_;
  sample_weight_ = NULL;
  return temp;
}
inline ::common::Variable* Sample::mutable_sample_weight() {
  
  if (sample_weight_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Variable>(GetArenaNoVirtual());
    sample_weight_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.Sample.sample_weight)
  return sample_weight_;
}
inline void Sample::set_allocated_sample_weight(::common::Variable* sample_weight) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(sample_weight_);
  }
  if (sample_weight) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sample_weight = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sample_weight, submessage_arena);
    }
    
  } else {
    
  }
  sample_weight_ = sample_weight;
  // @@protoc_insertion_point(field_set_allocated:algebra.Sample.sample_weight)
}

// -------------------------------------------------------------------

// Sink_SinkTarget

// .algebra.SinkDefault sink_default = 1;
inline bool Sink_SinkTarget::has_sink_default() const {
  return inner_case() == kSinkDefault;
}
inline void Sink_SinkTarget::set_has_sink_default() {
  _oneof_case_[0] = kSinkDefault;
}
inline void Sink_SinkTarget::clear_sink_default() {
  if (has_sink_default()) {
    delete inner_.sink_default_;
    clear_has_inner();
  }
}
inline const ::algebra::SinkDefault& Sink_SinkTarget::_internal_sink_default() const {
  return *inner_.sink_default_;
}
inline ::algebra::SinkDefault* Sink_SinkTarget::release_sink_default() {
  // @@protoc_insertion_point(field_release:algebra.Sink.SinkTarget.sink_default)
  if (has_sink_default()) {
    clear_has_inner();
      ::algebra::SinkDefault* temp = inner_.sink_default_;
    inner_.sink_default_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::SinkDefault& Sink_SinkTarget::sink_default() const {
  // @@protoc_insertion_point(field_get:algebra.Sink.SinkTarget.sink_default)
  return has_sink_default()
      ? *inner_.sink_default_
      : *reinterpret_cast< ::algebra::SinkDefault*>(&::algebra::_SinkDefault_default_instance_);
}
inline ::algebra::SinkDefault* Sink_SinkTarget::mutable_sink_default() {
  if (!has_sink_default()) {
    clear_inner();
    set_has_sink_default();
    inner_.sink_default_ = CreateMaybeMessage< ::algebra::SinkDefault >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.Sink.SinkTarget.sink_default)
  return inner_.sink_default_;
}

// .algebra.SinkVineyard sink_vineyard = 2;
inline bool Sink_SinkTarget::has_sink_vineyard() const {
  return inner_case() == kSinkVineyard;
}
inline void Sink_SinkTarget::set_has_sink_vineyard() {
  _oneof_case_[0] = kSinkVineyard;
}
inline void Sink_SinkTarget::clear_sink_vineyard() {
  if (has_sink_vineyard()) {
    delete inner_.sink_vineyard_;
    clear_has_inner();
  }
}
inline const ::algebra::SinkVineyard& Sink_SinkTarget::_internal_sink_vineyard() const {
  return *inner_.sink_vineyard_;
}
inline ::algebra::SinkVineyard* Sink_SinkTarget::release_sink_vineyard() {
  // @@protoc_insertion_point(field_release:algebra.Sink.SinkTarget.sink_vineyard)
  if (has_sink_vineyard()) {
    clear_has_inner();
      ::algebra::SinkVineyard* temp = inner_.sink_vineyard_;
    inner_.sink_vineyard_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::SinkVineyard& Sink_SinkTarget::sink_vineyard() const {
  // @@protoc_insertion_point(field_get:algebra.Sink.SinkTarget.sink_vineyard)
  return has_sink_vineyard()
      ? *inner_.sink_vineyard_
      : *reinterpret_cast< ::algebra::SinkVineyard*>(&::algebra::_SinkVineyard_default_instance_);
}
inline ::algebra::SinkVineyard* Sink_SinkTarget::mutable_sink_vineyard() {
  if (!has_sink_vineyard()) {
    clear_inner();
    set_has_sink_vineyard();
    inner_.sink_vineyard_ = CreateMaybeMessage< ::algebra::SinkVineyard >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.Sink.SinkTarget.sink_vineyard)
  return inner_.sink_vineyard_;
}

inline bool Sink_SinkTarget::has_inner() const {
  return inner_case() != INNER_NOT_SET;
}
inline void Sink_SinkTarget::clear_has_inner() {
  _oneof_case_[0] = INNER_NOT_SET;
}
inline Sink_SinkTarget::InnerCase Sink_SinkTarget::inner_case() const {
  return Sink_SinkTarget::InnerCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Sink

// repeated .common.NameOrIdKey tags = 1;
inline int Sink::tags_size() const {
  return tags_.size();
}
inline ::common::NameOrIdKey* Sink::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:algebra.Sink.tags)
  return tags_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::common::NameOrIdKey >*
Sink::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:algebra.Sink.tags)
  return &tags_;
}
inline const ::common::NameOrIdKey& Sink::tags(int index) const {
  // @@protoc_insertion_point(field_get:algebra.Sink.tags)
  return tags_.Get(index);
}
inline ::common::NameOrIdKey* Sink::add_tags() {
  // @@protoc_insertion_point(field_add:algebra.Sink.tags)
  return tags_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::NameOrIdKey >&
Sink::tags() const {
  // @@protoc_insertion_point(field_list:algebra.Sink.tags)
  return tags_;
}

// .algebra.Sink.SinkTarget sink_target = 2;
inline bool Sink::has_sink_target() const {
  return this != internal_default_instance() && sink_target_ != NULL;
}
inline void Sink::clear_sink_target() {
  if (GetArenaNoVirtual() == NULL && sink_target_ != NULL) {
    delete sink_target_;
  }
  sink_target_ = NULL;
}
inline const ::algebra::Sink_SinkTarget& Sink::_internal_sink_target() const {
  return *sink_target_;
}
inline const ::algebra::Sink_SinkTarget& Sink::sink_target() const {
  const ::algebra::Sink_SinkTarget* p = sink_target_;
  // @@protoc_insertion_point(field_get:algebra.Sink.sink_target)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::Sink_SinkTarget*>(
      &::algebra::_Sink_SinkTarget_default_instance_);
}
inline ::algebra::Sink_SinkTarget* Sink::release_sink_target() {
  // @@protoc_insertion_point(field_release:algebra.Sink.sink_target)
  
  ::algebra::Sink_SinkTarget* temp = sink_target_;
  sink_target_ = NULL;
  return temp;
}
inline ::algebra::Sink_SinkTarget* Sink::mutable_sink_target() {
  
  if (sink_target_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::Sink_SinkTarget>(GetArenaNoVirtual());
    sink_target_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.Sink.sink_target)
  return sink_target_;
}
inline void Sink::set_allocated_sink_target(::algebra::Sink_SinkTarget* sink_target) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sink_target_;
  }
  if (sink_target) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sink_target = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sink_target, submessage_arena);
    }
    
  } else {
    
  }
  sink_target_ = sink_target;
  // @@protoc_insertion_point(field_set_allocated:algebra.Sink.sink_target)
}

// -------------------------------------------------------------------

// SinkDefault_IdNameMapping

// int32 id = 1;
inline void SinkDefault_IdNameMapping::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 SinkDefault_IdNameMapping::id() const {
  // @@protoc_insertion_point(field_get:algebra.SinkDefault.IdNameMapping.id)
  return id_;
}
inline void SinkDefault_IdNameMapping::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:algebra.SinkDefault.IdNameMapping.id)
}

// string name = 2;
inline void SinkDefault_IdNameMapping::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SinkDefault_IdNameMapping::name() const {
  // @@protoc_insertion_point(field_get:algebra.SinkDefault.IdNameMapping.name)
  return name_.GetNoArena();
}
inline void SinkDefault_IdNameMapping::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:algebra.SinkDefault.IdNameMapping.name)
}
#if LANG_CXX11
inline void SinkDefault_IdNameMapping::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:algebra.SinkDefault.IdNameMapping.name)
}
#endif
inline void SinkDefault_IdNameMapping::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:algebra.SinkDefault.IdNameMapping.name)
}
inline void SinkDefault_IdNameMapping::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:algebra.SinkDefault.IdNameMapping.name)
}
inline ::std::string* SinkDefault_IdNameMapping::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:algebra.SinkDefault.IdNameMapping.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SinkDefault_IdNameMapping::release_name() {
  // @@protoc_insertion_point(field_release:algebra.SinkDefault.IdNameMapping.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SinkDefault_IdNameMapping::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:algebra.SinkDefault.IdNameMapping.name)
}

// .algebra.SinkDefault.MetaType meta_type = 3;
inline void SinkDefault_IdNameMapping::clear_meta_type() {
  meta_type_ = 0;
}
inline ::algebra::SinkDefault_MetaType SinkDefault_IdNameMapping::meta_type() const {
  // @@protoc_insertion_point(field_get:algebra.SinkDefault.IdNameMapping.meta_type)
  return static_cast< ::algebra::SinkDefault_MetaType >(meta_type_);
}
inline void SinkDefault_IdNameMapping::set_meta_type(::algebra::SinkDefault_MetaType value) {
  
  meta_type_ = value;
  // @@protoc_insertion_point(field_set:algebra.SinkDefault.IdNameMapping.meta_type)
}

// -------------------------------------------------------------------

// SinkDefault

// repeated .algebra.SinkDefault.IdNameMapping id_name_mappings = 1;
inline int SinkDefault::id_name_mappings_size() const {
  return id_name_mappings_.size();
}
inline void SinkDefault::clear_id_name_mappings() {
  id_name_mappings_.Clear();
}
inline ::algebra::SinkDefault_IdNameMapping* SinkDefault::mutable_id_name_mappings(int index) {
  // @@protoc_insertion_point(field_mutable:algebra.SinkDefault.id_name_mappings)
  return id_name_mappings_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::algebra::SinkDefault_IdNameMapping >*
SinkDefault::mutable_id_name_mappings() {
  // @@protoc_insertion_point(field_mutable_list:algebra.SinkDefault.id_name_mappings)
  return &id_name_mappings_;
}
inline const ::algebra::SinkDefault_IdNameMapping& SinkDefault::id_name_mappings(int index) const {
  // @@protoc_insertion_point(field_get:algebra.SinkDefault.id_name_mappings)
  return id_name_mappings_.Get(index);
}
inline ::algebra::SinkDefault_IdNameMapping* SinkDefault::add_id_name_mappings() {
  // @@protoc_insertion_point(field_add:algebra.SinkDefault.id_name_mappings)
  return id_name_mappings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::algebra::SinkDefault_IdNameMapping >&
SinkDefault::id_name_mappings() const {
  // @@protoc_insertion_point(field_list:algebra.SinkDefault.id_name_mappings)
  return id_name_mappings_;
}

// -------------------------------------------------------------------

// SinkVineyard

// string graph_name = 1;
inline void SinkVineyard::clear_graph_name() {
  graph_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SinkVineyard::graph_name() const {
  // @@protoc_insertion_point(field_get:algebra.SinkVineyard.graph_name)
  return graph_name_.GetNoArena();
}
inline void SinkVineyard::set_graph_name(const ::std::string& value) {
  
  graph_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:algebra.SinkVineyard.graph_name)
}
#if LANG_CXX11
inline void SinkVineyard::set_graph_name(::std::string&& value) {
  
  graph_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:algebra.SinkVineyard.graph_name)
}
#endif
inline void SinkVineyard::set_graph_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  graph_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:algebra.SinkVineyard.graph_name)
}
inline void SinkVineyard::set_graph_name(const char* value, size_t size) {
  
  graph_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:algebra.SinkVineyard.graph_name)
}
inline ::std::string* SinkVineyard::mutable_graph_name() {
  
  // @@protoc_insertion_point(field_mutable:algebra.SinkVineyard.graph_name)
  return graph_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SinkVineyard::release_graph_name() {
  // @@protoc_insertion_point(field_release:algebra.SinkVineyard.graph_name)
  
  return graph_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SinkVineyard::set_allocated_graph_name(::std::string* graph_name) {
  if (graph_name != NULL) {
    
  } else {
    
  }
  graph_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), graph_name);
  // @@protoc_insertion_point(field_set_allocated:algebra.SinkVineyard.graph_name)
}

// .schema.Schema graph_schema = 2;
inline bool SinkVineyard::has_graph_schema() const {
  return this != internal_default_instance() && graph_schema_ != NULL;
}
inline const ::schema::Schema& SinkVineyard::_internal_graph_schema() const {
  return *graph_schema_;
}
inline const ::schema::Schema& SinkVineyard::graph_schema() const {
  const ::schema::Schema* p = graph_schema_;
  // @@protoc_insertion_point(field_get:algebra.SinkVineyard.graph_schema)
  return p != NULL ? *p : *reinterpret_cast<const ::schema::Schema*>(
      &::schema::_Schema_default_instance_);
}
inline ::schema::Schema* SinkVineyard::release_graph_schema() {
  // @@protoc_insertion_point(field_release:algebra.SinkVineyard.graph_schema)
  
  ::schema::Schema* temp = graph_schema_;
  graph_schema_ = NULL;
  return temp;
}
inline ::schema::Schema* SinkVineyard::mutable_graph_schema() {
  
  if (graph_schema_ == NULL) {
    auto* p = CreateMaybeMessage<::schema::Schema>(GetArenaNoVirtual());
    graph_schema_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.SinkVineyard.graph_schema)
  return graph_schema_;
}
inline void SinkVineyard::set_allocated_graph_schema(::schema::Schema* graph_schema) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(graph_schema_);
  }
  if (graph_schema) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      graph_schema = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, graph_schema, submessage_arena);
    }
    
  } else {
    
  }
  graph_schema_ = graph_schema;
  // @@protoc_insertion_point(field_set_allocated:algebra.SinkVineyard.graph_schema)
}

// -------------------------------------------------------------------

// Root

// -------------------------------------------------------------------

// Branch

// -------------------------------------------------------------------

// LogicalPlan_Operator

// .algebra.Project project = 1;
inline bool LogicalPlan_Operator::has_project() const {
  return opr_case() == kProject;
}
inline void LogicalPlan_Operator::set_has_project() {
  _oneof_case_[0] = kProject;
}
inline void LogicalPlan_Operator::clear_project() {
  if (has_project()) {
    delete opr_.project_;
    clear_has_opr();
  }
}
inline const ::algebra::Project& LogicalPlan_Operator::_internal_project() const {
  return *opr_.project_;
}
inline ::algebra::Project* LogicalPlan_Operator::release_project() {
  // @@protoc_insertion_point(field_release:algebra.LogicalPlan.Operator.project)
  if (has_project()) {
    clear_has_opr();
      ::algebra::Project* temp = opr_.project_;
    opr_.project_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::Project& LogicalPlan_Operator::project() const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Operator.project)
  return has_project()
      ? *opr_.project_
      : *reinterpret_cast< ::algebra::Project*>(&::algebra::_Project_default_instance_);
}
inline ::algebra::Project* LogicalPlan_Operator::mutable_project() {
  if (!has_project()) {
    clear_opr();
    set_has_project();
    opr_.project_ = CreateMaybeMessage< ::algebra::Project >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.Operator.project)
  return opr_.project_;
}

// .algebra.Select select = 2;
inline bool LogicalPlan_Operator::has_select() const {
  return opr_case() == kSelect;
}
inline void LogicalPlan_Operator::set_has_select() {
  _oneof_case_[0] = kSelect;
}
inline void LogicalPlan_Operator::clear_select() {
  if (has_select()) {
    delete opr_.select_;
    clear_has_opr();
  }
}
inline const ::algebra::Select& LogicalPlan_Operator::_internal_select() const {
  return *opr_.select_;
}
inline ::algebra::Select* LogicalPlan_Operator::release_select() {
  // @@protoc_insertion_point(field_release:algebra.LogicalPlan.Operator.select)
  if (has_select()) {
    clear_has_opr();
      ::algebra::Select* temp = opr_.select_;
    opr_.select_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::Select& LogicalPlan_Operator::select() const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Operator.select)
  return has_select()
      ? *opr_.select_
      : *reinterpret_cast< ::algebra::Select*>(&::algebra::_Select_default_instance_);
}
inline ::algebra::Select* LogicalPlan_Operator::mutable_select() {
  if (!has_select()) {
    clear_opr();
    set_has_select();
    opr_.select_ = CreateMaybeMessage< ::algebra::Select >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.Operator.select)
  return opr_.select_;
}

// .algebra.Join join = 3;
inline bool LogicalPlan_Operator::has_join() const {
  return opr_case() == kJoin;
}
inline void LogicalPlan_Operator::set_has_join() {
  _oneof_case_[0] = kJoin;
}
inline void LogicalPlan_Operator::clear_join() {
  if (has_join()) {
    delete opr_.join_;
    clear_has_opr();
  }
}
inline const ::algebra::Join& LogicalPlan_Operator::_internal_join() const {
  return *opr_.join_;
}
inline ::algebra::Join* LogicalPlan_Operator::release_join() {
  // @@protoc_insertion_point(field_release:algebra.LogicalPlan.Operator.join)
  if (has_join()) {
    clear_has_opr();
      ::algebra::Join* temp = opr_.join_;
    opr_.join_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::Join& LogicalPlan_Operator::join() const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Operator.join)
  return has_join()
      ? *opr_.join_
      : *reinterpret_cast< ::algebra::Join*>(&::algebra::_Join_default_instance_);
}
inline ::algebra::Join* LogicalPlan_Operator::mutable_join() {
  if (!has_join()) {
    clear_opr();
    set_has_join();
    opr_.join_ = CreateMaybeMessage< ::algebra::Join >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.Operator.join)
  return opr_.join_;
}

// .algebra.Union union = 4;
inline bool LogicalPlan_Operator::has_union_() const {
  return opr_case() == kUnion;
}
inline void LogicalPlan_Operator::set_has_union_() {
  _oneof_case_[0] = kUnion;
}
inline void LogicalPlan_Operator::clear_union_() {
  if (has_union_()) {
    delete opr_.union__;
    clear_has_opr();
  }
}
inline const ::algebra::Union& LogicalPlan_Operator::_internal_union_() const {
  return *opr_.union__;
}
inline ::algebra::Union* LogicalPlan_Operator::release_union_() {
  // @@protoc_insertion_point(field_release:algebra.LogicalPlan.Operator.union)
  if (has_union_()) {
    clear_has_opr();
      ::algebra::Union* temp = opr_.union__;
    opr_.union__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::Union& LogicalPlan_Operator::union_() const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Operator.union)
  return has_union_()
      ? *opr_.union__
      : *reinterpret_cast< ::algebra::Union*>(&::algebra::_Union_default_instance_);
}
inline ::algebra::Union* LogicalPlan_Operator::mutable_union_() {
  if (!has_union_()) {
    clear_opr();
    set_has_union_();
    opr_.union__ = CreateMaybeMessage< ::algebra::Union >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.Operator.union)
  return opr_.union__;
}

// .algebra.GroupBy group_by = 5;
inline bool LogicalPlan_Operator::has_group_by() const {
  return opr_case() == kGroupBy;
}
inline void LogicalPlan_Operator::set_has_group_by() {
  _oneof_case_[0] = kGroupBy;
}
inline void LogicalPlan_Operator::clear_group_by() {
  if (has_group_by()) {
    delete opr_.group_by_;
    clear_has_opr();
  }
}
inline const ::algebra::GroupBy& LogicalPlan_Operator::_internal_group_by() const {
  return *opr_.group_by_;
}
inline ::algebra::GroupBy* LogicalPlan_Operator::release_group_by() {
  // @@protoc_insertion_point(field_release:algebra.LogicalPlan.Operator.group_by)
  if (has_group_by()) {
    clear_has_opr();
      ::algebra::GroupBy* temp = opr_.group_by_;
    opr_.group_by_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::GroupBy& LogicalPlan_Operator::group_by() const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Operator.group_by)
  return has_group_by()
      ? *opr_.group_by_
      : *reinterpret_cast< ::algebra::GroupBy*>(&::algebra::_GroupBy_default_instance_);
}
inline ::algebra::GroupBy* LogicalPlan_Operator::mutable_group_by() {
  if (!has_group_by()) {
    clear_opr();
    set_has_group_by();
    opr_.group_by_ = CreateMaybeMessage< ::algebra::GroupBy >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.Operator.group_by)
  return opr_.group_by_;
}

// .algebra.OrderBy order_by = 6;
inline bool LogicalPlan_Operator::has_order_by() const {
  return opr_case() == kOrderBy;
}
inline void LogicalPlan_Operator::set_has_order_by() {
  _oneof_case_[0] = kOrderBy;
}
inline void LogicalPlan_Operator::clear_order_by() {
  if (has_order_by()) {
    delete opr_.order_by_;
    clear_has_opr();
  }
}
inline const ::algebra::OrderBy& LogicalPlan_Operator::_internal_order_by() const {
  return *opr_.order_by_;
}
inline ::algebra::OrderBy* LogicalPlan_Operator::release_order_by() {
  // @@protoc_insertion_point(field_release:algebra.LogicalPlan.Operator.order_by)
  if (has_order_by()) {
    clear_has_opr();
      ::algebra::OrderBy* temp = opr_.order_by_;
    opr_.order_by_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::OrderBy& LogicalPlan_Operator::order_by() const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Operator.order_by)
  return has_order_by()
      ? *opr_.order_by_
      : *reinterpret_cast< ::algebra::OrderBy*>(&::algebra::_OrderBy_default_instance_);
}
inline ::algebra::OrderBy* LogicalPlan_Operator::mutable_order_by() {
  if (!has_order_by()) {
    clear_opr();
    set_has_order_by();
    opr_.order_by_ = CreateMaybeMessage< ::algebra::OrderBy >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.Operator.order_by)
  return opr_.order_by_;
}

// .algebra.Dedup dedup = 7;
inline bool LogicalPlan_Operator::has_dedup() const {
  return opr_case() == kDedup;
}
inline void LogicalPlan_Operator::set_has_dedup() {
  _oneof_case_[0] = kDedup;
}
inline void LogicalPlan_Operator::clear_dedup() {
  if (has_dedup()) {
    delete opr_.dedup_;
    clear_has_opr();
  }
}
inline const ::algebra::Dedup& LogicalPlan_Operator::_internal_dedup() const {
  return *opr_.dedup_;
}
inline ::algebra::Dedup* LogicalPlan_Operator::release_dedup() {
  // @@protoc_insertion_point(field_release:algebra.LogicalPlan.Operator.dedup)
  if (has_dedup()) {
    clear_has_opr();
      ::algebra::Dedup* temp = opr_.dedup_;
    opr_.dedup_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::Dedup& LogicalPlan_Operator::dedup() const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Operator.dedup)
  return has_dedup()
      ? *opr_.dedup_
      : *reinterpret_cast< ::algebra::Dedup*>(&::algebra::_Dedup_default_instance_);
}
inline ::algebra::Dedup* LogicalPlan_Operator::mutable_dedup() {
  if (!has_dedup()) {
    clear_opr();
    set_has_dedup();
    opr_.dedup_ = CreateMaybeMessage< ::algebra::Dedup >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.Operator.dedup)
  return opr_.dedup_;
}

// .algebra.Unfold unfold = 8;
inline bool LogicalPlan_Operator::has_unfold() const {
  return opr_case() == kUnfold;
}
inline void LogicalPlan_Operator::set_has_unfold() {
  _oneof_case_[0] = kUnfold;
}
inline void LogicalPlan_Operator::clear_unfold() {
  if (has_unfold()) {
    delete opr_.unfold_;
    clear_has_opr();
  }
}
inline const ::algebra::Unfold& LogicalPlan_Operator::_internal_unfold() const {
  return *opr_.unfold_;
}
inline ::algebra::Unfold* LogicalPlan_Operator::release_unfold() {
  // @@protoc_insertion_point(field_release:algebra.LogicalPlan.Operator.unfold)
  if (has_unfold()) {
    clear_has_opr();
      ::algebra::Unfold* temp = opr_.unfold_;
    opr_.unfold_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::Unfold& LogicalPlan_Operator::unfold() const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Operator.unfold)
  return has_unfold()
      ? *opr_.unfold_
      : *reinterpret_cast< ::algebra::Unfold*>(&::algebra::_Unfold_default_instance_);
}
inline ::algebra::Unfold* LogicalPlan_Operator::mutable_unfold() {
  if (!has_unfold()) {
    clear_opr();
    set_has_unfold();
    opr_.unfold_ = CreateMaybeMessage< ::algebra::Unfold >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.Operator.unfold)
  return opr_.unfold_;
}

// .algebra.Apply apply = 9;
inline bool LogicalPlan_Operator::has_apply() const {
  return opr_case() == kApply;
}
inline void LogicalPlan_Operator::set_has_apply() {
  _oneof_case_[0] = kApply;
}
inline void LogicalPlan_Operator::clear_apply() {
  if (has_apply()) {
    delete opr_.apply_;
    clear_has_opr();
  }
}
inline const ::algebra::Apply& LogicalPlan_Operator::_internal_apply() const {
  return *opr_.apply_;
}
inline ::algebra::Apply* LogicalPlan_Operator::release_apply() {
  // @@protoc_insertion_point(field_release:algebra.LogicalPlan.Operator.apply)
  if (has_apply()) {
    clear_has_opr();
      ::algebra::Apply* temp = opr_.apply_;
    opr_.apply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::Apply& LogicalPlan_Operator::apply() const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Operator.apply)
  return has_apply()
      ? *opr_.apply_
      : *reinterpret_cast< ::algebra::Apply*>(&::algebra::_Apply_default_instance_);
}
inline ::algebra::Apply* LogicalPlan_Operator::mutable_apply() {
  if (!has_apply()) {
    clear_opr();
    set_has_apply();
    opr_.apply_ = CreateMaybeMessage< ::algebra::Apply >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.Operator.apply)
  return opr_.apply_;
}

// .algebra.SegmentApply seg_apply = 10;
inline bool LogicalPlan_Operator::has_seg_apply() const {
  return opr_case() == kSegApply;
}
inline void LogicalPlan_Operator::set_has_seg_apply() {
  _oneof_case_[0] = kSegApply;
}
inline void LogicalPlan_Operator::clear_seg_apply() {
  if (has_seg_apply()) {
    delete opr_.seg_apply_;
    clear_has_opr();
  }
}
inline const ::algebra::SegmentApply& LogicalPlan_Operator::_internal_seg_apply() const {
  return *opr_.seg_apply_;
}
inline ::algebra::SegmentApply* LogicalPlan_Operator::release_seg_apply() {
  // @@protoc_insertion_point(field_release:algebra.LogicalPlan.Operator.seg_apply)
  if (has_seg_apply()) {
    clear_has_opr();
      ::algebra::SegmentApply* temp = opr_.seg_apply_;
    opr_.seg_apply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::SegmentApply& LogicalPlan_Operator::seg_apply() const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Operator.seg_apply)
  return has_seg_apply()
      ? *opr_.seg_apply_
      : *reinterpret_cast< ::algebra::SegmentApply*>(&::algebra::_SegmentApply_default_instance_);
}
inline ::algebra::SegmentApply* LogicalPlan_Operator::mutable_seg_apply() {
  if (!has_seg_apply()) {
    clear_opr();
    set_has_seg_apply();
    opr_.seg_apply_ = CreateMaybeMessage< ::algebra::SegmentApply >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.Operator.seg_apply)
  return opr_.seg_apply_;
}

// .algebra.Scan scan = 11;
inline bool LogicalPlan_Operator::has_scan() const {
  return opr_case() == kScan;
}
inline void LogicalPlan_Operator::set_has_scan() {
  _oneof_case_[0] = kScan;
}
inline void LogicalPlan_Operator::clear_scan() {
  if (has_scan()) {
    delete opr_.scan_;
    clear_has_opr();
  }
}
inline const ::algebra::Scan& LogicalPlan_Operator::_internal_scan() const {
  return *opr_.scan_;
}
inline ::algebra::Scan* LogicalPlan_Operator::release_scan() {
  // @@protoc_insertion_point(field_release:algebra.LogicalPlan.Operator.scan)
  if (has_scan()) {
    clear_has_opr();
      ::algebra::Scan* temp = opr_.scan_;
    opr_.scan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::Scan& LogicalPlan_Operator::scan() const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Operator.scan)
  return has_scan()
      ? *opr_.scan_
      : *reinterpret_cast< ::algebra::Scan*>(&::algebra::_Scan_default_instance_);
}
inline ::algebra::Scan* LogicalPlan_Operator::mutable_scan() {
  if (!has_scan()) {
    clear_opr();
    set_has_scan();
    opr_.scan_ = CreateMaybeMessage< ::algebra::Scan >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.Operator.scan)
  return opr_.scan_;
}

// .algebra.Limit limit = 12;
inline bool LogicalPlan_Operator::has_limit() const {
  return opr_case() == kLimit;
}
inline void LogicalPlan_Operator::set_has_limit() {
  _oneof_case_[0] = kLimit;
}
inline void LogicalPlan_Operator::clear_limit() {
  if (has_limit()) {
    delete opr_.limit_;
    clear_has_opr();
  }
}
inline const ::algebra::Limit& LogicalPlan_Operator::_internal_limit() const {
  return *opr_.limit_;
}
inline ::algebra::Limit* LogicalPlan_Operator::release_limit() {
  // @@protoc_insertion_point(field_release:algebra.LogicalPlan.Operator.limit)
  if (has_limit()) {
    clear_has_opr();
      ::algebra::Limit* temp = opr_.limit_;
    opr_.limit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::Limit& LogicalPlan_Operator::limit() const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Operator.limit)
  return has_limit()
      ? *opr_.limit_
      : *reinterpret_cast< ::algebra::Limit*>(&::algebra::_Limit_default_instance_);
}
inline ::algebra::Limit* LogicalPlan_Operator::mutable_limit() {
  if (!has_limit()) {
    clear_opr();
    set_has_limit();
    opr_.limit_ = CreateMaybeMessage< ::algebra::Limit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.Operator.limit)
  return opr_.limit_;
}

// .algebra.As as = 14;
inline bool LogicalPlan_Operator::has_as() const {
  return opr_case() == kAs;
}
inline void LogicalPlan_Operator::set_has_as() {
  _oneof_case_[0] = kAs;
}
inline void LogicalPlan_Operator::clear_as() {
  if (has_as()) {
    delete opr_.as_;
    clear_has_opr();
  }
}
inline const ::algebra::As& LogicalPlan_Operator::_internal_as() const {
  return *opr_.as_;
}
inline ::algebra::As* LogicalPlan_Operator::release_as() {
  // @@protoc_insertion_point(field_release:algebra.LogicalPlan.Operator.as)
  if (has_as()) {
    clear_has_opr();
      ::algebra::As* temp = opr_.as_;
    opr_.as_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::As& LogicalPlan_Operator::as() const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Operator.as)
  return has_as()
      ? *opr_.as_
      : *reinterpret_cast< ::algebra::As*>(&::algebra::_As_default_instance_);
}
inline ::algebra::As* LogicalPlan_Operator::mutable_as() {
  if (!has_as()) {
    clear_opr();
    set_has_as();
    opr_.as_ = CreateMaybeMessage< ::algebra::As >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.Operator.as)
  return opr_.as_;
}

// .algebra.Intersect intersect = 15;
inline bool LogicalPlan_Operator::has_intersect() const {
  return opr_case() == kIntersect;
}
inline void LogicalPlan_Operator::set_has_intersect() {
  _oneof_case_[0] = kIntersect;
}
inline void LogicalPlan_Operator::clear_intersect() {
  if (has_intersect()) {
    delete opr_.intersect_;
    clear_has_opr();
  }
}
inline const ::algebra::Intersect& LogicalPlan_Operator::_internal_intersect() const {
  return *opr_.intersect_;
}
inline ::algebra::Intersect* LogicalPlan_Operator::release_intersect() {
  // @@protoc_insertion_point(field_release:algebra.LogicalPlan.Operator.intersect)
  if (has_intersect()) {
    clear_has_opr();
      ::algebra::Intersect* temp = opr_.intersect_;
    opr_.intersect_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::Intersect& LogicalPlan_Operator::intersect() const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Operator.intersect)
  return has_intersect()
      ? *opr_.intersect_
      : *reinterpret_cast< ::algebra::Intersect*>(&::algebra::_Intersect_default_instance_);
}
inline ::algebra::Intersect* LogicalPlan_Operator::mutable_intersect() {
  if (!has_intersect()) {
    clear_opr();
    set_has_intersect();
    opr_.intersect_ = CreateMaybeMessage< ::algebra::Intersect >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.Operator.intersect)
  return opr_.intersect_;
}

// .algebra.Sink sink = 16;
inline bool LogicalPlan_Operator::has_sink() const {
  return opr_case() == kSink;
}
inline void LogicalPlan_Operator::set_has_sink() {
  _oneof_case_[0] = kSink;
}
inline void LogicalPlan_Operator::clear_sink() {
  if (has_sink()) {
    delete opr_.sink_;
    clear_has_opr();
  }
}
inline const ::algebra::Sink& LogicalPlan_Operator::_internal_sink() const {
  return *opr_.sink_;
}
inline ::algebra::Sink* LogicalPlan_Operator::release_sink() {
  // @@protoc_insertion_point(field_release:algebra.LogicalPlan.Operator.sink)
  if (has_sink()) {
    clear_has_opr();
      ::algebra::Sink* temp = opr_.sink_;
    opr_.sink_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::Sink& LogicalPlan_Operator::sink() const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Operator.sink)
  return has_sink()
      ? *opr_.sink_
      : *reinterpret_cast< ::algebra::Sink*>(&::algebra::_Sink_default_instance_);
}
inline ::algebra::Sink* LogicalPlan_Operator::mutable_sink() {
  if (!has_sink()) {
    clear_opr();
    set_has_sink();
    opr_.sink_ = CreateMaybeMessage< ::algebra::Sink >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.Operator.sink)
  return opr_.sink_;
}

// .algebra.Root root = 17;
inline bool LogicalPlan_Operator::has_root() const {
  return opr_case() == kRoot;
}
inline void LogicalPlan_Operator::set_has_root() {
  _oneof_case_[0] = kRoot;
}
inline void LogicalPlan_Operator::clear_root() {
  if (has_root()) {
    delete opr_.root_;
    clear_has_opr();
  }
}
inline const ::algebra::Root& LogicalPlan_Operator::_internal_root() const {
  return *opr_.root_;
}
inline ::algebra::Root* LogicalPlan_Operator::release_root() {
  // @@protoc_insertion_point(field_release:algebra.LogicalPlan.Operator.root)
  if (has_root()) {
    clear_has_opr();
      ::algebra::Root* temp = opr_.root_;
    opr_.root_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::Root& LogicalPlan_Operator::root() const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Operator.root)
  return has_root()
      ? *opr_.root_
      : *reinterpret_cast< ::algebra::Root*>(&::algebra::_Root_default_instance_);
}
inline ::algebra::Root* LogicalPlan_Operator::mutable_root() {
  if (!has_root()) {
    clear_opr();
    set_has_root();
    opr_.root_ = CreateMaybeMessage< ::algebra::Root >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.Operator.root)
  return opr_.root_;
}

// .algebra.Sample sample = 18;
inline bool LogicalPlan_Operator::has_sample() const {
  return opr_case() == kSample;
}
inline void LogicalPlan_Operator::set_has_sample() {
  _oneof_case_[0] = kSample;
}
inline void LogicalPlan_Operator::clear_sample() {
  if (has_sample()) {
    delete opr_.sample_;
    clear_has_opr();
  }
}
inline const ::algebra::Sample& LogicalPlan_Operator::_internal_sample() const {
  return *opr_.sample_;
}
inline ::algebra::Sample* LogicalPlan_Operator::release_sample() {
  // @@protoc_insertion_point(field_release:algebra.LogicalPlan.Operator.sample)
  if (has_sample()) {
    clear_has_opr();
      ::algebra::Sample* temp = opr_.sample_;
    opr_.sample_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::Sample& LogicalPlan_Operator::sample() const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Operator.sample)
  return has_sample()
      ? *opr_.sample_
      : *reinterpret_cast< ::algebra::Sample*>(&::algebra::_Sample_default_instance_);
}
inline ::algebra::Sample* LogicalPlan_Operator::mutable_sample() {
  if (!has_sample()) {
    clear_opr();
    set_has_sample();
    opr_.sample_ = CreateMaybeMessage< ::algebra::Sample >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.Operator.sample)
  return opr_.sample_;
}

// .algebra.Branch branch = 19;
inline bool LogicalPlan_Operator::has_branch() const {
  return opr_case() == kBranch;
}
inline void LogicalPlan_Operator::set_has_branch() {
  _oneof_case_[0] = kBranch;
}
inline void LogicalPlan_Operator::clear_branch() {
  if (has_branch()) {
    delete opr_.branch_;
    clear_has_opr();
  }
}
inline const ::algebra::Branch& LogicalPlan_Operator::_internal_branch() const {
  return *opr_.branch_;
}
inline ::algebra::Branch* LogicalPlan_Operator::release_branch() {
  // @@protoc_insertion_point(field_release:algebra.LogicalPlan.Operator.branch)
  if (has_branch()) {
    clear_has_opr();
      ::algebra::Branch* temp = opr_.branch_;
    opr_.branch_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::Branch& LogicalPlan_Operator::branch() const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Operator.branch)
  return has_branch()
      ? *opr_.branch_
      : *reinterpret_cast< ::algebra::Branch*>(&::algebra::_Branch_default_instance_);
}
inline ::algebra::Branch* LogicalPlan_Operator::mutable_branch() {
  if (!has_branch()) {
    clear_opr();
    set_has_branch();
    opr_.branch_ = CreateMaybeMessage< ::algebra::Branch >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.Operator.branch)
  return opr_.branch_;
}

// .algebra.GetV vertex = 30;
inline bool LogicalPlan_Operator::has_vertex() const {
  return opr_case() == kVertex;
}
inline void LogicalPlan_Operator::set_has_vertex() {
  _oneof_case_[0] = kVertex;
}
inline void LogicalPlan_Operator::clear_vertex() {
  if (has_vertex()) {
    delete opr_.vertex_;
    clear_has_opr();
  }
}
inline const ::algebra::GetV& LogicalPlan_Operator::_internal_vertex() const {
  return *opr_.vertex_;
}
inline ::algebra::GetV* LogicalPlan_Operator::release_vertex() {
  // @@protoc_insertion_point(field_release:algebra.LogicalPlan.Operator.vertex)
  if (has_vertex()) {
    clear_has_opr();
      ::algebra::GetV* temp = opr_.vertex_;
    opr_.vertex_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::GetV& LogicalPlan_Operator::vertex() const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Operator.vertex)
  return has_vertex()
      ? *opr_.vertex_
      : *reinterpret_cast< ::algebra::GetV*>(&::algebra::_GetV_default_instance_);
}
inline ::algebra::GetV* LogicalPlan_Operator::mutable_vertex() {
  if (!has_vertex()) {
    clear_opr();
    set_has_vertex();
    opr_.vertex_ = CreateMaybeMessage< ::algebra::GetV >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.Operator.vertex)
  return opr_.vertex_;
}

// .algebra.EdgeExpand edge = 31;
inline bool LogicalPlan_Operator::has_edge() const {
  return opr_case() == kEdge;
}
inline void LogicalPlan_Operator::set_has_edge() {
  _oneof_case_[0] = kEdge;
}
inline void LogicalPlan_Operator::clear_edge() {
  if (has_edge()) {
    delete opr_.edge_;
    clear_has_opr();
  }
}
inline const ::algebra::EdgeExpand& LogicalPlan_Operator::_internal_edge() const {
  return *opr_.edge_;
}
inline ::algebra::EdgeExpand* LogicalPlan_Operator::release_edge() {
  // @@protoc_insertion_point(field_release:algebra.LogicalPlan.Operator.edge)
  if (has_edge()) {
    clear_has_opr();
      ::algebra::EdgeExpand* temp = opr_.edge_;
    opr_.edge_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::EdgeExpand& LogicalPlan_Operator::edge() const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Operator.edge)
  return has_edge()
      ? *opr_.edge_
      : *reinterpret_cast< ::algebra::EdgeExpand*>(&::algebra::_EdgeExpand_default_instance_);
}
inline ::algebra::EdgeExpand* LogicalPlan_Operator::mutable_edge() {
  if (!has_edge()) {
    clear_opr();
    set_has_edge();
    opr_.edge_ = CreateMaybeMessage< ::algebra::EdgeExpand >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.Operator.edge)
  return opr_.edge_;
}

// .algebra.PathExpand path = 32;
inline bool LogicalPlan_Operator::has_path() const {
  return opr_case() == kPath;
}
inline void LogicalPlan_Operator::set_has_path() {
  _oneof_case_[0] = kPath;
}
inline void LogicalPlan_Operator::clear_path() {
  if (has_path()) {
    delete opr_.path_;
    clear_has_opr();
  }
}
inline const ::algebra::PathExpand& LogicalPlan_Operator::_internal_path() const {
  return *opr_.path_;
}
inline ::algebra::PathExpand* LogicalPlan_Operator::release_path() {
  // @@protoc_insertion_point(field_release:algebra.LogicalPlan.Operator.path)
  if (has_path()) {
    clear_has_opr();
      ::algebra::PathExpand* temp = opr_.path_;
    opr_.path_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::PathExpand& LogicalPlan_Operator::path() const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Operator.path)
  return has_path()
      ? *opr_.path_
      : *reinterpret_cast< ::algebra::PathExpand*>(&::algebra::_PathExpand_default_instance_);
}
inline ::algebra::PathExpand* LogicalPlan_Operator::mutable_path() {
  if (!has_path()) {
    clear_opr();
    set_has_path();
    opr_.path_ = CreateMaybeMessage< ::algebra::PathExpand >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.Operator.path)
  return opr_.path_;
}

// .algebra.Pattern pattern = 35;
inline bool LogicalPlan_Operator::has_pattern() const {
  return opr_case() == kPattern;
}
inline void LogicalPlan_Operator::set_has_pattern() {
  _oneof_case_[0] = kPattern;
}
inline void LogicalPlan_Operator::clear_pattern() {
  if (has_pattern()) {
    delete opr_.pattern_;
    clear_has_opr();
  }
}
inline const ::algebra::Pattern& LogicalPlan_Operator::_internal_pattern() const {
  return *opr_.pattern_;
}
inline ::algebra::Pattern* LogicalPlan_Operator::release_pattern() {
  // @@protoc_insertion_point(field_release:algebra.LogicalPlan.Operator.pattern)
  if (has_pattern()) {
    clear_has_opr();
      ::algebra::Pattern* temp = opr_.pattern_;
    opr_.pattern_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::algebra::Pattern& LogicalPlan_Operator::pattern() const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Operator.pattern)
  return has_pattern()
      ? *opr_.pattern_
      : *reinterpret_cast< ::algebra::Pattern*>(&::algebra::_Pattern_default_instance_);
}
inline ::algebra::Pattern* LogicalPlan_Operator::mutable_pattern() {
  if (!has_pattern()) {
    clear_opr();
    set_has_pattern();
    opr_.pattern_ = CreateMaybeMessage< ::algebra::Pattern >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.Operator.pattern)
  return opr_.pattern_;
}

inline bool LogicalPlan_Operator::has_opr() const {
  return opr_case() != OPR_NOT_SET;
}
inline void LogicalPlan_Operator::clear_has_opr() {
  _oneof_case_[0] = OPR_NOT_SET;
}
inline LogicalPlan_Operator::OprCase LogicalPlan_Operator::opr_case() const {
  return LogicalPlan_Operator::OprCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LogicalPlan_Node

// .algebra.LogicalPlan.Operator opr = 1;
inline bool LogicalPlan_Node::has_opr() const {
  return this != internal_default_instance() && opr_ != NULL;
}
inline void LogicalPlan_Node::clear_opr() {
  if (GetArenaNoVirtual() == NULL && opr_ != NULL) {
    delete opr_;
  }
  opr_ = NULL;
}
inline const ::algebra::LogicalPlan_Operator& LogicalPlan_Node::_internal_opr() const {
  return *opr_;
}
inline const ::algebra::LogicalPlan_Operator& LogicalPlan_Node::opr() const {
  const ::algebra::LogicalPlan_Operator* p = opr_;
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Node.opr)
  return p != NULL ? *p : *reinterpret_cast<const ::algebra::LogicalPlan_Operator*>(
      &::algebra::_LogicalPlan_Operator_default_instance_);
}
inline ::algebra::LogicalPlan_Operator* LogicalPlan_Node::release_opr() {
  // @@protoc_insertion_point(field_release:algebra.LogicalPlan.Node.opr)
  
  ::algebra::LogicalPlan_Operator* temp = opr_;
  opr_ = NULL;
  return temp;
}
inline ::algebra::LogicalPlan_Operator* LogicalPlan_Node::mutable_opr() {
  
  if (opr_ == NULL) {
    auto* p = CreateMaybeMessage<::algebra::LogicalPlan_Operator>(GetArenaNoVirtual());
    opr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.Node.opr)
  return opr_;
}
inline void LogicalPlan_Node::set_allocated_opr(::algebra::LogicalPlan_Operator* opr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete opr_;
  }
  if (opr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      opr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, opr, submessage_arena);
    }
    
  } else {
    
  }
  opr_ = opr;
  // @@protoc_insertion_point(field_set_allocated:algebra.LogicalPlan.Node.opr)
}

// repeated int32 children = 2;
inline int LogicalPlan_Node::children_size() const {
  return children_.size();
}
inline void LogicalPlan_Node::clear_children() {
  children_.Clear();
}
inline ::google::protobuf::int32 LogicalPlan_Node::children(int index) const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.Node.children)
  return children_.Get(index);
}
inline void LogicalPlan_Node::set_children(int index, ::google::protobuf::int32 value) {
  children_.Set(index, value);
  // @@protoc_insertion_point(field_set:algebra.LogicalPlan.Node.children)
}
inline void LogicalPlan_Node::add_children(::google::protobuf::int32 value) {
  children_.Add(value);
  // @@protoc_insertion_point(field_add:algebra.LogicalPlan.Node.children)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LogicalPlan_Node::children() const {
  // @@protoc_insertion_point(field_list:algebra.LogicalPlan.Node.children)
  return children_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LogicalPlan_Node::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:algebra.LogicalPlan.Node.children)
  return &children_;
}

// -------------------------------------------------------------------

// LogicalPlan

// repeated .algebra.LogicalPlan.Node nodes = 1;
inline int LogicalPlan::nodes_size() const {
  return nodes_.size();
}
inline void LogicalPlan::clear_nodes() {
  nodes_.Clear();
}
inline ::algebra::LogicalPlan_Node* LogicalPlan::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:algebra.LogicalPlan.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::algebra::LogicalPlan_Node >*
LogicalPlan::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:algebra.LogicalPlan.nodes)
  return &nodes_;
}
inline const ::algebra::LogicalPlan_Node& LogicalPlan::nodes(int index) const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.nodes)
  return nodes_.Get(index);
}
inline ::algebra::LogicalPlan_Node* LogicalPlan::add_nodes() {
  // @@protoc_insertion_point(field_add:algebra.LogicalPlan.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::algebra::LogicalPlan_Node >&
LogicalPlan::nodes() const {
  // @@protoc_insertion_point(field_list:algebra.LogicalPlan.nodes)
  return nodes_;
}

// repeated int32 roots = 2;
inline int LogicalPlan::roots_size() const {
  return roots_.size();
}
inline void LogicalPlan::clear_roots() {
  roots_.Clear();
}
inline ::google::protobuf::int32 LogicalPlan::roots(int index) const {
  // @@protoc_insertion_point(field_get:algebra.LogicalPlan.roots)
  return roots_.Get(index);
}
inline void LogicalPlan::set_roots(int index, ::google::protobuf::int32 value) {
  roots_.Set(index, value);
  // @@protoc_insertion_point(field_set:algebra.LogicalPlan.roots)
}
inline void LogicalPlan::add_roots(::google::protobuf::int32 value) {
  roots_.Add(value);
  // @@protoc_insertion_point(field_add:algebra.LogicalPlan.roots)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LogicalPlan::roots() const {
  // @@protoc_insertion_point(field_list:algebra.LogicalPlan.roots)
  return roots_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LogicalPlan::mutable_roots() {
  // @@protoc_insertion_point(field_mutable_list:algebra.LogicalPlan.roots)
  return &roots_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace algebra

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::algebra::Join_JoinKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::algebra::Join_JoinKind>() {
  return ::algebra::Join_JoinKind_descriptor();
}
template <> struct is_proto_enum< ::algebra::GroupBy_AggFunc_Aggregate> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::algebra::GroupBy_AggFunc_Aggregate>() {
  return ::algebra::GroupBy_AggFunc_Aggregate_descriptor();
}
template <> struct is_proto_enum< ::algebra::OrderBy_OrderingPair_Order> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::algebra::OrderBy_OrderingPair_Order>() {
  return ::algebra::OrderBy_OrderingPair_Order_descriptor();
}
template <> struct is_proto_enum< ::algebra::Scan_ScanOpt> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::algebra::Scan_ScanOpt>() {
  return ::algebra::Scan_ScanOpt_descriptor();
}
template <> struct is_proto_enum< ::algebra::GetV_VOpt> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::algebra::GetV_VOpt>() {
  return ::algebra::GetV_VOpt_descriptor();
}
template <> struct is_proto_enum< ::algebra::EdgeExpand_Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::algebra::EdgeExpand_Direction>() {
  return ::algebra::EdgeExpand_Direction_descriptor();
}
template <> struct is_proto_enum< ::algebra::EdgeExpand_ExpandOpt> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::algebra::EdgeExpand_ExpandOpt>() {
  return ::algebra::EdgeExpand_ExpandOpt_descriptor();
}
template <> struct is_proto_enum< ::algebra::PathExpand_PathOpt> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::algebra::PathExpand_PathOpt>() {
  return ::algebra::PathExpand_PathOpt_descriptor();
}
template <> struct is_proto_enum< ::algebra::PathExpand_ResultOpt> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::algebra::PathExpand_ResultOpt>() {
  return ::algebra::PathExpand_ResultOpt_descriptor();
}
template <> struct is_proto_enum< ::algebra::SinkDefault_MetaType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::algebra::SinkDefault_MetaType>() {
  return ::algebra::SinkDefault_MetaType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_algebra_2eproto
