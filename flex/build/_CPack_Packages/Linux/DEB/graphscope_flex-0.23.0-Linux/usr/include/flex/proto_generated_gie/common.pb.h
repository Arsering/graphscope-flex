// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef PROTOBUF_INCLUDED_common_2eproto
#define PROTOBUF_INCLUDED_common_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_common_2eproto 

namespace protobuf_common_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_common_2eproto
namespace common {
class DoubleArray;
class DoubleArrayDefaultTypeInternal;
extern DoubleArrayDefaultTypeInternal _DoubleArray_default_instance_;
class I32Array;
class I32ArrayDefaultTypeInternal;
extern I32ArrayDefaultTypeInternal _I32Array_default_instance_;
class I64Array;
class I64ArrayDefaultTypeInternal;
extern I64ArrayDefaultTypeInternal _I64Array_default_instance_;
class NameOrId;
class NameOrIdDefaultTypeInternal;
extern NameOrIdDefaultTypeInternal _NameOrId_default_instance_;
class None;
class NoneDefaultTypeInternal;
extern NoneDefaultTypeInternal _None_default_instance_;
class Pair;
class PairDefaultTypeInternal;
extern PairDefaultTypeInternal _Pair_default_instance_;
class PairArray;
class PairArrayDefaultTypeInternal;
extern PairArrayDefaultTypeInternal _PairArray_default_instance_;
class StringArray;
class StringArrayDefaultTypeInternal;
extern StringArrayDefaultTypeInternal _StringArray_default_instance_;
class Value;
class ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
}  // namespace common
namespace google {
namespace protobuf {
template<> ::common::DoubleArray* Arena::CreateMaybeMessage<::common::DoubleArray>(Arena*);
template<> ::common::I32Array* Arena::CreateMaybeMessage<::common::I32Array>(Arena*);
template<> ::common::I64Array* Arena::CreateMaybeMessage<::common::I64Array>(Arena*);
template<> ::common::NameOrId* Arena::CreateMaybeMessage<::common::NameOrId>(Arena*);
template<> ::common::None* Arena::CreateMaybeMessage<::common::None>(Arena*);
template<> ::common::Pair* Arena::CreateMaybeMessage<::common::Pair>(Arena*);
template<> ::common::PairArray* Arena::CreateMaybeMessage<::common::PairArray>(Arena*);
template<> ::common::StringArray* Arena::CreateMaybeMessage<::common::StringArray>(Arena*);
template<> ::common::Value* Arena::CreateMaybeMessage<::common::Value>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace common {

enum DataType {
  BOOLEAN = 0,
  INT32 = 1,
  INT64 = 2,
  DOUBLE = 3,
  STRING = 4,
  BYTES = 5,
  INT32_ARRAY = 6,
  INT64_ARRAY = 7,
  DOUBLE_ARRAY = 8,
  STRING_ARRAY = 9,
  PAIR_ARRAY = 10,
  NONE = 11,
  DATE = 12,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DataType_IsValid(int value);
const DataType DataType_MIN = BOOLEAN;
const DataType DataType_MAX = DATE;
const int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataType_descriptor();
inline const ::std::string& DataType_Name(DataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataType_descriptor(), value);
}
inline bool DataType_Parse(
    const ::std::string& name, DataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
// ===================================================================

class None : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.None) */ {
 public:
  None();
  virtual ~None();

  None(const None& from);

  inline None& operator=(const None& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  None(None&& from) noexcept
    : None() {
    *this = ::std::move(from);
  }

  inline None& operator=(None&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const None& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const None* internal_default_instance() {
    return reinterpret_cast<const None*>(
               &_None_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(None* other);
  friend void swap(None& a, None& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline None* New() const final {
    return CreateMaybeMessage<None>(NULL);
  }

  None* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<None>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const None& from);
  void MergeFrom(const None& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(None* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:common.None)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class I32Array : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.I32Array) */ {
 public:
  I32Array();
  virtual ~I32Array();

  I32Array(const I32Array& from);

  inline I32Array& operator=(const I32Array& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  I32Array(I32Array&& from) noexcept
    : I32Array() {
    *this = ::std::move(from);
  }

  inline I32Array& operator=(I32Array&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const I32Array& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const I32Array* internal_default_instance() {
    return reinterpret_cast<const I32Array*>(
               &_I32Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(I32Array* other);
  friend void swap(I32Array& a, I32Array& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline I32Array* New() const final {
    return CreateMaybeMessage<I32Array>(NULL);
  }

  I32Array* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<I32Array>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const I32Array& from);
  void MergeFrom(const I32Array& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(I32Array* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  ::google::protobuf::int32 item(int index) const;
  void set_item(int index, ::google::protobuf::int32 value);
  void add_item(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      item() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_item();

  // @@protoc_insertion_point(class_scope:common.I32Array)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > item_;
  mutable int _item_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class I64Array : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.I64Array) */ {
 public:
  I64Array();
  virtual ~I64Array();

  I64Array(const I64Array& from);

  inline I64Array& operator=(const I64Array& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  I64Array(I64Array&& from) noexcept
    : I64Array() {
    *this = ::std::move(from);
  }

  inline I64Array& operator=(I64Array&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const I64Array& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const I64Array* internal_default_instance() {
    return reinterpret_cast<const I64Array*>(
               &_I64Array_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(I64Array* other);
  friend void swap(I64Array& a, I64Array& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline I64Array* New() const final {
    return CreateMaybeMessage<I64Array>(NULL);
  }

  I64Array* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<I64Array>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const I64Array& from);
  void MergeFrom(const I64Array& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(I64Array* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  ::google::protobuf::int64 item(int index) const;
  void set_item(int index, ::google::protobuf::int64 value);
  void add_item(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      item() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_item();

  // @@protoc_insertion_point(class_scope:common.I64Array)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > item_;
  mutable int _item_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DoubleArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.DoubleArray) */ {
 public:
  DoubleArray();
  virtual ~DoubleArray();

  DoubleArray(const DoubleArray& from);

  inline DoubleArray& operator=(const DoubleArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DoubleArray(DoubleArray&& from) noexcept
    : DoubleArray() {
    *this = ::std::move(from);
  }

  inline DoubleArray& operator=(DoubleArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DoubleArray& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DoubleArray* internal_default_instance() {
    return reinterpret_cast<const DoubleArray*>(
               &_DoubleArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(DoubleArray* other);
  friend void swap(DoubleArray& a, DoubleArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DoubleArray* New() const final {
    return CreateMaybeMessage<DoubleArray>(NULL);
  }

  DoubleArray* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DoubleArray>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DoubleArray& from);
  void MergeFrom(const DoubleArray& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoubleArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  double item(int index) const;
  void set_item(int index, double value);
  void add_item(double value);
  const ::google::protobuf::RepeatedField< double >&
      item() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_item();

  // @@protoc_insertion_point(class_scope:common.DoubleArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > item_;
  mutable int _item_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StringArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.StringArray) */ {
 public:
  StringArray();
  virtual ~StringArray();

  StringArray(const StringArray& from);

  inline StringArray& operator=(const StringArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StringArray(StringArray&& from) noexcept
    : StringArray() {
    *this = ::std::move(from);
  }

  inline StringArray& operator=(StringArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StringArray& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StringArray* internal_default_instance() {
    return reinterpret_cast<const StringArray*>(
               &_StringArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(StringArray* other);
  friend void swap(StringArray& a, StringArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StringArray* New() const final {
    return CreateMaybeMessage<StringArray>(NULL);
  }

  StringArray* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StringArray>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StringArray& from);
  void MergeFrom(const StringArray& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  const ::std::string& item(int index) const;
  ::std::string* mutable_item(int index);
  void set_item(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_item(int index, ::std::string&& value);
  #endif
  void set_item(int index, const char* value);
  void set_item(int index, const char* value, size_t size);
  ::std::string* add_item();
  void add_item(const ::std::string& value);
  #if LANG_CXX11
  void add_item(::std::string&& value);
  #endif
  void add_item(const char* value);
  void add_item(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& item() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_item();

  // @@protoc_insertion_point(class_scope:common.StringArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> item_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Pair) */ {
 public:
  Pair();
  virtual ~Pair();

  Pair(const Pair& from);

  inline Pair& operator=(const Pair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pair(Pair&& from) noexcept
    : Pair() {
    *this = ::std::move(from);
  }

  inline Pair& operator=(Pair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pair* internal_default_instance() {
    return reinterpret_cast<const Pair*>(
               &_Pair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Pair* other);
  friend void swap(Pair& a, Pair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pair* New() const final {
    return CreateMaybeMessage<Pair>(NULL);
  }

  Pair* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Pair>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Pair& from);
  void MergeFrom(const Pair& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.Value key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  private:
  const ::common::Value& _internal_key() const;
  public:
  const ::common::Value& key() const;
  ::common::Value* release_key();
  ::common::Value* mutable_key();
  void set_allocated_key(::common::Value* key);

  // .common.Value val = 2;
  bool has_val() const;
  void clear_val();
  static const int kValFieldNumber = 2;
  private:
  const ::common::Value& _internal_val() const;
  public:
  const ::common::Value& val() const;
  ::common::Value* release_val();
  ::common::Value* mutable_val();
  void set_allocated_val(::common::Value* val);

  // @@protoc_insertion_point(class_scope:common.Pair)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::Value* key_;
  ::common::Value* val_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PairArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.PairArray) */ {
 public:
  PairArray();
  virtual ~PairArray();

  PairArray(const PairArray& from);

  inline PairArray& operator=(const PairArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PairArray(PairArray&& from) noexcept
    : PairArray() {
    *this = ::std::move(from);
  }

  inline PairArray& operator=(PairArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PairArray& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PairArray* internal_default_instance() {
    return reinterpret_cast<const PairArray*>(
               &_PairArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(PairArray* other);
  friend void swap(PairArray& a, PairArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PairArray* New() const final {
    return CreateMaybeMessage<PairArray>(NULL);
  }

  PairArray* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PairArray>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PairArray& from);
  void MergeFrom(const PairArray& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PairArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .common.Pair item = 1;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  ::common::Pair* mutable_item(int index);
  ::google::protobuf::RepeatedPtrField< ::common::Pair >*
      mutable_item();
  const ::common::Pair& item(int index) const;
  ::common::Pair* add_item();
  const ::google::protobuf::RepeatedPtrField< ::common::Pair >&
      item() const;

  // @@protoc_insertion_point(class_scope:common.PairArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::common::Pair > item_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_common_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NameOrId : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.NameOrId) */ {
 public:
  NameOrId();
  virtual ~NameOrId();

  NameOrId(const NameOrId& from);

  inline NameOrId& operator=(const NameOrId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NameOrId(NameOrId&& from) noexcept
    : NameOrId() {
    *this = ::std::move(from);
  }

  inline NameOrId& operator=(NameOrId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NameOrId& default_instance();

  enum ItemCase {
    kName = 1,
    kId = 2,
    ITEM_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NameOrId* internal_default_instance() {
    return reinterpret_cast<const NameOrId*>(
               &_NameOrId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(NameOrId* other);
  friend void swap(NameOrId& a, NameOrId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NameOrId* New() const final {
    return CreateMaybeMessage<NameOrId>(NULL);
  }

  NameOrId* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NameOrId>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NameOrId& from);
  void MergeFrom(const NameOrId& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NameOrId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  private:
  bool has_name() const;
  public:
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int32 id = 2;
  private:
  bool has_id() const;
  public:
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  void clear_item();
  ItemCase item_case() const;
  // @@protoc_insertion_point(class_scope:common.NameOrId)
 private:
  void set_has_name();
  void set_has_id();

  inline bool has_item() const;
  inline void clear_has_item();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ItemUnion {
    ItemUnion() {}
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::int32 id_;
  } item_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_common_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Value : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Value) */ {
 public:
  Value();
  virtual ~Value();

  Value(const Value& from);

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(Value&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Value& default_instance();

  enum ItemCase {
    kBoolean = 2,
    kI32 = 3,
    kI64 = 4,
    kF64 = 5,
    kStr = 6,
    kBlob = 7,
    kI32Array = 8,
    kI64Array = 9,
    kF64Array = 10,
    kStrArray = 11,
    kPairArray = 12,
    kNone = 13,
    ITEM_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Value* other);
  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Value* New() const final {
    return CreateMaybeMessage<Value>(NULL);
  }

  Value* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Value* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool boolean = 2;
  private:
  bool has_boolean() const;
  public:
  void clear_boolean();
  static const int kBooleanFieldNumber = 2;
  bool boolean() const;
  void set_boolean(bool value);

  // int32 i32 = 3;
  private:
  bool has_i32() const;
  public:
  void clear_i32();
  static const int kI32FieldNumber = 3;
  ::google::protobuf::int32 i32() const;
  void set_i32(::google::protobuf::int32 value);

  // int64 i64 = 4;
  private:
  bool has_i64() const;
  public:
  void clear_i64();
  static const int kI64FieldNumber = 4;
  ::google::protobuf::int64 i64() const;
  void set_i64(::google::protobuf::int64 value);

  // double f64 = 5;
  private:
  bool has_f64() const;
  public:
  void clear_f64();
  static const int kF64FieldNumber = 5;
  double f64() const;
  void set_f64(double value);

  // string str = 6;
  private:
  bool has_str() const;
  public:
  void clear_str();
  static const int kStrFieldNumber = 6;
  const ::std::string& str() const;
  void set_str(const ::std::string& value);
  #if LANG_CXX11
  void set_str(::std::string&& value);
  #endif
  void set_str(const char* value);
  void set_str(const char* value, size_t size);
  ::std::string* mutable_str();
  ::std::string* release_str();
  void set_allocated_str(::std::string* str);

  // bytes blob = 7;
  private:
  bool has_blob() const;
  public:
  void clear_blob();
  static const int kBlobFieldNumber = 7;
  const ::std::string& blob() const;
  void set_blob(const ::std::string& value);
  #if LANG_CXX11
  void set_blob(::std::string&& value);
  #endif
  void set_blob(const char* value);
  void set_blob(const void* value, size_t size);
  ::std::string* mutable_blob();
  ::std::string* release_blob();
  void set_allocated_blob(::std::string* blob);

  // .common.I32Array i32_array = 8;
  bool has_i32_array() const;
  void clear_i32_array();
  static const int kI32ArrayFieldNumber = 8;
  private:
  const ::common::I32Array& _internal_i32_array() const;
  public:
  const ::common::I32Array& i32_array() const;
  ::common::I32Array* release_i32_array();
  ::common::I32Array* mutable_i32_array();
  void set_allocated_i32_array(::common::I32Array* i32_array);

  // .common.I64Array i64_array = 9;
  bool has_i64_array() const;
  void clear_i64_array();
  static const int kI64ArrayFieldNumber = 9;
  private:
  const ::common::I64Array& _internal_i64_array() const;
  public:
  const ::common::I64Array& i64_array() const;
  ::common::I64Array* release_i64_array();
  ::common::I64Array* mutable_i64_array();
  void set_allocated_i64_array(::common::I64Array* i64_array);

  // .common.DoubleArray f64_array = 10;
  bool has_f64_array() const;
  void clear_f64_array();
  static const int kF64ArrayFieldNumber = 10;
  private:
  const ::common::DoubleArray& _internal_f64_array() const;
  public:
  const ::common::DoubleArray& f64_array() const;
  ::common::DoubleArray* release_f64_array();
  ::common::DoubleArray* mutable_f64_array();
  void set_allocated_f64_array(::common::DoubleArray* f64_array);

  // .common.StringArray str_array = 11;
  bool has_str_array() const;
  void clear_str_array();
  static const int kStrArrayFieldNumber = 11;
  private:
  const ::common::StringArray& _internal_str_array() const;
  public:
  const ::common::StringArray& str_array() const;
  ::common::StringArray* release_str_array();
  ::common::StringArray* mutable_str_array();
  void set_allocated_str_array(::common::StringArray* str_array);

  // .common.PairArray pair_array = 12;
  bool has_pair_array() const;
  void clear_pair_array();
  static const int kPairArrayFieldNumber = 12;
  private:
  const ::common::PairArray& _internal_pair_array() const;
  public:
  const ::common::PairArray& pair_array() const;
  ::common::PairArray* release_pair_array();
  ::common::PairArray* mutable_pair_array();
  void set_allocated_pair_array(::common::PairArray* pair_array);

  // .common.None none = 13;
  bool has_none() const;
  void clear_none();
  static const int kNoneFieldNumber = 13;
  private:
  const ::common::None& _internal_none() const;
  public:
  const ::common::None& none() const;
  ::common::None* release_none();
  ::common::None* mutable_none();
  void set_allocated_none(::common::None* none);

  void clear_item();
  ItemCase item_case() const;
  // @@protoc_insertion_point(class_scope:common.Value)
 private:
  void set_has_boolean();
  void set_has_i32();
  void set_has_i64();
  void set_has_f64();
  void set_has_str();
  void set_has_blob();
  void set_has_i32_array();
  void set_has_i64_array();
  void set_has_f64_array();
  void set_has_str_array();
  void set_has_pair_array();
  void set_has_none();

  inline bool has_item() const;
  inline void clear_has_item();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ItemUnion {
    ItemUnion() {}
    bool boolean_;
    ::google::protobuf::int32 i32_;
    ::google::protobuf::int64 i64_;
    double f64_;
    ::google::protobuf::internal::ArenaStringPtr str_;
    ::google::protobuf::internal::ArenaStringPtr blob_;
    ::common::I32Array* i32_array_;
    ::common::I64Array* i64_array_;
    ::common::DoubleArray* f64_array_;
    ::common::StringArray* str_array_;
    ::common::PairArray* pair_array_;
    ::common::None* none_;
  } item_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_common_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// None

// -------------------------------------------------------------------

// I32Array

// repeated int32 item = 1;
inline int I32Array::item_size() const {
  return item_.size();
}
inline void I32Array::clear_item() {
  item_.Clear();
}
inline ::google::protobuf::int32 I32Array::item(int index) const {
  // @@protoc_insertion_point(field_get:common.I32Array.item)
  return item_.Get(index);
}
inline void I32Array::set_item(int index, ::google::protobuf::int32 value) {
  item_.Set(index, value);
  // @@protoc_insertion_point(field_set:common.I32Array.item)
}
inline void I32Array::add_item(::google::protobuf::int32 value) {
  item_.Add(value);
  // @@protoc_insertion_point(field_add:common.I32Array.item)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
I32Array::item() const {
  // @@protoc_insertion_point(field_list:common.I32Array.item)
  return item_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
I32Array::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:common.I32Array.item)
  return &item_;
}

// -------------------------------------------------------------------

// I64Array

// repeated int64 item = 1;
inline int I64Array::item_size() const {
  return item_.size();
}
inline void I64Array::clear_item() {
  item_.Clear();
}
inline ::google::protobuf::int64 I64Array::item(int index) const {
  // @@protoc_insertion_point(field_get:common.I64Array.item)
  return item_.Get(index);
}
inline void I64Array::set_item(int index, ::google::protobuf::int64 value) {
  item_.Set(index, value);
  // @@protoc_insertion_point(field_set:common.I64Array.item)
}
inline void I64Array::add_item(::google::protobuf::int64 value) {
  item_.Add(value);
  // @@protoc_insertion_point(field_add:common.I64Array.item)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
I64Array::item() const {
  // @@protoc_insertion_point(field_list:common.I64Array.item)
  return item_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
I64Array::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:common.I64Array.item)
  return &item_;
}

// -------------------------------------------------------------------

// DoubleArray

// repeated double item = 1;
inline int DoubleArray::item_size() const {
  return item_.size();
}
inline void DoubleArray::clear_item() {
  item_.Clear();
}
inline double DoubleArray::item(int index) const {
  // @@protoc_insertion_point(field_get:common.DoubleArray.item)
  return item_.Get(index);
}
inline void DoubleArray::set_item(int index, double value) {
  item_.Set(index, value);
  // @@protoc_insertion_point(field_set:common.DoubleArray.item)
}
inline void DoubleArray::add_item(double value) {
  item_.Add(value);
  // @@protoc_insertion_point(field_add:common.DoubleArray.item)
}
inline const ::google::protobuf::RepeatedField< double >&
DoubleArray::item() const {
  // @@protoc_insertion_point(field_list:common.DoubleArray.item)
  return item_;
}
inline ::google::protobuf::RepeatedField< double >*
DoubleArray::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:common.DoubleArray.item)
  return &item_;
}

// -------------------------------------------------------------------

// StringArray

// repeated string item = 1;
inline int StringArray::item_size() const {
  return item_.size();
}
inline void StringArray::clear_item() {
  item_.Clear();
}
inline const ::std::string& StringArray::item(int index) const {
  // @@protoc_insertion_point(field_get:common.StringArray.item)
  return item_.Get(index);
}
inline ::std::string* StringArray::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:common.StringArray.item)
  return item_.Mutable(index);
}
inline void StringArray::set_item(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:common.StringArray.item)
  item_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void StringArray::set_item(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:common.StringArray.item)
  item_.Mutable(index)->assign(std::move(value));
}
#endif
inline void StringArray::set_item(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  item_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:common.StringArray.item)
}
inline void StringArray::set_item(int index, const char* value, size_t size) {
  item_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.StringArray.item)
}
inline ::std::string* StringArray::add_item() {
  // @@protoc_insertion_point(field_add_mutable:common.StringArray.item)
  return item_.Add();
}
inline void StringArray::add_item(const ::std::string& value) {
  item_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:common.StringArray.item)
}
#if LANG_CXX11
inline void StringArray::add_item(::std::string&& value) {
  item_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:common.StringArray.item)
}
#endif
inline void StringArray::add_item(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  item_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:common.StringArray.item)
}
inline void StringArray::add_item(const char* value, size_t size) {
  item_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:common.StringArray.item)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StringArray::item() const {
  // @@protoc_insertion_point(field_list:common.StringArray.item)
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StringArray::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:common.StringArray.item)
  return &item_;
}

// -------------------------------------------------------------------

// Pair

// .common.Value key = 1;
inline bool Pair::has_key() const {
  return this != internal_default_instance() && key_ != NULL;
}
inline void Pair::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) {
    delete key_;
  }
  key_ = NULL;
}
inline const ::common::Value& Pair::_internal_key() const {
  return *key_;
}
inline const ::common::Value& Pair::key() const {
  const ::common::Value* p = key_;
  // @@protoc_insertion_point(field_get:common.Pair.key)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Value*>(
      &::common::_Value_default_instance_);
}
inline ::common::Value* Pair::release_key() {
  // @@protoc_insertion_point(field_release:common.Pair.key)
  
  ::common::Value* temp = key_;
  key_ = NULL;
  return temp;
}
inline ::common::Value* Pair::mutable_key() {
  
  if (key_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Value>(GetArenaNoVirtual());
    key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.Pair.key)
  return key_;
}
inline void Pair::set_allocated_key(::common::Value* key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete key_;
  }
  if (key) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:common.Pair.key)
}

// .common.Value val = 2;
inline bool Pair::has_val() const {
  return this != internal_default_instance() && val_ != NULL;
}
inline void Pair::clear_val() {
  if (GetArenaNoVirtual() == NULL && val_ != NULL) {
    delete val_;
  }
  val_ = NULL;
}
inline const ::common::Value& Pair::_internal_val() const {
  return *val_;
}
inline const ::common::Value& Pair::val() const {
  const ::common::Value* p = val_;
  // @@protoc_insertion_point(field_get:common.Pair.val)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Value*>(
      &::common::_Value_default_instance_);
}
inline ::common::Value* Pair::release_val() {
  // @@protoc_insertion_point(field_release:common.Pair.val)
  
  ::common::Value* temp = val_;
  val_ = NULL;
  return temp;
}
inline ::common::Value* Pair::mutable_val() {
  
  if (val_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Value>(GetArenaNoVirtual());
    val_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.Pair.val)
  return val_;
}
inline void Pair::set_allocated_val(::common::Value* val) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete val_;
  }
  if (val) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      val = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, val, submessage_arena);
    }
    
  } else {
    
  }
  val_ = val;
  // @@protoc_insertion_point(field_set_allocated:common.Pair.val)
}

// -------------------------------------------------------------------

// PairArray

// repeated .common.Pair item = 1;
inline int PairArray::item_size() const {
  return item_.size();
}
inline void PairArray::clear_item() {
  item_.Clear();
}
inline ::common::Pair* PairArray::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:common.PairArray.item)
  return item_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::common::Pair >*
PairArray::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:common.PairArray.item)
  return &item_;
}
inline const ::common::Pair& PairArray::item(int index) const {
  // @@protoc_insertion_point(field_get:common.PairArray.item)
  return item_.Get(index);
}
inline ::common::Pair* PairArray::add_item() {
  // @@protoc_insertion_point(field_add:common.PairArray.item)
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::Pair >&
PairArray::item() const {
  // @@protoc_insertion_point(field_list:common.PairArray.item)
  return item_;
}

// -------------------------------------------------------------------

// NameOrId

// string name = 1;
inline bool NameOrId::has_name() const {
  return item_case() == kName;
}
inline void NameOrId::set_has_name() {
  _oneof_case_[0] = kName;
}
inline void NameOrId::clear_name() {
  if (has_name()) {
    item_.name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_item();
  }
}
inline const ::std::string& NameOrId::name() const {
  // @@protoc_insertion_point(field_get:common.NameOrId.name)
  if (has_name()) {
    return item_.name_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void NameOrId::set_name(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:common.NameOrId.name)
  if (!has_name()) {
    clear_item();
    set_has_name();
    item_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  item_.name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:common.NameOrId.name)
}
#if LANG_CXX11
inline void NameOrId::set_name(::std::string&& value) {
  // @@protoc_insertion_point(field_set:common.NameOrId.name)
  if (!has_name()) {
    clear_item();
    set_has_name();
    item_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  item_.name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:common.NameOrId.name)
}
#endif
inline void NameOrId::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_name()) {
    clear_item();
    set_has_name();
    item_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  item_.name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:common.NameOrId.name)
}
inline void NameOrId::set_name(const char* value, size_t size) {
  if (!has_name()) {
    clear_item();
    set_has_name();
    item_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  item_.name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:common.NameOrId.name)
}
inline ::std::string* NameOrId::mutable_name() {
  if (!has_name()) {
    clear_item();
    set_has_name();
    item_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:common.NameOrId.name)
  return item_.name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NameOrId::release_name() {
  // @@protoc_insertion_point(field_release:common.NameOrId.name)
  if (has_name()) {
    clear_has_item();
    return item_.name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void NameOrId::set_allocated_name(::std::string* name) {
  if (!has_name()) {
    item_.name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_item();
  if (name != NULL) {
    set_has_name();
    item_.name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  }
  // @@protoc_insertion_point(field_set_allocated:common.NameOrId.name)
}

// int32 id = 2;
inline bool NameOrId::has_id() const {
  return item_case() == kId;
}
inline void NameOrId::set_has_id() {
  _oneof_case_[0] = kId;
}
inline void NameOrId::clear_id() {
  if (has_id()) {
    item_.id_ = 0;
    clear_has_item();
  }
}
inline ::google::protobuf::int32 NameOrId::id() const {
  // @@protoc_insertion_point(field_get:common.NameOrId.id)
  if (has_id()) {
    return item_.id_;
  }
  return 0;
}
inline void NameOrId::set_id(::google::protobuf::int32 value) {
  if (!has_id()) {
    clear_item();
    set_has_id();
  }
  item_.id_ = value;
  // @@protoc_insertion_point(field_set:common.NameOrId.id)
}

inline bool NameOrId::has_item() const {
  return item_case() != ITEM_NOT_SET;
}
inline void NameOrId::clear_has_item() {
  _oneof_case_[0] = ITEM_NOT_SET;
}
inline NameOrId::ItemCase NameOrId::item_case() const {
  return NameOrId::ItemCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Value

// bool boolean = 2;
inline bool Value::has_boolean() const {
  return item_case() == kBoolean;
}
inline void Value::set_has_boolean() {
  _oneof_case_[0] = kBoolean;
}
inline void Value::clear_boolean() {
  if (has_boolean()) {
    item_.boolean_ = false;
    clear_has_item();
  }
}
inline bool Value::boolean() const {
  // @@protoc_insertion_point(field_get:common.Value.boolean)
  if (has_boolean()) {
    return item_.boolean_;
  }
  return false;
}
inline void Value::set_boolean(bool value) {
  if (!has_boolean()) {
    clear_item();
    set_has_boolean();
  }
  item_.boolean_ = value;
  // @@protoc_insertion_point(field_set:common.Value.boolean)
}

// int32 i32 = 3;
inline bool Value::has_i32() const {
  return item_case() == kI32;
}
inline void Value::set_has_i32() {
  _oneof_case_[0] = kI32;
}
inline void Value::clear_i32() {
  if (has_i32()) {
    item_.i32_ = 0;
    clear_has_item();
  }
}
inline ::google::protobuf::int32 Value::i32() const {
  // @@protoc_insertion_point(field_get:common.Value.i32)
  if (has_i32()) {
    return item_.i32_;
  }
  return 0;
}
inline void Value::set_i32(::google::protobuf::int32 value) {
  if (!has_i32()) {
    clear_item();
    set_has_i32();
  }
  item_.i32_ = value;
  // @@protoc_insertion_point(field_set:common.Value.i32)
}

// int64 i64 = 4;
inline bool Value::has_i64() const {
  return item_case() == kI64;
}
inline void Value::set_has_i64() {
  _oneof_case_[0] = kI64;
}
inline void Value::clear_i64() {
  if (has_i64()) {
    item_.i64_ = GOOGLE_LONGLONG(0);
    clear_has_item();
  }
}
inline ::google::protobuf::int64 Value::i64() const {
  // @@protoc_insertion_point(field_get:common.Value.i64)
  if (has_i64()) {
    return item_.i64_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void Value::set_i64(::google::protobuf::int64 value) {
  if (!has_i64()) {
    clear_item();
    set_has_i64();
  }
  item_.i64_ = value;
  // @@protoc_insertion_point(field_set:common.Value.i64)
}

// double f64 = 5;
inline bool Value::has_f64() const {
  return item_case() == kF64;
}
inline void Value::set_has_f64() {
  _oneof_case_[0] = kF64;
}
inline void Value::clear_f64() {
  if (has_f64()) {
    item_.f64_ = 0;
    clear_has_item();
  }
}
inline double Value::f64() const {
  // @@protoc_insertion_point(field_get:common.Value.f64)
  if (has_f64()) {
    return item_.f64_;
  }
  return 0;
}
inline void Value::set_f64(double value) {
  if (!has_f64()) {
    clear_item();
    set_has_f64();
  }
  item_.f64_ = value;
  // @@protoc_insertion_point(field_set:common.Value.f64)
}

// string str = 6;
inline bool Value::has_str() const {
  return item_case() == kStr;
}
inline void Value::set_has_str() {
  _oneof_case_[0] = kStr;
}
inline void Value::clear_str() {
  if (has_str()) {
    item_.str_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_item();
  }
}
inline const ::std::string& Value::str() const {
  // @@protoc_insertion_point(field_get:common.Value.str)
  if (has_str()) {
    return item_.str_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Value::set_str(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:common.Value.str)
  if (!has_str()) {
    clear_item();
    set_has_str();
    item_.str_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  item_.str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:common.Value.str)
}
#if LANG_CXX11
inline void Value::set_str(::std::string&& value) {
  // @@protoc_insertion_point(field_set:common.Value.str)
  if (!has_str()) {
    clear_item();
    set_has_str();
    item_.str_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  item_.str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:common.Value.str)
}
#endif
inline void Value::set_str(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_str()) {
    clear_item();
    set_has_str();
    item_.str_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  item_.str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:common.Value.str)
}
inline void Value::set_str(const char* value, size_t size) {
  if (!has_str()) {
    clear_item();
    set_has_str();
    item_.str_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  item_.str_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:common.Value.str)
}
inline ::std::string* Value::mutable_str() {
  if (!has_str()) {
    clear_item();
    set_has_str();
    item_.str_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:common.Value.str)
  return item_.str_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Value::release_str() {
  // @@protoc_insertion_point(field_release:common.Value.str)
  if (has_str()) {
    clear_has_item();
    return item_.str_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Value::set_allocated_str(::std::string* str) {
  if (!has_str()) {
    item_.str_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_item();
  if (str != NULL) {
    set_has_str();
    item_.str_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), str);
  }
  // @@protoc_insertion_point(field_set_allocated:common.Value.str)
}

// bytes blob = 7;
inline bool Value::has_blob() const {
  return item_case() == kBlob;
}
inline void Value::set_has_blob() {
  _oneof_case_[0] = kBlob;
}
inline void Value::clear_blob() {
  if (has_blob()) {
    item_.blob_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_item();
  }
}
inline const ::std::string& Value::blob() const {
  // @@protoc_insertion_point(field_get:common.Value.blob)
  if (has_blob()) {
    return item_.blob_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Value::set_blob(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:common.Value.blob)
  if (!has_blob()) {
    clear_item();
    set_has_blob();
    item_.blob_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  item_.blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:common.Value.blob)
}
#if LANG_CXX11
inline void Value::set_blob(::std::string&& value) {
  // @@protoc_insertion_point(field_set:common.Value.blob)
  if (!has_blob()) {
    clear_item();
    set_has_blob();
    item_.blob_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  item_.blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:common.Value.blob)
}
#endif
inline void Value::set_blob(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_blob()) {
    clear_item();
    set_has_blob();
    item_.blob_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  item_.blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:common.Value.blob)
}
inline void Value::set_blob(const void* value, size_t size) {
  if (!has_blob()) {
    clear_item();
    set_has_blob();
    item_.blob_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  item_.blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:common.Value.blob)
}
inline ::std::string* Value::mutable_blob() {
  if (!has_blob()) {
    clear_item();
    set_has_blob();
    item_.blob_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:common.Value.blob)
  return item_.blob_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Value::release_blob() {
  // @@protoc_insertion_point(field_release:common.Value.blob)
  if (has_blob()) {
    clear_has_item();
    return item_.blob_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Value::set_allocated_blob(::std::string* blob) {
  if (!has_blob()) {
    item_.blob_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_item();
  if (blob != NULL) {
    set_has_blob();
    item_.blob_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blob);
  }
  // @@protoc_insertion_point(field_set_allocated:common.Value.blob)
}

// .common.I32Array i32_array = 8;
inline bool Value::has_i32_array() const {
  return item_case() == kI32Array;
}
inline void Value::set_has_i32_array() {
  _oneof_case_[0] = kI32Array;
}
inline void Value::clear_i32_array() {
  if (has_i32_array()) {
    delete item_.i32_array_;
    clear_has_item();
  }
}
inline const ::common::I32Array& Value::_internal_i32_array() const {
  return *item_.i32_array_;
}
inline ::common::I32Array* Value::release_i32_array() {
  // @@protoc_insertion_point(field_release:common.Value.i32_array)
  if (has_i32_array()) {
    clear_has_item();
      ::common::I32Array* temp = item_.i32_array_;
    item_.i32_array_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::common::I32Array& Value::i32_array() const {
  // @@protoc_insertion_point(field_get:common.Value.i32_array)
  return has_i32_array()
      ? *item_.i32_array_
      : *reinterpret_cast< ::common::I32Array*>(&::common::_I32Array_default_instance_);
}
inline ::common::I32Array* Value::mutable_i32_array() {
  if (!has_i32_array()) {
    clear_item();
    set_has_i32_array();
    item_.i32_array_ = CreateMaybeMessage< ::common::I32Array >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:common.Value.i32_array)
  return item_.i32_array_;
}

// .common.I64Array i64_array = 9;
inline bool Value::has_i64_array() const {
  return item_case() == kI64Array;
}
inline void Value::set_has_i64_array() {
  _oneof_case_[0] = kI64Array;
}
inline void Value::clear_i64_array() {
  if (has_i64_array()) {
    delete item_.i64_array_;
    clear_has_item();
  }
}
inline const ::common::I64Array& Value::_internal_i64_array() const {
  return *item_.i64_array_;
}
inline ::common::I64Array* Value::release_i64_array() {
  // @@protoc_insertion_point(field_release:common.Value.i64_array)
  if (has_i64_array()) {
    clear_has_item();
      ::common::I64Array* temp = item_.i64_array_;
    item_.i64_array_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::common::I64Array& Value::i64_array() const {
  // @@protoc_insertion_point(field_get:common.Value.i64_array)
  return has_i64_array()
      ? *item_.i64_array_
      : *reinterpret_cast< ::common::I64Array*>(&::common::_I64Array_default_instance_);
}
inline ::common::I64Array* Value::mutable_i64_array() {
  if (!has_i64_array()) {
    clear_item();
    set_has_i64_array();
    item_.i64_array_ = CreateMaybeMessage< ::common::I64Array >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:common.Value.i64_array)
  return item_.i64_array_;
}

// .common.DoubleArray f64_array = 10;
inline bool Value::has_f64_array() const {
  return item_case() == kF64Array;
}
inline void Value::set_has_f64_array() {
  _oneof_case_[0] = kF64Array;
}
inline void Value::clear_f64_array() {
  if (has_f64_array()) {
    delete item_.f64_array_;
    clear_has_item();
  }
}
inline const ::common::DoubleArray& Value::_internal_f64_array() const {
  return *item_.f64_array_;
}
inline ::common::DoubleArray* Value::release_f64_array() {
  // @@protoc_insertion_point(field_release:common.Value.f64_array)
  if (has_f64_array()) {
    clear_has_item();
      ::common::DoubleArray* temp = item_.f64_array_;
    item_.f64_array_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::common::DoubleArray& Value::f64_array() const {
  // @@protoc_insertion_point(field_get:common.Value.f64_array)
  return has_f64_array()
      ? *item_.f64_array_
      : *reinterpret_cast< ::common::DoubleArray*>(&::common::_DoubleArray_default_instance_);
}
inline ::common::DoubleArray* Value::mutable_f64_array() {
  if (!has_f64_array()) {
    clear_item();
    set_has_f64_array();
    item_.f64_array_ = CreateMaybeMessage< ::common::DoubleArray >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:common.Value.f64_array)
  return item_.f64_array_;
}

// .common.StringArray str_array = 11;
inline bool Value::has_str_array() const {
  return item_case() == kStrArray;
}
inline void Value::set_has_str_array() {
  _oneof_case_[0] = kStrArray;
}
inline void Value::clear_str_array() {
  if (has_str_array()) {
    delete item_.str_array_;
    clear_has_item();
  }
}
inline const ::common::StringArray& Value::_internal_str_array() const {
  return *item_.str_array_;
}
inline ::common::StringArray* Value::release_str_array() {
  // @@protoc_insertion_point(field_release:common.Value.str_array)
  if (has_str_array()) {
    clear_has_item();
      ::common::StringArray* temp = item_.str_array_;
    item_.str_array_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::common::StringArray& Value::str_array() const {
  // @@protoc_insertion_point(field_get:common.Value.str_array)
  return has_str_array()
      ? *item_.str_array_
      : *reinterpret_cast< ::common::StringArray*>(&::common::_StringArray_default_instance_);
}
inline ::common::StringArray* Value::mutable_str_array() {
  if (!has_str_array()) {
    clear_item();
    set_has_str_array();
    item_.str_array_ = CreateMaybeMessage< ::common::StringArray >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:common.Value.str_array)
  return item_.str_array_;
}

// .common.PairArray pair_array = 12;
inline bool Value::has_pair_array() const {
  return item_case() == kPairArray;
}
inline void Value::set_has_pair_array() {
  _oneof_case_[0] = kPairArray;
}
inline void Value::clear_pair_array() {
  if (has_pair_array()) {
    delete item_.pair_array_;
    clear_has_item();
  }
}
inline const ::common::PairArray& Value::_internal_pair_array() const {
  return *item_.pair_array_;
}
inline ::common::PairArray* Value::release_pair_array() {
  // @@protoc_insertion_point(field_release:common.Value.pair_array)
  if (has_pair_array()) {
    clear_has_item();
      ::common::PairArray* temp = item_.pair_array_;
    item_.pair_array_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::common::PairArray& Value::pair_array() const {
  // @@protoc_insertion_point(field_get:common.Value.pair_array)
  return has_pair_array()
      ? *item_.pair_array_
      : *reinterpret_cast< ::common::PairArray*>(&::common::_PairArray_default_instance_);
}
inline ::common::PairArray* Value::mutable_pair_array() {
  if (!has_pair_array()) {
    clear_item();
    set_has_pair_array();
    item_.pair_array_ = CreateMaybeMessage< ::common::PairArray >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:common.Value.pair_array)
  return item_.pair_array_;
}

// .common.None none = 13;
inline bool Value::has_none() const {
  return item_case() == kNone;
}
inline void Value::set_has_none() {
  _oneof_case_[0] = kNone;
}
inline void Value::clear_none() {
  if (has_none()) {
    delete item_.none_;
    clear_has_item();
  }
}
inline const ::common::None& Value::_internal_none() const {
  return *item_.none_;
}
inline ::common::None* Value::release_none() {
  // @@protoc_insertion_point(field_release:common.Value.none)
  if (has_none()) {
    clear_has_item();
      ::common::None* temp = item_.none_;
    item_.none_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::common::None& Value::none() const {
  // @@protoc_insertion_point(field_get:common.Value.none)
  return has_none()
      ? *item_.none_
      : *reinterpret_cast< ::common::None*>(&::common::_None_default_instance_);
}
inline ::common::None* Value::mutable_none() {
  if (!has_none()) {
    clear_item();
    set_has_none();
    item_.none_ = CreateMaybeMessage< ::common::None >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:common.Value.none)
  return item_.none_;
}

inline bool Value::has_item() const {
  return item_case() != ITEM_NOT_SET;
}
inline void Value::clear_has_item() {
  _oneof_case_[0] = ITEM_NOT_SET;
}
inline Value::ItemCase Value::item_case() const {
  return Value::ItemCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace common

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::common::DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::DataType>() {
  return ::common::DataType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_common_2eproto
