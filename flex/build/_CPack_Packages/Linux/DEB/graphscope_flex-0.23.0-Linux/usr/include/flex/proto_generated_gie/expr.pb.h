// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: expr.proto

#ifndef PROTOBUF_INCLUDED_expr_2eproto
#define PROTOBUF_INCLUDED_expr_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "type.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_expr_2eproto 

namespace protobuf_expr_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[14];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_expr_2eproto
namespace common {
class AllKey;
class AllKeyDefaultTypeInternal;
extern AllKeyDefaultTypeInternal _AllKey_default_instance_;
class Case;
class CaseDefaultTypeInternal;
extern CaseDefaultTypeInternal _Case_default_instance_;
class Case_WhenThen;
class Case_WhenThenDefaultTypeInternal;
extern Case_WhenThenDefaultTypeInternal _Case_WhenThen_default_instance_;
class DynamicParam;
class DynamicParamDefaultTypeInternal;
extern DynamicParamDefaultTypeInternal _DynamicParam_default_instance_;
class ExprOpr;
class ExprOprDefaultTypeInternal;
extern ExprOprDefaultTypeInternal _ExprOpr_default_instance_;
class Expression;
class ExpressionDefaultTypeInternal;
extern ExpressionDefaultTypeInternal _Expression_default_instance_;
class Extract;
class ExtractDefaultTypeInternal;
extern ExtractDefaultTypeInternal _Extract_default_instance_;
class IdKey;
class IdKeyDefaultTypeInternal;
extern IdKeyDefaultTypeInternal _IdKey_default_instance_;
class LabelKey;
class LabelKeyDefaultTypeInternal;
extern LabelKeyDefaultTypeInternal _LabelKey_default_instance_;
class LengthKey;
class LengthKeyDefaultTypeInternal;
extern LengthKeyDefaultTypeInternal _LengthKey_default_instance_;
class NameOrIdKey;
class NameOrIdKeyDefaultTypeInternal;
extern NameOrIdKeyDefaultTypeInternal _NameOrIdKey_default_instance_;
class Property;
class PropertyDefaultTypeInternal;
extern PropertyDefaultTypeInternal _Property_default_instance_;
class Variable;
class VariableDefaultTypeInternal;
extern VariableDefaultTypeInternal _Variable_default_instance_;
class VariableKeys;
class VariableKeysDefaultTypeInternal;
extern VariableKeysDefaultTypeInternal _VariableKeys_default_instance_;
}  // namespace common
namespace google {
namespace protobuf {
template<> ::common::AllKey* Arena::CreateMaybeMessage<::common::AllKey>(Arena*);
template<> ::common::Case* Arena::CreateMaybeMessage<::common::Case>(Arena*);
template<> ::common::Case_WhenThen* Arena::CreateMaybeMessage<::common::Case_WhenThen>(Arena*);
template<> ::common::DynamicParam* Arena::CreateMaybeMessage<::common::DynamicParam>(Arena*);
template<> ::common::ExprOpr* Arena::CreateMaybeMessage<::common::ExprOpr>(Arena*);
template<> ::common::Expression* Arena::CreateMaybeMessage<::common::Expression>(Arena*);
template<> ::common::Extract* Arena::CreateMaybeMessage<::common::Extract>(Arena*);
template<> ::common::IdKey* Arena::CreateMaybeMessage<::common::IdKey>(Arena*);
template<> ::common::LabelKey* Arena::CreateMaybeMessage<::common::LabelKey>(Arena*);
template<> ::common::LengthKey* Arena::CreateMaybeMessage<::common::LengthKey>(Arena*);
template<> ::common::NameOrIdKey* Arena::CreateMaybeMessage<::common::NameOrIdKey>(Arena*);
template<> ::common::Property* Arena::CreateMaybeMessage<::common::Property>(Arena*);
template<> ::common::Variable* Arena::CreateMaybeMessage<::common::Variable>(Arena*);
template<> ::common::VariableKeys* Arena::CreateMaybeMessage<::common::VariableKeys>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace common {

enum Extract_Interval {
  Extract_Interval_YEAR = 0,
  Extract_Interval_MONTH = 1,
  Extract_Interval_DAY = 2,
  Extract_Interval_HOUR = 3,
  Extract_Interval_MINUTE = 4,
  Extract_Interval_SECOND = 5,
  Extract_Interval_Extract_Interval_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Extract_Interval_Extract_Interval_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Extract_Interval_IsValid(int value);
const Extract_Interval Extract_Interval_Interval_MIN = Extract_Interval_YEAR;
const Extract_Interval Extract_Interval_Interval_MAX = Extract_Interval_SECOND;
const int Extract_Interval_Interval_ARRAYSIZE = Extract_Interval_Interval_MAX + 1;

const ::google::protobuf::EnumDescriptor* Extract_Interval_descriptor();
inline const ::std::string& Extract_Interval_Name(Extract_Interval value) {
  return ::google::protobuf::internal::NameOfEnum(
    Extract_Interval_descriptor(), value);
}
inline bool Extract_Interval_Parse(
    const ::std::string& name, Extract_Interval* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Extract_Interval>(
    Extract_Interval_descriptor(), name, value);
}
enum ExprOpr_Brace {
  ExprOpr_Brace_LEFT_BRACE = 0,
  ExprOpr_Brace_RIGHT_BRACE = 1,
  ExprOpr_Brace_ExprOpr_Brace_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ExprOpr_Brace_ExprOpr_Brace_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ExprOpr_Brace_IsValid(int value);
const ExprOpr_Brace ExprOpr_Brace_Brace_MIN = ExprOpr_Brace_LEFT_BRACE;
const ExprOpr_Brace ExprOpr_Brace_Brace_MAX = ExprOpr_Brace_RIGHT_BRACE;
const int ExprOpr_Brace_Brace_ARRAYSIZE = ExprOpr_Brace_Brace_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExprOpr_Brace_descriptor();
inline const ::std::string& ExprOpr_Brace_Name(ExprOpr_Brace value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExprOpr_Brace_descriptor(), value);
}
inline bool ExprOpr_Brace_Parse(
    const ::std::string& name, ExprOpr_Brace* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExprOpr_Brace>(
    ExprOpr_Brace_descriptor(), name, value);
}
enum Logical {
  EQ = 0,
  NE = 1,
  LT = 2,
  LE = 3,
  GT = 4,
  GE = 5,
  WITHIN = 6,
  WITHOUT = 7,
  STARTSWITH = 8,
  ENDSWITH = 9,
  AND = 10,
  OR = 11,
  NOT = 12,
  ISNULL = 13,
  Logical_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Logical_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Logical_IsValid(int value);
const Logical Logical_MIN = EQ;
const Logical Logical_MAX = ISNULL;
const int Logical_ARRAYSIZE = Logical_MAX + 1;

const ::google::protobuf::EnumDescriptor* Logical_descriptor();
inline const ::std::string& Logical_Name(Logical value) {
  return ::google::protobuf::internal::NameOfEnum(
    Logical_descriptor(), value);
}
inline bool Logical_Parse(
    const ::std::string& name, Logical* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Logical>(
    Logical_descriptor(), name, value);
}
enum Arithmetic {
  ADD = 0,
  SUB = 1,
  MUL = 2,
  DIV = 3,
  MOD = 4,
  EXP = 5,
  BITAND = 6,
  BITOR = 7,
  BITXOR = 8,
  BITLSHIFT = 9,
  BITRSHIFT = 10,
  Arithmetic_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Arithmetic_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Arithmetic_IsValid(int value);
const Arithmetic Arithmetic_MIN = ADD;
const Arithmetic Arithmetic_MAX = BITRSHIFT;
const int Arithmetic_ARRAYSIZE = Arithmetic_MAX + 1;

const ::google::protobuf::EnumDescriptor* Arithmetic_descriptor();
inline const ::std::string& Arithmetic_Name(Arithmetic value) {
  return ::google::protobuf::internal::NameOfEnum(
    Arithmetic_descriptor(), value);
}
inline bool Arithmetic_Parse(
    const ::std::string& name, Arithmetic* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Arithmetic>(
    Arithmetic_descriptor(), name, value);
}
// ===================================================================

class IdKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.IdKey) */ {
 public:
  IdKey();
  virtual ~IdKey();

  IdKey(const IdKey& from);

  inline IdKey& operator=(const IdKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IdKey(IdKey&& from) noexcept
    : IdKey() {
    *this = ::std::move(from);
  }

  inline IdKey& operator=(IdKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IdKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IdKey* internal_default_instance() {
    return reinterpret_cast<const IdKey*>(
               &_IdKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(IdKey* other);
  friend void swap(IdKey& a, IdKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IdKey* New() const final {
    return CreateMaybeMessage<IdKey>(NULL);
  }

  IdKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IdKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IdKey& from);
  void MergeFrom(const IdKey& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IdKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:common.IdKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_expr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LabelKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.LabelKey) */ {
 public:
  LabelKey();
  virtual ~LabelKey();

  LabelKey(const LabelKey& from);

  inline LabelKey& operator=(const LabelKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LabelKey(LabelKey&& from) noexcept
    : LabelKey() {
    *this = ::std::move(from);
  }

  inline LabelKey& operator=(LabelKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LabelKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LabelKey* internal_default_instance() {
    return reinterpret_cast<const LabelKey*>(
               &_LabelKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(LabelKey* other);
  friend void swap(LabelKey& a, LabelKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LabelKey* New() const final {
    return CreateMaybeMessage<LabelKey>(NULL);
  }

  LabelKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LabelKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LabelKey& from);
  void MergeFrom(const LabelKey& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LabelKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:common.LabelKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_expr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LengthKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.LengthKey) */ {
 public:
  LengthKey();
  virtual ~LengthKey();

  LengthKey(const LengthKey& from);

  inline LengthKey& operator=(const LengthKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LengthKey(LengthKey&& from) noexcept
    : LengthKey() {
    *this = ::std::move(from);
  }

  inline LengthKey& operator=(LengthKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LengthKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LengthKey* internal_default_instance() {
    return reinterpret_cast<const LengthKey*>(
               &_LengthKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(LengthKey* other);
  friend void swap(LengthKey& a, LengthKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LengthKey* New() const final {
    return CreateMaybeMessage<LengthKey>(NULL);
  }

  LengthKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LengthKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LengthKey& from);
  void MergeFrom(const LengthKey& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LengthKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:common.LengthKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_expr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AllKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.AllKey) */ {
 public:
  AllKey();
  virtual ~AllKey();

  AllKey(const AllKey& from);

  inline AllKey& operator=(const AllKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AllKey(AllKey&& from) noexcept
    : AllKey() {
    *this = ::std::move(from);
  }

  inline AllKey& operator=(AllKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AllKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AllKey* internal_default_instance() {
    return reinterpret_cast<const AllKey*>(
               &_AllKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(AllKey* other);
  friend void swap(AllKey& a, AllKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AllKey* New() const final {
    return CreateMaybeMessage<AllKey>(NULL);
  }

  AllKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AllKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AllKey& from);
  void MergeFrom(const AllKey& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:common.AllKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_expr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NameOrIdKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.NameOrIdKey) */ {
 public:
  NameOrIdKey();
  virtual ~NameOrIdKey();

  NameOrIdKey(const NameOrIdKey& from);

  inline NameOrIdKey& operator=(const NameOrIdKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NameOrIdKey(NameOrIdKey&& from) noexcept
    : NameOrIdKey() {
    *this = ::std::move(from);
  }

  inline NameOrIdKey& operator=(NameOrIdKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NameOrIdKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NameOrIdKey* internal_default_instance() {
    return reinterpret_cast<const NameOrIdKey*>(
               &_NameOrIdKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(NameOrIdKey* other);
  friend void swap(NameOrIdKey& a, NameOrIdKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NameOrIdKey* New() const final {
    return CreateMaybeMessage<NameOrIdKey>(NULL);
  }

  NameOrIdKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NameOrIdKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NameOrIdKey& from);
  void MergeFrom(const NameOrIdKey& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NameOrIdKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.NameOrId key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  private:
  const ::common::NameOrId& _internal_key() const;
  public:
  const ::common::NameOrId& key() const;
  ::common::NameOrId* release_key();
  ::common::NameOrId* mutable_key();
  void set_allocated_key(::common::NameOrId* key);

  // @@protoc_insertion_point(class_scope:common.NameOrIdKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::NameOrId* key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_expr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Property : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Property) */ {
 public:
  Property();
  virtual ~Property();

  Property(const Property& from);

  inline Property& operator=(const Property& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Property(Property&& from) noexcept
    : Property() {
    *this = ::std::move(from);
  }

  inline Property& operator=(Property&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Property& default_instance();

  enum ItemCase {
    kId = 2,
    kLabel = 3,
    kLen = 4,
    kAll = 5,
    kKey = 6,
    ITEM_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Property* internal_default_instance() {
    return reinterpret_cast<const Property*>(
               &_Property_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Property* other);
  friend void swap(Property& a, Property& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Property* New() const final {
    return CreateMaybeMessage<Property>(NULL);
  }

  Property* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Property>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Property& from);
  void MergeFrom(const Property& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Property* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.IdKey id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  private:
  const ::common::IdKey& _internal_id() const;
  public:
  const ::common::IdKey& id() const;
  ::common::IdKey* release_id();
  ::common::IdKey* mutable_id();
  void set_allocated_id(::common::IdKey* id);

  // .common.LabelKey label = 3;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 3;
  private:
  const ::common::LabelKey& _internal_label() const;
  public:
  const ::common::LabelKey& label() const;
  ::common::LabelKey* release_label();
  ::common::LabelKey* mutable_label();
  void set_allocated_label(::common::LabelKey* label);

  // .common.LengthKey len = 4;
  bool has_len() const;
  void clear_len();
  static const int kLenFieldNumber = 4;
  private:
  const ::common::LengthKey& _internal_len() const;
  public:
  const ::common::LengthKey& len() const;
  ::common::LengthKey* release_len();
  ::common::LengthKey* mutable_len();
  void set_allocated_len(::common::LengthKey* len);

  // .common.AllKey all = 5;
  bool has_all() const;
  void clear_all();
  static const int kAllFieldNumber = 5;
  private:
  const ::common::AllKey& _internal_all() const;
  public:
  const ::common::AllKey& all() const;
  ::common::AllKey* release_all();
  ::common::AllKey* mutable_all();
  void set_allocated_all(::common::AllKey* all);

  // .common.NameOrId key = 6;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 6;
  private:
  const ::common::NameOrId& _internal_key() const;
  public:
  const ::common::NameOrId& key() const;
  ::common::NameOrId* release_key();
  ::common::NameOrId* mutable_key();
  void set_allocated_key(::common::NameOrId* key);

  void clear_item();
  ItemCase item_case() const;
  // @@protoc_insertion_point(class_scope:common.Property)
 private:
  void set_has_id();
  void set_has_label();
  void set_has_len();
  void set_has_all();
  void set_has_key();

  inline bool has_item() const;
  inline void clear_has_item();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ItemUnion {
    ItemUnion() {}
    ::common::IdKey* id_;
    ::common::LabelKey* label_;
    ::common::LengthKey* len_;
    ::common::AllKey* all_;
    ::common::NameOrId* key_;
  } item_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_expr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Variable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Variable) */ {
 public:
  Variable();
  virtual ~Variable();

  Variable(const Variable& from);

  inline Variable& operator=(const Variable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Variable(Variable&& from) noexcept
    : Variable() {
    *this = ::std::move(from);
  }

  inline Variable& operator=(Variable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Variable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Variable* internal_default_instance() {
    return reinterpret_cast<const Variable*>(
               &_Variable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Variable* other);
  friend void swap(Variable& a, Variable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Variable* New() const final {
    return CreateMaybeMessage<Variable>(NULL);
  }

  Variable* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Variable>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Variable& from);
  void MergeFrom(const Variable& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Variable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.NameOrId tag = 1;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  private:
  const ::common::NameOrId& _internal_tag() const;
  public:
  const ::common::NameOrId& tag() const;
  ::common::NameOrId* release_tag();
  ::common::NameOrId* mutable_tag();
  void set_allocated_tag(::common::NameOrId* tag);

  // .common.Property property = 2;
  bool has_property() const;
  void clear_property();
  static const int kPropertyFieldNumber = 2;
  private:
  const ::common::Property& _internal_property() const;
  public:
  const ::common::Property& property() const;
  ::common::Property* release_property();
  ::common::Property* mutable_property();
  void set_allocated_property(::common::Property* property);

  // .common.IrDataType node_type = 3;
  bool has_node_type() const;
  void clear_node_type();
  static const int kNodeTypeFieldNumber = 3;
  private:
  const ::common::IrDataType& _internal_node_type() const;
  public:
  const ::common::IrDataType& node_type() const;
  ::common::IrDataType* release_node_type();
  ::common::IrDataType* mutable_node_type();
  void set_allocated_node_type(::common::IrDataType* node_type);

  // @@protoc_insertion_point(class_scope:common.Variable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::NameOrId* tag_;
  ::common::Property* property_;
  ::common::IrDataType* node_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_expr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VariableKeys : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.VariableKeys) */ {
 public:
  VariableKeys();
  virtual ~VariableKeys();

  VariableKeys(const VariableKeys& from);

  inline VariableKeys& operator=(const VariableKeys& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VariableKeys(VariableKeys&& from) noexcept
    : VariableKeys() {
    *this = ::std::move(from);
  }

  inline VariableKeys& operator=(VariableKeys&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VariableKeys& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VariableKeys* internal_default_instance() {
    return reinterpret_cast<const VariableKeys*>(
               &_VariableKeys_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(VariableKeys* other);
  friend void swap(VariableKeys& a, VariableKeys& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VariableKeys* New() const final {
    return CreateMaybeMessage<VariableKeys>(NULL);
  }

  VariableKeys* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VariableKeys>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VariableKeys& from);
  void MergeFrom(const VariableKeys& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VariableKeys* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .common.Variable keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  ::common::Variable* mutable_keys(int index);
  ::google::protobuf::RepeatedPtrField< ::common::Variable >*
      mutable_keys();
  const ::common::Variable& keys(int index) const;
  ::common::Variable* add_keys();
  const ::google::protobuf::RepeatedPtrField< ::common::Variable >&
      keys() const;

  // @@protoc_insertion_point(class_scope:common.VariableKeys)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::common::Variable > keys_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_expr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DynamicParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.DynamicParam) */ {
 public:
  DynamicParam();
  virtual ~DynamicParam();

  DynamicParam(const DynamicParam& from);

  inline DynamicParam& operator=(const DynamicParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DynamicParam(DynamicParam&& from) noexcept
    : DynamicParam() {
    *this = ::std::move(from);
  }

  inline DynamicParam& operator=(DynamicParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DynamicParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DynamicParam* internal_default_instance() {
    return reinterpret_cast<const DynamicParam*>(
               &_DynamicParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(DynamicParam* other);
  friend void swap(DynamicParam& a, DynamicParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DynamicParam* New() const final {
    return CreateMaybeMessage<DynamicParam>(NULL);
  }

  DynamicParam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DynamicParam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DynamicParam& from);
  void MergeFrom(const DynamicParam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DynamicParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .common.IrDataType data_type = 3;
  bool has_data_type() const;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 3;
  private:
  const ::common::IrDataType& _internal_data_type() const;
  public:
  const ::common::IrDataType& data_type() const;
  ::common::IrDataType* release_data_type();
  ::common::IrDataType* mutable_data_type();
  void set_allocated_data_type(::common::IrDataType* data_type);

  // int32 index = 2;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:common.DynamicParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::common::IrDataType* data_type_;
  ::google::protobuf::int32 index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_expr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Case_WhenThen : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Case.WhenThen) */ {
 public:
  Case_WhenThen();
  virtual ~Case_WhenThen();

  Case_WhenThen(const Case_WhenThen& from);

  inline Case_WhenThen& operator=(const Case_WhenThen& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Case_WhenThen(Case_WhenThen&& from) noexcept
    : Case_WhenThen() {
    *this = ::std::move(from);
  }

  inline Case_WhenThen& operator=(Case_WhenThen&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Case_WhenThen& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Case_WhenThen* internal_default_instance() {
    return reinterpret_cast<const Case_WhenThen*>(
               &_Case_WhenThen_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Case_WhenThen* other);
  friend void swap(Case_WhenThen& a, Case_WhenThen& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Case_WhenThen* New() const final {
    return CreateMaybeMessage<Case_WhenThen>(NULL);
  }

  Case_WhenThen* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Case_WhenThen>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Case_WhenThen& from);
  void MergeFrom(const Case_WhenThen& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Case_WhenThen* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.Expression when_expression = 1;
  bool has_when_expression() const;
  void clear_when_expression();
  static const int kWhenExpressionFieldNumber = 1;
  private:
  const ::common::Expression& _internal_when_expression() const;
  public:
  const ::common::Expression& when_expression() const;
  ::common::Expression* release_when_expression();
  ::common::Expression* mutable_when_expression();
  void set_allocated_when_expression(::common::Expression* when_expression);

  // .common.Expression then_result_expression = 2;
  bool has_then_result_expression() const;
  void clear_then_result_expression();
  static const int kThenResultExpressionFieldNumber = 2;
  private:
  const ::common::Expression& _internal_then_result_expression() const;
  public:
  const ::common::Expression& then_result_expression() const;
  ::common::Expression* release_then_result_expression();
  ::common::Expression* mutable_then_result_expression();
  void set_allocated_then_result_expression(::common::Expression* then_result_expression);

  // @@protoc_insertion_point(class_scope:common.Case.WhenThen)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::Expression* when_expression_;
  ::common::Expression* then_result_expression_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_expr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Case : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Case) */ {
 public:
  Case();
  virtual ~Case();

  Case(const Case& from);

  inline Case& operator=(const Case& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Case(Case&& from) noexcept
    : Case() {
    *this = ::std::move(from);
  }

  inline Case& operator=(Case&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Case& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Case* internal_default_instance() {
    return reinterpret_cast<const Case*>(
               &_Case_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Case* other);
  friend void swap(Case& a, Case& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Case* New() const final {
    return CreateMaybeMessage<Case>(NULL);
  }

  Case* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Case>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Case& from);
  void MergeFrom(const Case& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Case* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Case_WhenThen WhenThen;

  // accessors -------------------------------------------------------

  // repeated .common.Case.WhenThen when_then_expressions = 1;
  int when_then_expressions_size() const;
  void clear_when_then_expressions();
  static const int kWhenThenExpressionsFieldNumber = 1;
  ::common::Case_WhenThen* mutable_when_then_expressions(int index);
  ::google::protobuf::RepeatedPtrField< ::common::Case_WhenThen >*
      mutable_when_then_expressions();
  const ::common::Case_WhenThen& when_then_expressions(int index) const;
  ::common::Case_WhenThen* add_when_then_expressions();
  const ::google::protobuf::RepeatedPtrField< ::common::Case_WhenThen >&
      when_then_expressions() const;

  // .common.Expression else_result_expression = 2;
  bool has_else_result_expression() const;
  void clear_else_result_expression();
  static const int kElseResultExpressionFieldNumber = 2;
  private:
  const ::common::Expression& _internal_else_result_expression() const;
  public:
  const ::common::Expression& else_result_expression() const;
  ::common::Expression* release_else_result_expression();
  ::common::Expression* mutable_else_result_expression();
  void set_allocated_else_result_expression(::common::Expression* else_result_expression);

  // @@protoc_insertion_point(class_scope:common.Case)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::common::Case_WhenThen > when_then_expressions_;
  ::common::Expression* else_result_expression_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_expr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Extract : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Extract) */ {
 public:
  Extract();
  virtual ~Extract();

  Extract(const Extract& from);

  inline Extract& operator=(const Extract& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Extract(Extract&& from) noexcept
    : Extract() {
    *this = ::std::move(from);
  }

  inline Extract& operator=(Extract&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Extract& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Extract* internal_default_instance() {
    return reinterpret_cast<const Extract*>(
               &_Extract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Extract* other);
  friend void swap(Extract& a, Extract& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Extract* New() const final {
    return CreateMaybeMessage<Extract>(NULL);
  }

  Extract* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Extract>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Extract& from);
  void MergeFrom(const Extract& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Extract* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Extract_Interval Interval;
  static const Interval YEAR =
    Extract_Interval_YEAR;
  static const Interval MONTH =
    Extract_Interval_MONTH;
  static const Interval DAY =
    Extract_Interval_DAY;
  static const Interval HOUR =
    Extract_Interval_HOUR;
  static const Interval MINUTE =
    Extract_Interval_MINUTE;
  static const Interval SECOND =
    Extract_Interval_SECOND;
  static inline bool Interval_IsValid(int value) {
    return Extract_Interval_IsValid(value);
  }
  static const Interval Interval_MIN =
    Extract_Interval_Interval_MIN;
  static const Interval Interval_MAX =
    Extract_Interval_Interval_MAX;
  static const int Interval_ARRAYSIZE =
    Extract_Interval_Interval_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Interval_descriptor() {
    return Extract_Interval_descriptor();
  }
  static inline const ::std::string& Interval_Name(Interval value) {
    return Extract_Interval_Name(value);
  }
  static inline bool Interval_Parse(const ::std::string& name,
      Interval* value) {
    return Extract_Interval_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .common.Expression data_time = 2;
  bool has_data_time() const;
  void clear_data_time();
  static const int kDataTimeFieldNumber = 2;
  private:
  const ::common::Expression& _internal_data_time() const;
  public:
  const ::common::Expression& data_time() const;
  ::common::Expression* release_data_time();
  ::common::Expression* mutable_data_time();
  void set_allocated_data_time(::common::Expression* data_time);

  // .common.Extract.Interval interval = 1;
  void clear_interval();
  static const int kIntervalFieldNumber = 1;
  ::common::Extract_Interval interval() const;
  void set_interval(::common::Extract_Interval value);

  // @@protoc_insertion_point(class_scope:common.Extract)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::Expression* data_time_;
  int interval_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_expr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExprOpr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.ExprOpr) */ {
 public:
  ExprOpr();
  virtual ~ExprOpr();

  ExprOpr(const ExprOpr& from);

  inline ExprOpr& operator=(const ExprOpr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExprOpr(ExprOpr&& from) noexcept
    : ExprOpr() {
    *this = ::std::move(from);
  }

  inline ExprOpr& operator=(ExprOpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExprOpr& default_instance();

  enum ItemCase {
    kLogical = 2,
    kArith = 3,
    kConst = 4,
    kVar = 5,
    kBrace = 6,
    kVars = 7,
    kVarMap = 8,
    kParam = 9,
    kCase = 10,
    kExtract = 11,
    ITEM_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExprOpr* internal_default_instance() {
    return reinterpret_cast<const ExprOpr*>(
               &_ExprOpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ExprOpr* other);
  friend void swap(ExprOpr& a, ExprOpr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExprOpr* New() const final {
    return CreateMaybeMessage<ExprOpr>(NULL);
  }

  ExprOpr* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExprOpr>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExprOpr& from);
  void MergeFrom(const ExprOpr& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExprOpr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ExprOpr_Brace Brace;
  static const Brace LEFT_BRACE =
    ExprOpr_Brace_LEFT_BRACE;
  static const Brace RIGHT_BRACE =
    ExprOpr_Brace_RIGHT_BRACE;
  static inline bool Brace_IsValid(int value) {
    return ExprOpr_Brace_IsValid(value);
  }
  static const Brace Brace_MIN =
    ExprOpr_Brace_Brace_MIN;
  static const Brace Brace_MAX =
    ExprOpr_Brace_Brace_MAX;
  static const int Brace_ARRAYSIZE =
    ExprOpr_Brace_Brace_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Brace_descriptor() {
    return ExprOpr_Brace_descriptor();
  }
  static inline const ::std::string& Brace_Name(Brace value) {
    return ExprOpr_Brace_Name(value);
  }
  static inline bool Brace_Parse(const ::std::string& name,
      Brace* value) {
    return ExprOpr_Brace_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .common.IrDataType node_type = 12;
  bool has_node_type() const;
  void clear_node_type();
  static const int kNodeTypeFieldNumber = 12;
  private:
  const ::common::IrDataType& _internal_node_type() const;
  public:
  const ::common::IrDataType& node_type() const;
  ::common::IrDataType* release_node_type();
  ::common::IrDataType* mutable_node_type();
  void set_allocated_node_type(::common::IrDataType* node_type);

  // .common.Logical logical = 2;
  private:
  bool has_logical() const;
  public:
  void clear_logical();
  static const int kLogicalFieldNumber = 2;
  ::common::Logical logical() const;
  void set_logical(::common::Logical value);

  // .common.Arithmetic arith = 3;
  private:
  bool has_arith() const;
  public:
  void clear_arith();
  static const int kArithFieldNumber = 3;
  ::common::Arithmetic arith() const;
  void set_arith(::common::Arithmetic value);

  // .common.Value const = 4;
  bool has_const_() const;
  void clear_const_();
  static const int kConstFieldNumber = 4;
  private:
  const ::common::Value& _internal_const_() const;
  public:
  const ::common::Value& const_() const;
  ::common::Value* release_const_();
  ::common::Value* mutable_const_();
  void set_allocated_const_(::common::Value* const_);

  // .common.Variable var = 5;
  bool has_var() const;
  void clear_var();
  static const int kVarFieldNumber = 5;
  private:
  const ::common::Variable& _internal_var() const;
  public:
  const ::common::Variable& var() const;
  ::common::Variable* release_var();
  ::common::Variable* mutable_var();
  void set_allocated_var(::common::Variable* var);

  // .common.ExprOpr.Brace brace = 6;
  private:
  bool has_brace() const;
  public:
  void clear_brace();
  static const int kBraceFieldNumber = 6;
  ::common::ExprOpr_Brace brace() const;
  void set_brace(::common::ExprOpr_Brace value);

  // .common.VariableKeys vars = 7;
  bool has_vars() const;
  void clear_vars();
  static const int kVarsFieldNumber = 7;
  private:
  const ::common::VariableKeys& _internal_vars() const;
  public:
  const ::common::VariableKeys& vars() const;
  ::common::VariableKeys* release_vars();
  ::common::VariableKeys* mutable_vars();
  void set_allocated_vars(::common::VariableKeys* vars);

  // .common.VariableKeys var_map = 8;
  bool has_var_map() const;
  void clear_var_map();
  static const int kVarMapFieldNumber = 8;
  private:
  const ::common::VariableKeys& _internal_var_map() const;
  public:
  const ::common::VariableKeys& var_map() const;
  ::common::VariableKeys* release_var_map();
  ::common::VariableKeys* mutable_var_map();
  void set_allocated_var_map(::common::VariableKeys* var_map);

  // .common.DynamicParam param = 9;
  bool has_param() const;
  void clear_param();
  static const int kParamFieldNumber = 9;
  private:
  const ::common::DynamicParam& _internal_param() const;
  public:
  const ::common::DynamicParam& param() const;
  ::common::DynamicParam* release_param();
  ::common::DynamicParam* mutable_param();
  void set_allocated_param(::common::DynamicParam* param);

  // .common.Case case = 10;
  bool has_case_() const;
  void clear_case_();
  static const int kCaseFieldNumber = 10;
  private:
  const ::common::Case& _internal_case_() const;
  public:
  const ::common::Case& case_() const;
  ::common::Case* release_case_();
  ::common::Case* mutable_case_();
  void set_allocated_case_(::common::Case* case_);

  // .common.Extract extract = 11;
  bool has_extract() const;
  void clear_extract();
  static const int kExtractFieldNumber = 11;
  private:
  const ::common::Extract& _internal_extract() const;
  public:
  const ::common::Extract& extract() const;
  ::common::Extract* release_extract();
  ::common::Extract* mutable_extract();
  void set_allocated_extract(::common::Extract* extract);

  void clear_item();
  ItemCase item_case() const;
  // @@protoc_insertion_point(class_scope:common.ExprOpr)
 private:
  void set_has_logical();
  void set_has_arith();
  void set_has_const_();
  void set_has_var();
  void set_has_brace();
  void set_has_vars();
  void set_has_var_map();
  void set_has_param();
  void set_has_case_();
  void set_has_extract();

  inline bool has_item() const;
  inline void clear_has_item();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::common::IrDataType* node_type_;
  union ItemUnion {
    ItemUnion() {}
    int logical_;
    int arith_;
    ::common::Value* const__;
    ::common::Variable* var_;
    int brace_;
    ::common::VariableKeys* vars_;
    ::common::VariableKeys* var_map_;
    ::common::DynamicParam* param_;
    ::common::Case* case__;
    ::common::Extract* extract_;
  } item_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_expr_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:common.Expression) */ {
 public:
  Expression();
  virtual ~Expression();

  Expression(const Expression& from);

  inline Expression& operator=(const Expression& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression(Expression&& from) noexcept
    : Expression() {
    *this = ::std::move(from);
  }

  inline Expression& operator=(Expression&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression* internal_default_instance() {
    return reinterpret_cast<const Expression*>(
               &_Expression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Expression* other);
  friend void swap(Expression& a, Expression& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression* New() const final {
    return CreateMaybeMessage<Expression>(NULL);
  }

  Expression* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression& from);
  void MergeFrom(const Expression& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .common.ExprOpr operators = 1;
  int operators_size() const;
  void clear_operators();
  static const int kOperatorsFieldNumber = 1;
  ::common::ExprOpr* mutable_operators(int index);
  ::google::protobuf::RepeatedPtrField< ::common::ExprOpr >*
      mutable_operators();
  const ::common::ExprOpr& operators(int index) const;
  ::common::ExprOpr* add_operators();
  const ::google::protobuf::RepeatedPtrField< ::common::ExprOpr >&
      operators() const;

  // @@protoc_insertion_point(class_scope:common.Expression)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::common::ExprOpr > operators_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_expr_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// IdKey

// -------------------------------------------------------------------

// LabelKey

// -------------------------------------------------------------------

// LengthKey

// -------------------------------------------------------------------

// AllKey

// -------------------------------------------------------------------

// NameOrIdKey

// .common.NameOrId key = 1;
inline bool NameOrIdKey::has_key() const {
  return this != internal_default_instance() && key_ != NULL;
}
inline const ::common::NameOrId& NameOrIdKey::_internal_key() const {
  return *key_;
}
inline const ::common::NameOrId& NameOrIdKey::key() const {
  const ::common::NameOrId* p = key_;
  // @@protoc_insertion_point(field_get:common.NameOrIdKey.key)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* NameOrIdKey::release_key() {
  // @@protoc_insertion_point(field_release:common.NameOrIdKey.key)
  
  ::common::NameOrId* temp = key_;
  key_ = NULL;
  return temp;
}
inline ::common::NameOrId* NameOrIdKey::mutable_key() {
  
  if (key_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.NameOrIdKey.key)
  return key_;
}
inline void NameOrIdKey::set_allocated_key(::common::NameOrId* key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(key_);
  }
  if (key) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:common.NameOrIdKey.key)
}

// -------------------------------------------------------------------

// Property

// .common.IdKey id = 2;
inline bool Property::has_id() const {
  return item_case() == kId;
}
inline void Property::set_has_id() {
  _oneof_case_[0] = kId;
}
inline void Property::clear_id() {
  if (has_id()) {
    delete item_.id_;
    clear_has_item();
  }
}
inline const ::common::IdKey& Property::_internal_id() const {
  return *item_.id_;
}
inline ::common::IdKey* Property::release_id() {
  // @@protoc_insertion_point(field_release:common.Property.id)
  if (has_id()) {
    clear_has_item();
      ::common::IdKey* temp = item_.id_;
    item_.id_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::common::IdKey& Property::id() const {
  // @@protoc_insertion_point(field_get:common.Property.id)
  return has_id()
      ? *item_.id_
      : *reinterpret_cast< ::common::IdKey*>(&::common::_IdKey_default_instance_);
}
inline ::common::IdKey* Property::mutable_id() {
  if (!has_id()) {
    clear_item();
    set_has_id();
    item_.id_ = CreateMaybeMessage< ::common::IdKey >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:common.Property.id)
  return item_.id_;
}

// .common.LabelKey label = 3;
inline bool Property::has_label() const {
  return item_case() == kLabel;
}
inline void Property::set_has_label() {
  _oneof_case_[0] = kLabel;
}
inline void Property::clear_label() {
  if (has_label()) {
    delete item_.label_;
    clear_has_item();
  }
}
inline const ::common::LabelKey& Property::_internal_label() const {
  return *item_.label_;
}
inline ::common::LabelKey* Property::release_label() {
  // @@protoc_insertion_point(field_release:common.Property.label)
  if (has_label()) {
    clear_has_item();
      ::common::LabelKey* temp = item_.label_;
    item_.label_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::common::LabelKey& Property::label() const {
  // @@protoc_insertion_point(field_get:common.Property.label)
  return has_label()
      ? *item_.label_
      : *reinterpret_cast< ::common::LabelKey*>(&::common::_LabelKey_default_instance_);
}
inline ::common::LabelKey* Property::mutable_label() {
  if (!has_label()) {
    clear_item();
    set_has_label();
    item_.label_ = CreateMaybeMessage< ::common::LabelKey >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:common.Property.label)
  return item_.label_;
}

// .common.LengthKey len = 4;
inline bool Property::has_len() const {
  return item_case() == kLen;
}
inline void Property::set_has_len() {
  _oneof_case_[0] = kLen;
}
inline void Property::clear_len() {
  if (has_len()) {
    delete item_.len_;
    clear_has_item();
  }
}
inline const ::common::LengthKey& Property::_internal_len() const {
  return *item_.len_;
}
inline ::common::LengthKey* Property::release_len() {
  // @@protoc_insertion_point(field_release:common.Property.len)
  if (has_len()) {
    clear_has_item();
      ::common::LengthKey* temp = item_.len_;
    item_.len_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::common::LengthKey& Property::len() const {
  // @@protoc_insertion_point(field_get:common.Property.len)
  return has_len()
      ? *item_.len_
      : *reinterpret_cast< ::common::LengthKey*>(&::common::_LengthKey_default_instance_);
}
inline ::common::LengthKey* Property::mutable_len() {
  if (!has_len()) {
    clear_item();
    set_has_len();
    item_.len_ = CreateMaybeMessage< ::common::LengthKey >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:common.Property.len)
  return item_.len_;
}

// .common.AllKey all = 5;
inline bool Property::has_all() const {
  return item_case() == kAll;
}
inline void Property::set_has_all() {
  _oneof_case_[0] = kAll;
}
inline void Property::clear_all() {
  if (has_all()) {
    delete item_.all_;
    clear_has_item();
  }
}
inline const ::common::AllKey& Property::_internal_all() const {
  return *item_.all_;
}
inline ::common::AllKey* Property::release_all() {
  // @@protoc_insertion_point(field_release:common.Property.all)
  if (has_all()) {
    clear_has_item();
      ::common::AllKey* temp = item_.all_;
    item_.all_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::common::AllKey& Property::all() const {
  // @@protoc_insertion_point(field_get:common.Property.all)
  return has_all()
      ? *item_.all_
      : *reinterpret_cast< ::common::AllKey*>(&::common::_AllKey_default_instance_);
}
inline ::common::AllKey* Property::mutable_all() {
  if (!has_all()) {
    clear_item();
    set_has_all();
    item_.all_ = CreateMaybeMessage< ::common::AllKey >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:common.Property.all)
  return item_.all_;
}

// .common.NameOrId key = 6;
inline bool Property::has_key() const {
  return item_case() == kKey;
}
inline void Property::set_has_key() {
  _oneof_case_[0] = kKey;
}
inline const ::common::NameOrId& Property::_internal_key() const {
  return *item_.key_;
}
inline ::common::NameOrId* Property::release_key() {
  // @@protoc_insertion_point(field_release:common.Property.key)
  if (has_key()) {
    clear_has_item();
      ::common::NameOrId* temp = item_.key_;
    item_.key_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::common::NameOrId& Property::key() const {
  // @@protoc_insertion_point(field_get:common.Property.key)
  return has_key()
      ? *item_.key_
      : *reinterpret_cast< ::common::NameOrId*>(&::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* Property::mutable_key() {
  if (!has_key()) {
    clear_item();
    set_has_key();
    item_.key_ = CreateMaybeMessage< ::common::NameOrId >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:common.Property.key)
  return item_.key_;
}

inline bool Property::has_item() const {
  return item_case() != ITEM_NOT_SET;
}
inline void Property::clear_has_item() {
  _oneof_case_[0] = ITEM_NOT_SET;
}
inline Property::ItemCase Property::item_case() const {
  return Property::ItemCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Variable

// .common.NameOrId tag = 1;
inline bool Variable::has_tag() const {
  return this != internal_default_instance() && tag_ != NULL;
}
inline const ::common::NameOrId& Variable::_internal_tag() const {
  return *tag_;
}
inline const ::common::NameOrId& Variable::tag() const {
  const ::common::NameOrId* p = tag_;
  // @@protoc_insertion_point(field_get:common.Variable.tag)
  return p != NULL ? *p : *reinterpret_cast<const ::common::NameOrId*>(
      &::common::_NameOrId_default_instance_);
}
inline ::common::NameOrId* Variable::release_tag() {
  // @@protoc_insertion_point(field_release:common.Variable.tag)
  
  ::common::NameOrId* temp = tag_;
  tag_ = NULL;
  return temp;
}
inline ::common::NameOrId* Variable::mutable_tag() {
  
  if (tag_ == NULL) {
    auto* p = CreateMaybeMessage<::common::NameOrId>(GetArenaNoVirtual());
    tag_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.Variable.tag)
  return tag_;
}
inline void Variable::set_allocated_tag(::common::NameOrId* tag) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tag_);
  }
  if (tag) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tag = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tag, submessage_arena);
    }
    
  } else {
    
  }
  tag_ = tag;
  // @@protoc_insertion_point(field_set_allocated:common.Variable.tag)
}

// .common.Property property = 2;
inline bool Variable::has_property() const {
  return this != internal_default_instance() && property_ != NULL;
}
inline void Variable::clear_property() {
  if (GetArenaNoVirtual() == NULL && property_ != NULL) {
    delete property_;
  }
  property_ = NULL;
}
inline const ::common::Property& Variable::_internal_property() const {
  return *property_;
}
inline const ::common::Property& Variable::property() const {
  const ::common::Property* p = property_;
  // @@protoc_insertion_point(field_get:common.Variable.property)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Property*>(
      &::common::_Property_default_instance_);
}
inline ::common::Property* Variable::release_property() {
  // @@protoc_insertion_point(field_release:common.Variable.property)
  
  ::common::Property* temp = property_;
  property_ = NULL;
  return temp;
}
inline ::common::Property* Variable::mutable_property() {
  
  if (property_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Property>(GetArenaNoVirtual());
    property_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.Variable.property)
  return property_;
}
inline void Variable::set_allocated_property(::common::Property* property) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete property_;
  }
  if (property) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      property = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, property, submessage_arena);
    }
    
  } else {
    
  }
  property_ = property;
  // @@protoc_insertion_point(field_set_allocated:common.Variable.property)
}

// .common.IrDataType node_type = 3;
inline bool Variable::has_node_type() const {
  return this != internal_default_instance() && node_type_ != NULL;
}
inline const ::common::IrDataType& Variable::_internal_node_type() const {
  return *node_type_;
}
inline const ::common::IrDataType& Variable::node_type() const {
  const ::common::IrDataType* p = node_type_;
  // @@protoc_insertion_point(field_get:common.Variable.node_type)
  return p != NULL ? *p : *reinterpret_cast<const ::common::IrDataType*>(
      &::common::_IrDataType_default_instance_);
}
inline ::common::IrDataType* Variable::release_node_type() {
  // @@protoc_insertion_point(field_release:common.Variable.node_type)
  
  ::common::IrDataType* temp = node_type_;
  node_type_ = NULL;
  return temp;
}
inline ::common::IrDataType* Variable::mutable_node_type() {
  
  if (node_type_ == NULL) {
    auto* p = CreateMaybeMessage<::common::IrDataType>(GetArenaNoVirtual());
    node_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.Variable.node_type)
  return node_type_;
}
inline void Variable::set_allocated_node_type(::common::IrDataType* node_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(node_type_);
  }
  if (node_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      node_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node_type, submessage_arena);
    }
    
  } else {
    
  }
  node_type_ = node_type;
  // @@protoc_insertion_point(field_set_allocated:common.Variable.node_type)
}

// -------------------------------------------------------------------

// VariableKeys

// repeated .common.Variable keys = 1;
inline int VariableKeys::keys_size() const {
  return keys_.size();
}
inline void VariableKeys::clear_keys() {
  keys_.Clear();
}
inline ::common::Variable* VariableKeys::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:common.VariableKeys.keys)
  return keys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::common::Variable >*
VariableKeys::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:common.VariableKeys.keys)
  return &keys_;
}
inline const ::common::Variable& VariableKeys::keys(int index) const {
  // @@protoc_insertion_point(field_get:common.VariableKeys.keys)
  return keys_.Get(index);
}
inline ::common::Variable* VariableKeys::add_keys() {
  // @@protoc_insertion_point(field_add:common.VariableKeys.keys)
  return keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::Variable >&
VariableKeys::keys() const {
  // @@protoc_insertion_point(field_list:common.VariableKeys.keys)
  return keys_;
}

// -------------------------------------------------------------------

// DynamicParam

// string name = 1;
inline void DynamicParam::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DynamicParam::name() const {
  // @@protoc_insertion_point(field_get:common.DynamicParam.name)
  return name_.GetNoArena();
}
inline void DynamicParam::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:common.DynamicParam.name)
}
#if LANG_CXX11
inline void DynamicParam::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:common.DynamicParam.name)
}
#endif
inline void DynamicParam::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:common.DynamicParam.name)
}
inline void DynamicParam::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:common.DynamicParam.name)
}
inline ::std::string* DynamicParam::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:common.DynamicParam.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DynamicParam::release_name() {
  // @@protoc_insertion_point(field_release:common.DynamicParam.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DynamicParam::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:common.DynamicParam.name)
}

// int32 index = 2;
inline void DynamicParam::clear_index() {
  index_ = 0;
}
inline ::google::protobuf::int32 DynamicParam::index() const {
  // @@protoc_insertion_point(field_get:common.DynamicParam.index)
  return index_;
}
inline void DynamicParam::set_index(::google::protobuf::int32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:common.DynamicParam.index)
}

// .common.IrDataType data_type = 3;
inline bool DynamicParam::has_data_type() const {
  return this != internal_default_instance() && data_type_ != NULL;
}
inline const ::common::IrDataType& DynamicParam::_internal_data_type() const {
  return *data_type_;
}
inline const ::common::IrDataType& DynamicParam::data_type() const {
  const ::common::IrDataType* p = data_type_;
  // @@protoc_insertion_point(field_get:common.DynamicParam.data_type)
  return p != NULL ? *p : *reinterpret_cast<const ::common::IrDataType*>(
      &::common::_IrDataType_default_instance_);
}
inline ::common::IrDataType* DynamicParam::release_data_type() {
  // @@protoc_insertion_point(field_release:common.DynamicParam.data_type)
  
  ::common::IrDataType* temp = data_type_;
  data_type_ = NULL;
  return temp;
}
inline ::common::IrDataType* DynamicParam::mutable_data_type() {
  
  if (data_type_ == NULL) {
    auto* p = CreateMaybeMessage<::common::IrDataType>(GetArenaNoVirtual());
    data_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.DynamicParam.data_type)
  return data_type_;
}
inline void DynamicParam::set_allocated_data_type(::common::IrDataType* data_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(data_type_);
  }
  if (data_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data_type, submessage_arena);
    }
    
  } else {
    
  }
  data_type_ = data_type;
  // @@protoc_insertion_point(field_set_allocated:common.DynamicParam.data_type)
}

// -------------------------------------------------------------------

// Case_WhenThen

// .common.Expression when_expression = 1;
inline bool Case_WhenThen::has_when_expression() const {
  return this != internal_default_instance() && when_expression_ != NULL;
}
inline void Case_WhenThen::clear_when_expression() {
  if (GetArenaNoVirtual() == NULL && when_expression_ != NULL) {
    delete when_expression_;
  }
  when_expression_ = NULL;
}
inline const ::common::Expression& Case_WhenThen::_internal_when_expression() const {
  return *when_expression_;
}
inline const ::common::Expression& Case_WhenThen::when_expression() const {
  const ::common::Expression* p = when_expression_;
  // @@protoc_insertion_point(field_get:common.Case.WhenThen.when_expression)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Expression*>(
      &::common::_Expression_default_instance_);
}
inline ::common::Expression* Case_WhenThen::release_when_expression() {
  // @@protoc_insertion_point(field_release:common.Case.WhenThen.when_expression)
  
  ::common::Expression* temp = when_expression_;
  when_expression_ = NULL;
  return temp;
}
inline ::common::Expression* Case_WhenThen::mutable_when_expression() {
  
  if (when_expression_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Expression>(GetArenaNoVirtual());
    when_expression_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.Case.WhenThen.when_expression)
  return when_expression_;
}
inline void Case_WhenThen::set_allocated_when_expression(::common::Expression* when_expression) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete when_expression_;
  }
  if (when_expression) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      when_expression = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, when_expression, submessage_arena);
    }
    
  } else {
    
  }
  when_expression_ = when_expression;
  // @@protoc_insertion_point(field_set_allocated:common.Case.WhenThen.when_expression)
}

// .common.Expression then_result_expression = 2;
inline bool Case_WhenThen::has_then_result_expression() const {
  return this != internal_default_instance() && then_result_expression_ != NULL;
}
inline void Case_WhenThen::clear_then_result_expression() {
  if (GetArenaNoVirtual() == NULL && then_result_expression_ != NULL) {
    delete then_result_expression_;
  }
  then_result_expression_ = NULL;
}
inline const ::common::Expression& Case_WhenThen::_internal_then_result_expression() const {
  return *then_result_expression_;
}
inline const ::common::Expression& Case_WhenThen::then_result_expression() const {
  const ::common::Expression* p = then_result_expression_;
  // @@protoc_insertion_point(field_get:common.Case.WhenThen.then_result_expression)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Expression*>(
      &::common::_Expression_default_instance_);
}
inline ::common::Expression* Case_WhenThen::release_then_result_expression() {
  // @@protoc_insertion_point(field_release:common.Case.WhenThen.then_result_expression)
  
  ::common::Expression* temp = then_result_expression_;
  then_result_expression_ = NULL;
  return temp;
}
inline ::common::Expression* Case_WhenThen::mutable_then_result_expression() {
  
  if (then_result_expression_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Expression>(GetArenaNoVirtual());
    then_result_expression_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.Case.WhenThen.then_result_expression)
  return then_result_expression_;
}
inline void Case_WhenThen::set_allocated_then_result_expression(::common::Expression* then_result_expression) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete then_result_expression_;
  }
  if (then_result_expression) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      then_result_expression = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, then_result_expression, submessage_arena);
    }
    
  } else {
    
  }
  then_result_expression_ = then_result_expression;
  // @@protoc_insertion_point(field_set_allocated:common.Case.WhenThen.then_result_expression)
}

// -------------------------------------------------------------------

// Case

// repeated .common.Case.WhenThen when_then_expressions = 1;
inline int Case::when_then_expressions_size() const {
  return when_then_expressions_.size();
}
inline void Case::clear_when_then_expressions() {
  when_then_expressions_.Clear();
}
inline ::common::Case_WhenThen* Case::mutable_when_then_expressions(int index) {
  // @@protoc_insertion_point(field_mutable:common.Case.when_then_expressions)
  return when_then_expressions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::common::Case_WhenThen >*
Case::mutable_when_then_expressions() {
  // @@protoc_insertion_point(field_mutable_list:common.Case.when_then_expressions)
  return &when_then_expressions_;
}
inline const ::common::Case_WhenThen& Case::when_then_expressions(int index) const {
  // @@protoc_insertion_point(field_get:common.Case.when_then_expressions)
  return when_then_expressions_.Get(index);
}
inline ::common::Case_WhenThen* Case::add_when_then_expressions() {
  // @@protoc_insertion_point(field_add:common.Case.when_then_expressions)
  return when_then_expressions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::Case_WhenThen >&
Case::when_then_expressions() const {
  // @@protoc_insertion_point(field_list:common.Case.when_then_expressions)
  return when_then_expressions_;
}

// .common.Expression else_result_expression = 2;
inline bool Case::has_else_result_expression() const {
  return this != internal_default_instance() && else_result_expression_ != NULL;
}
inline void Case::clear_else_result_expression() {
  if (GetArenaNoVirtual() == NULL && else_result_expression_ != NULL) {
    delete else_result_expression_;
  }
  else_result_expression_ = NULL;
}
inline const ::common::Expression& Case::_internal_else_result_expression() const {
  return *else_result_expression_;
}
inline const ::common::Expression& Case::else_result_expression() const {
  const ::common::Expression* p = else_result_expression_;
  // @@protoc_insertion_point(field_get:common.Case.else_result_expression)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Expression*>(
      &::common::_Expression_default_instance_);
}
inline ::common::Expression* Case::release_else_result_expression() {
  // @@protoc_insertion_point(field_release:common.Case.else_result_expression)
  
  ::common::Expression* temp = else_result_expression_;
  else_result_expression_ = NULL;
  return temp;
}
inline ::common::Expression* Case::mutable_else_result_expression() {
  
  if (else_result_expression_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Expression>(GetArenaNoVirtual());
    else_result_expression_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.Case.else_result_expression)
  return else_result_expression_;
}
inline void Case::set_allocated_else_result_expression(::common::Expression* else_result_expression) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete else_result_expression_;
  }
  if (else_result_expression) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      else_result_expression = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, else_result_expression, submessage_arena);
    }
    
  } else {
    
  }
  else_result_expression_ = else_result_expression;
  // @@protoc_insertion_point(field_set_allocated:common.Case.else_result_expression)
}

// -------------------------------------------------------------------

// Extract

// .common.Extract.Interval interval = 1;
inline void Extract::clear_interval() {
  interval_ = 0;
}
inline ::common::Extract_Interval Extract::interval() const {
  // @@protoc_insertion_point(field_get:common.Extract.interval)
  return static_cast< ::common::Extract_Interval >(interval_);
}
inline void Extract::set_interval(::common::Extract_Interval value) {
  
  interval_ = value;
  // @@protoc_insertion_point(field_set:common.Extract.interval)
}

// .common.Expression data_time = 2;
inline bool Extract::has_data_time() const {
  return this != internal_default_instance() && data_time_ != NULL;
}
inline void Extract::clear_data_time() {
  if (GetArenaNoVirtual() == NULL && data_time_ != NULL) {
    delete data_time_;
  }
  data_time_ = NULL;
}
inline const ::common::Expression& Extract::_internal_data_time() const {
  return *data_time_;
}
inline const ::common::Expression& Extract::data_time() const {
  const ::common::Expression* p = data_time_;
  // @@protoc_insertion_point(field_get:common.Extract.data_time)
  return p != NULL ? *p : *reinterpret_cast<const ::common::Expression*>(
      &::common::_Expression_default_instance_);
}
inline ::common::Expression* Extract::release_data_time() {
  // @@protoc_insertion_point(field_release:common.Extract.data_time)
  
  ::common::Expression* temp = data_time_;
  data_time_ = NULL;
  return temp;
}
inline ::common::Expression* Extract::mutable_data_time() {
  
  if (data_time_ == NULL) {
    auto* p = CreateMaybeMessage<::common::Expression>(GetArenaNoVirtual());
    data_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.Extract.data_time)
  return data_time_;
}
inline void Extract::set_allocated_data_time(::common::Expression* data_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete data_time_;
  }
  if (data_time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data_time, submessage_arena);
    }
    
  } else {
    
  }
  data_time_ = data_time;
  // @@protoc_insertion_point(field_set_allocated:common.Extract.data_time)
}

// -------------------------------------------------------------------

// ExprOpr

// .common.Logical logical = 2;
inline bool ExprOpr::has_logical() const {
  return item_case() == kLogical;
}
inline void ExprOpr::set_has_logical() {
  _oneof_case_[0] = kLogical;
}
inline void ExprOpr::clear_logical() {
  if (has_logical()) {
    item_.logical_ = 0;
    clear_has_item();
  }
}
inline ::common::Logical ExprOpr::logical() const {
  // @@protoc_insertion_point(field_get:common.ExprOpr.logical)
  if (has_logical()) {
    return static_cast< ::common::Logical >(item_.logical_);
  }
  return static_cast< ::common::Logical >(0);
}
inline void ExprOpr::set_logical(::common::Logical value) {
  if (!has_logical()) {
    clear_item();
    set_has_logical();
  }
  item_.logical_ = value;
  // @@protoc_insertion_point(field_set:common.ExprOpr.logical)
}

// .common.Arithmetic arith = 3;
inline bool ExprOpr::has_arith() const {
  return item_case() == kArith;
}
inline void ExprOpr::set_has_arith() {
  _oneof_case_[0] = kArith;
}
inline void ExprOpr::clear_arith() {
  if (has_arith()) {
    item_.arith_ = 0;
    clear_has_item();
  }
}
inline ::common::Arithmetic ExprOpr::arith() const {
  // @@protoc_insertion_point(field_get:common.ExprOpr.arith)
  if (has_arith()) {
    return static_cast< ::common::Arithmetic >(item_.arith_);
  }
  return static_cast< ::common::Arithmetic >(0);
}
inline void ExprOpr::set_arith(::common::Arithmetic value) {
  if (!has_arith()) {
    clear_item();
    set_has_arith();
  }
  item_.arith_ = value;
  // @@protoc_insertion_point(field_set:common.ExprOpr.arith)
}

// .common.Value const = 4;
inline bool ExprOpr::has_const_() const {
  return item_case() == kConst;
}
inline void ExprOpr::set_has_const_() {
  _oneof_case_[0] = kConst;
}
inline const ::common::Value& ExprOpr::_internal_const_() const {
  return *item_.const__;
}
inline ::common::Value* ExprOpr::release_const_() {
  // @@protoc_insertion_point(field_release:common.ExprOpr.const)
  if (has_const_()) {
    clear_has_item();
      ::common::Value* temp = item_.const__;
    item_.const__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::common::Value& ExprOpr::const_() const {
  // @@protoc_insertion_point(field_get:common.ExprOpr.const)
  return has_const_()
      ? *item_.const__
      : *reinterpret_cast< ::common::Value*>(&::common::_Value_default_instance_);
}
inline ::common::Value* ExprOpr::mutable_const_() {
  if (!has_const_()) {
    clear_item();
    set_has_const_();
    item_.const__ = CreateMaybeMessage< ::common::Value >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:common.ExprOpr.const)
  return item_.const__;
}

// .common.Variable var = 5;
inline bool ExprOpr::has_var() const {
  return item_case() == kVar;
}
inline void ExprOpr::set_has_var() {
  _oneof_case_[0] = kVar;
}
inline void ExprOpr::clear_var() {
  if (has_var()) {
    delete item_.var_;
    clear_has_item();
  }
}
inline const ::common::Variable& ExprOpr::_internal_var() const {
  return *item_.var_;
}
inline ::common::Variable* ExprOpr::release_var() {
  // @@protoc_insertion_point(field_release:common.ExprOpr.var)
  if (has_var()) {
    clear_has_item();
      ::common::Variable* temp = item_.var_;
    item_.var_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::common::Variable& ExprOpr::var() const {
  // @@protoc_insertion_point(field_get:common.ExprOpr.var)
  return has_var()
      ? *item_.var_
      : *reinterpret_cast< ::common::Variable*>(&::common::_Variable_default_instance_);
}
inline ::common::Variable* ExprOpr::mutable_var() {
  if (!has_var()) {
    clear_item();
    set_has_var();
    item_.var_ = CreateMaybeMessage< ::common::Variable >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:common.ExprOpr.var)
  return item_.var_;
}

// .common.ExprOpr.Brace brace = 6;
inline bool ExprOpr::has_brace() const {
  return item_case() == kBrace;
}
inline void ExprOpr::set_has_brace() {
  _oneof_case_[0] = kBrace;
}
inline void ExprOpr::clear_brace() {
  if (has_brace()) {
    item_.brace_ = 0;
    clear_has_item();
  }
}
inline ::common::ExprOpr_Brace ExprOpr::brace() const {
  // @@protoc_insertion_point(field_get:common.ExprOpr.brace)
  if (has_brace()) {
    return static_cast< ::common::ExprOpr_Brace >(item_.brace_);
  }
  return static_cast< ::common::ExprOpr_Brace >(0);
}
inline void ExprOpr::set_brace(::common::ExprOpr_Brace value) {
  if (!has_brace()) {
    clear_item();
    set_has_brace();
  }
  item_.brace_ = value;
  // @@protoc_insertion_point(field_set:common.ExprOpr.brace)
}

// .common.VariableKeys vars = 7;
inline bool ExprOpr::has_vars() const {
  return item_case() == kVars;
}
inline void ExprOpr::set_has_vars() {
  _oneof_case_[0] = kVars;
}
inline void ExprOpr::clear_vars() {
  if (has_vars()) {
    delete item_.vars_;
    clear_has_item();
  }
}
inline const ::common::VariableKeys& ExprOpr::_internal_vars() const {
  return *item_.vars_;
}
inline ::common::VariableKeys* ExprOpr::release_vars() {
  // @@protoc_insertion_point(field_release:common.ExprOpr.vars)
  if (has_vars()) {
    clear_has_item();
      ::common::VariableKeys* temp = item_.vars_;
    item_.vars_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::common::VariableKeys& ExprOpr::vars() const {
  // @@protoc_insertion_point(field_get:common.ExprOpr.vars)
  return has_vars()
      ? *item_.vars_
      : *reinterpret_cast< ::common::VariableKeys*>(&::common::_VariableKeys_default_instance_);
}
inline ::common::VariableKeys* ExprOpr::mutable_vars() {
  if (!has_vars()) {
    clear_item();
    set_has_vars();
    item_.vars_ = CreateMaybeMessage< ::common::VariableKeys >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:common.ExprOpr.vars)
  return item_.vars_;
}

// .common.VariableKeys var_map = 8;
inline bool ExprOpr::has_var_map() const {
  return item_case() == kVarMap;
}
inline void ExprOpr::set_has_var_map() {
  _oneof_case_[0] = kVarMap;
}
inline void ExprOpr::clear_var_map() {
  if (has_var_map()) {
    delete item_.var_map_;
    clear_has_item();
  }
}
inline const ::common::VariableKeys& ExprOpr::_internal_var_map() const {
  return *item_.var_map_;
}
inline ::common::VariableKeys* ExprOpr::release_var_map() {
  // @@protoc_insertion_point(field_release:common.ExprOpr.var_map)
  if (has_var_map()) {
    clear_has_item();
      ::common::VariableKeys* temp = item_.var_map_;
    item_.var_map_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::common::VariableKeys& ExprOpr::var_map() const {
  // @@protoc_insertion_point(field_get:common.ExprOpr.var_map)
  return has_var_map()
      ? *item_.var_map_
      : *reinterpret_cast< ::common::VariableKeys*>(&::common::_VariableKeys_default_instance_);
}
inline ::common::VariableKeys* ExprOpr::mutable_var_map() {
  if (!has_var_map()) {
    clear_item();
    set_has_var_map();
    item_.var_map_ = CreateMaybeMessage< ::common::VariableKeys >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:common.ExprOpr.var_map)
  return item_.var_map_;
}

// .common.DynamicParam param = 9;
inline bool ExprOpr::has_param() const {
  return item_case() == kParam;
}
inline void ExprOpr::set_has_param() {
  _oneof_case_[0] = kParam;
}
inline void ExprOpr::clear_param() {
  if (has_param()) {
    delete item_.param_;
    clear_has_item();
  }
}
inline const ::common::DynamicParam& ExprOpr::_internal_param() const {
  return *item_.param_;
}
inline ::common::DynamicParam* ExprOpr::release_param() {
  // @@protoc_insertion_point(field_release:common.ExprOpr.param)
  if (has_param()) {
    clear_has_item();
      ::common::DynamicParam* temp = item_.param_;
    item_.param_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::common::DynamicParam& ExprOpr::param() const {
  // @@protoc_insertion_point(field_get:common.ExprOpr.param)
  return has_param()
      ? *item_.param_
      : *reinterpret_cast< ::common::DynamicParam*>(&::common::_DynamicParam_default_instance_);
}
inline ::common::DynamicParam* ExprOpr::mutable_param() {
  if (!has_param()) {
    clear_item();
    set_has_param();
    item_.param_ = CreateMaybeMessage< ::common::DynamicParam >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:common.ExprOpr.param)
  return item_.param_;
}

// .common.Case case = 10;
inline bool ExprOpr::has_case_() const {
  return item_case() == kCase;
}
inline void ExprOpr::set_has_case_() {
  _oneof_case_[0] = kCase;
}
inline void ExprOpr::clear_case_() {
  if (has_case_()) {
    delete item_.case__;
    clear_has_item();
  }
}
inline const ::common::Case& ExprOpr::_internal_case_() const {
  return *item_.case__;
}
inline ::common::Case* ExprOpr::release_case_() {
  // @@protoc_insertion_point(field_release:common.ExprOpr.case)
  if (has_case_()) {
    clear_has_item();
      ::common::Case* temp = item_.case__;
    item_.case__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::common::Case& ExprOpr::case_() const {
  // @@protoc_insertion_point(field_get:common.ExprOpr.case)
  return has_case_()
      ? *item_.case__
      : *reinterpret_cast< ::common::Case*>(&::common::_Case_default_instance_);
}
inline ::common::Case* ExprOpr::mutable_case_() {
  if (!has_case_()) {
    clear_item();
    set_has_case_();
    item_.case__ = CreateMaybeMessage< ::common::Case >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:common.ExprOpr.case)
  return item_.case__;
}

// .common.Extract extract = 11;
inline bool ExprOpr::has_extract() const {
  return item_case() == kExtract;
}
inline void ExprOpr::set_has_extract() {
  _oneof_case_[0] = kExtract;
}
inline void ExprOpr::clear_extract() {
  if (has_extract()) {
    delete item_.extract_;
    clear_has_item();
  }
}
inline const ::common::Extract& ExprOpr::_internal_extract() const {
  return *item_.extract_;
}
inline ::common::Extract* ExprOpr::release_extract() {
  // @@protoc_insertion_point(field_release:common.ExprOpr.extract)
  if (has_extract()) {
    clear_has_item();
      ::common::Extract* temp = item_.extract_;
    item_.extract_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::common::Extract& ExprOpr::extract() const {
  // @@protoc_insertion_point(field_get:common.ExprOpr.extract)
  return has_extract()
      ? *item_.extract_
      : *reinterpret_cast< ::common::Extract*>(&::common::_Extract_default_instance_);
}
inline ::common::Extract* ExprOpr::mutable_extract() {
  if (!has_extract()) {
    clear_item();
    set_has_extract();
    item_.extract_ = CreateMaybeMessage< ::common::Extract >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:common.ExprOpr.extract)
  return item_.extract_;
}

// .common.IrDataType node_type = 12;
inline bool ExprOpr::has_node_type() const {
  return this != internal_default_instance() && node_type_ != NULL;
}
inline const ::common::IrDataType& ExprOpr::_internal_node_type() const {
  return *node_type_;
}
inline const ::common::IrDataType& ExprOpr::node_type() const {
  const ::common::IrDataType* p = node_type_;
  // @@protoc_insertion_point(field_get:common.ExprOpr.node_type)
  return p != NULL ? *p : *reinterpret_cast<const ::common::IrDataType*>(
      &::common::_IrDataType_default_instance_);
}
inline ::common::IrDataType* ExprOpr::release_node_type() {
  // @@protoc_insertion_point(field_release:common.ExprOpr.node_type)
  
  ::common::IrDataType* temp = node_type_;
  node_type_ = NULL;
  return temp;
}
inline ::common::IrDataType* ExprOpr::mutable_node_type() {
  
  if (node_type_ == NULL) {
    auto* p = CreateMaybeMessage<::common::IrDataType>(GetArenaNoVirtual());
    node_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:common.ExprOpr.node_type)
  return node_type_;
}
inline void ExprOpr::set_allocated_node_type(::common::IrDataType* node_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(node_type_);
  }
  if (node_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      node_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node_type, submessage_arena);
    }
    
  } else {
    
  }
  node_type_ = node_type;
  // @@protoc_insertion_point(field_set_allocated:common.ExprOpr.node_type)
}

inline bool ExprOpr::has_item() const {
  return item_case() != ITEM_NOT_SET;
}
inline void ExprOpr::clear_has_item() {
  _oneof_case_[0] = ITEM_NOT_SET;
}
inline ExprOpr::ItemCase ExprOpr::item_case() const {
  return ExprOpr::ItemCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression

// repeated .common.ExprOpr operators = 1;
inline int Expression::operators_size() const {
  return operators_.size();
}
inline void Expression::clear_operators() {
  operators_.Clear();
}
inline ::common::ExprOpr* Expression::mutable_operators(int index) {
  // @@protoc_insertion_point(field_mutable:common.Expression.operators)
  return operators_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::common::ExprOpr >*
Expression::mutable_operators() {
  // @@protoc_insertion_point(field_mutable_list:common.Expression.operators)
  return &operators_;
}
inline const ::common::ExprOpr& Expression::operators(int index) const {
  // @@protoc_insertion_point(field_get:common.Expression.operators)
  return operators_.Get(index);
}
inline ::common::ExprOpr* Expression::add_operators() {
  // @@protoc_insertion_point(field_add:common.Expression.operators)
  return operators_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::common::ExprOpr >&
Expression::operators() const {
  // @@protoc_insertion_point(field_list:common.Expression.operators)
  return operators_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace common

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::common::Extract_Interval> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::Extract_Interval>() {
  return ::common::Extract_Interval_descriptor();
}
template <> struct is_proto_enum< ::common::ExprOpr_Brace> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::ExprOpr_Brace>() {
  return ::common::ExprOpr_Brace_descriptor();
}
template <> struct is_proto_enum< ::common::Logical> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::Logical>() {
  return ::common::Logical_descriptor();
}
template <> struct is_proto_enum< ::common::Arithmetic> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::Arithmetic>() {
  return ::common::Arithmetic_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_expr_2eproto
